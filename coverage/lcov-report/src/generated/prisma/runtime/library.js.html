
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for src/generated/prisma/runtime/library.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../../index.html">All files</a> / <a href="index.html">src/generated/prisma/runtime</a> library.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">36.98% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>54/146</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">50.26% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>378/752</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">25.24% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>236/935</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">36.98% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>54/146</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a>
<a name='L16'></a><a href='#L16'>16</a>
<a name='L17'></a><a href='#L17'>17</a>
<a name='L18'></a><a href='#L18'>18</a>
<a name='L19'></a><a href='#L19'>19</a>
<a name='L20'></a><a href='#L20'>20</a>
<a name='L21'></a><a href='#L21'>21</a>
<a name='L22'></a><a href='#L22'>22</a>
<a name='L23'></a><a href='#L23'>23</a>
<a name='L24'></a><a href='#L24'>24</a>
<a name='L25'></a><a href='#L25'>25</a>
<a name='L26'></a><a href='#L26'>26</a>
<a name='L27'></a><a href='#L27'>27</a>
<a name='L28'></a><a href='#L28'>28</a>
<a name='L29'></a><a href='#L29'>29</a>
<a name='L30'></a><a href='#L30'>30</a>
<a name='L31'></a><a href='#L31'>31</a>
<a name='L32'></a><a href='#L32'>32</a>
<a name='L33'></a><a href='#L33'>33</a>
<a name='L34'></a><a href='#L34'>34</a>
<a name='L35'></a><a href='#L35'>35</a>
<a name='L36'></a><a href='#L36'>36</a>
<a name='L37'></a><a href='#L37'>37</a>
<a name='L38'></a><a href='#L38'>38</a>
<a name='L39'></a><a href='#L39'>39</a>
<a name='L40'></a><a href='#L40'>40</a>
<a name='L41'></a><a href='#L41'>41</a>
<a name='L42'></a><a href='#L42'>42</a>
<a name='L43'></a><a href='#L43'>43</a>
<a name='L44'></a><a href='#L44'>44</a>
<a name='L45'></a><a href='#L45'>45</a>
<a name='L46'></a><a href='#L46'>46</a>
<a name='L47'></a><a href='#L47'>47</a>
<a name='L48'></a><a href='#L48'>48</a>
<a name='L49'></a><a href='#L49'>49</a>
<a name='L50'></a><a href='#L50'>50</a>
<a name='L51'></a><a href='#L51'>51</a>
<a name='L52'></a><a href='#L52'>52</a>
<a name='L53'></a><a href='#L53'>53</a>
<a name='L54'></a><a href='#L54'>54</a>
<a name='L55'></a><a href='#L55'>55</a>
<a name='L56'></a><a href='#L56'>56</a>
<a name='L57'></a><a href='#L57'>57</a>
<a name='L58'></a><a href='#L58'>58</a>
<a name='L59'></a><a href='#L59'>59</a>
<a name='L60'></a><a href='#L60'>60</a>
<a name='L61'></a><a href='#L61'>61</a>
<a name='L62'></a><a href='#L62'>62</a>
<a name='L63'></a><a href='#L63'>63</a>
<a name='L64'></a><a href='#L64'>64</a>
<a name='L65'></a><a href='#L65'>65</a>
<a name='L66'></a><a href='#L66'>66</a>
<a name='L67'></a><a href='#L67'>67</a>
<a name='L68'></a><a href='#L68'>68</a>
<a name='L69'></a><a href='#L69'>69</a>
<a name='L70'></a><a href='#L70'>70</a>
<a name='L71'></a><a href='#L71'>71</a>
<a name='L72'></a><a href='#L72'>72</a>
<a name='L73'></a><a href='#L73'>73</a>
<a name='L74'></a><a href='#L74'>74</a>
<a name='L75'></a><a href='#L75'>75</a>
<a name='L76'></a><a href='#L76'>76</a>
<a name='L77'></a><a href='#L77'>77</a>
<a name='L78'></a><a href='#L78'>78</a>
<a name='L79'></a><a href='#L79'>79</a>
<a name='L80'></a><a href='#L80'>80</a>
<a name='L81'></a><a href='#L81'>81</a>
<a name='L82'></a><a href='#L82'>82</a>
<a name='L83'></a><a href='#L83'>83</a>
<a name='L84'></a><a href='#L84'>84</a>
<a name='L85'></a><a href='#L85'>85</a>
<a name='L86'></a><a href='#L86'>86</a>
<a name='L87'></a><a href='#L87'>87</a>
<a name='L88'></a><a href='#L88'>88</a>
<a name='L89'></a><a href='#L89'>89</a>
<a name='L90'></a><a href='#L90'>90</a>
<a name='L91'></a><a href='#L91'>91</a>
<a name='L92'></a><a href='#L92'>92</a>
<a name='L93'></a><a href='#L93'>93</a>
<a name='L94'></a><a href='#L94'>94</a>
<a name='L95'></a><a href='#L95'>95</a>
<a name='L96'></a><a href='#L96'>96</a>
<a name='L97'></a><a href='#L97'>97</a>
<a name='L98'></a><a href='#L98'>98</a>
<a name='L99'></a><a href='#L99'>99</a>
<a name='L100'></a><a href='#L100'>100</a>
<a name='L101'></a><a href='#L101'>101</a>
<a name='L102'></a><a href='#L102'>102</a>
<a name='L103'></a><a href='#L103'>103</a>
<a name='L104'></a><a href='#L104'>104</a>
<a name='L105'></a><a href='#L105'>105</a>
<a name='L106'></a><a href='#L106'>106</a>
<a name='L107'></a><a href='#L107'>107</a>
<a name='L108'></a><a href='#L108'>108</a>
<a name='L109'></a><a href='#L109'>109</a>
<a name='L110'></a><a href='#L110'>110</a>
<a name='L111'></a><a href='#L111'>111</a>
<a name='L112'></a><a href='#L112'>112</a>
<a name='L113'></a><a href='#L113'>113</a>
<a name='L114'></a><a href='#L114'>114</a>
<a name='L115'></a><a href='#L115'>115</a>
<a name='L116'></a><a href='#L116'>116</a>
<a name='L117'></a><a href='#L117'>117</a>
<a name='L118'></a><a href='#L118'>118</a>
<a name='L119'></a><a href='#L119'>119</a>
<a name='L120'></a><a href='#L120'>120</a>
<a name='L121'></a><a href='#L121'>121</a>
<a name='L122'></a><a href='#L122'>122</a>
<a name='L123'></a><a href='#L123'>123</a>
<a name='L124'></a><a href='#L124'>124</a>
<a name='L125'></a><a href='#L125'>125</a>
<a name='L126'></a><a href='#L126'>126</a>
<a name='L127'></a><a href='#L127'>127</a>
<a name='L128'></a><a href='#L128'>128</a>
<a name='L129'></a><a href='#L129'>129</a>
<a name='L130'></a><a href='#L130'>130</a>
<a name='L131'></a><a href='#L131'>131</a>
<a name='L132'></a><a href='#L132'>132</a>
<a name='L133'></a><a href='#L133'>133</a>
<a name='L134'></a><a href='#L134'>134</a>
<a name='L135'></a><a href='#L135'>135</a>
<a name='L136'></a><a href='#L136'>136</a>
<a name='L137'></a><a href='#L137'>137</a>
<a name='L138'></a><a href='#L138'>138</a>
<a name='L139'></a><a href='#L139'>139</a>
<a name='L140'></a><a href='#L140'>140</a>
<a name='L141'></a><a href='#L141'>141</a>
<a name='L142'></a><a href='#L142'>142</a>
<a name='L143'></a><a href='#L143'>143</a>
<a name='L144'></a><a href='#L144'>144</a>
<a name='L145'></a><a href='#L145'>145</a>
<a name='L146'></a><a href='#L146'>146</a>
<a name='L147'></a><a href='#L147'>147</a></td><td class="line-coverage quiet"><span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">10x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">9x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">&nbsp;
/* !!! This is code generated by Prisma. Do not edit directly. !!!
/* eslint-disable */
"use strict";var yu=Object.create;var jt=Object.defineProperty;var bu=Object.getOwnPropertyDescriptor;var Eu=Object.getOwnPropertyNames;var wu=Object.getPrototypeOf,xu=Object.prototype.hasOwnProperty;var Do=(e,r)=&gt;()=&gt;(e&amp;&amp;(r=e(e=0)),r);var ue=(e,r)=&gt;()=&gt;(r||e((r={exports:{}}).exports,r),r.exports),tr=(e,r)=&gt;{for(var t in r)jt(e,t,{get:r[t],enumerable:!0})},Oo=(e,r,t,n)=&gt;{if(r&amp;&amp;typeof r=="object"||typeof r=="function")for(let i of Eu(r))!xu.call(e,i)&amp;&amp;i!==t&amp;&amp;jt(e,i,{get:()=&gt;r[i],enumerable:!(n=bu(r,i))||n.enumerable});return e};var O=(e,r,t)=&gt;(t=e!=null?yu(wu(e))<span class="branch-0 cbranch-no" title="branch not covered" >:{},</span>Oo(r||!e||!e.__esModule?jt(t,"default",{value:e,enumerable:!0}):t,e)),vu=e=&gt;Oo(jt({},"__esModule",{value:!0}),e);var hi=ue((_g,is)=&gt;{"use strict";is.exports=(e,r=process.argv)=&gt;{let t=e.startsWith("-")<span class="branch-0 cbranch-no" title="branch not covered" >?"":</span>e.length===1<span class="branch-0 cbranch-no" title="branch not covered" >?"-":</span>"--",n=r.indexOf(t+e),i=r.indexOf("--");return n!==-1<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(i===-1||n&lt;i)}</span>});var as=ue((Ng,ss)=&gt;{"use strict";var Fc=require("node:os"),os=require("node:tty"),de=hi(),{env:G}=process,Qe;de("no-color")||de("no-colors")||de("color=false")||de("color=never")<span class="branch-0 cbranch-no" title="branch not covered" >?Qe=0:</span>(de("color")||de("colors")||de("color=true")||de("color=always")<span class="branch-0 cbranch-no" title="branch not covered" >)&amp;&amp;(Qe=1);</span>"FORCE_COLOR"in G<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(G.FORCE_COLOR==="true"?Qe=1:G.FORCE_COLOR==="false"?Qe=0:Qe=G.FORCE_COLOR.length===0?1:Math.min(parseInt(G.FORCE_COLOR,10),3));</span>function yi(e){return e===0<span class="branch-0 cbranch-no" title="branch not covered" >?!1:</span>{level:e,hasBasic:!0,has256:e&gt;=2,has16m:e&gt;=3}}function bi(e,r){if(Qe===0)<span class="branch-0 cbranch-no" title="branch not covered" >return 0;i</span>f(de("color=16m")||de("color=full")||de("color=truecolor"))<span class="branch-0 cbranch-no" title="branch not covered" >return 3;i</span>f(de("color=256"))<span class="branch-0 cbranch-no" title="branch not covered" >return 2;i</span>f(e&amp;&amp;!r<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;Qe===void 0)<span class="branch-0 cbranch-no" title="branch not covered" ></span>return 0;l</span>et t=Qe||0;if(G.TERM==="dumb")<span class="branch-0 cbranch-no" title="branch not covered" >return t;i</span>f(process.platform==="win32"){let n=Fc.release().split(".");return Number(n[0])&gt;=10&amp;&amp;Number(n[2])&gt;=10586?Number(n[2])&gt;=14931?3<span class="branch-0 cbranch-no" title="branch not covered" >:2<span class="branch-0 cbranch-no" title="branch not covered" >:</span>1<span class="branch-0 cbranch-no" title="branch not covered" >}</span>if("CI"in G)return["TRAVIS","CIRCLECI","APPVEYOR","GITLAB_CI","GITHUB_ACTIONS","BUILDKITE"].some(n=&gt;n in G)||G.CI_NAME==="codeship"?1:t;if("TEAMCITY_VERSION"in G)return/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(G.TEAMCITY_VERSION)?1:0;if(G.COLORTERM==="truecolor")return 3;if("TERM_PROGRAM"in G){let n=parseInt((G.TERM_PROGRAM_VERSION||"").split(".")[0],10);switch(G.TERM_PROGRAM){case"iTerm.app":return n&gt;=3?3:2;case"Apple_Terminal":return 2}}return/-256(color)?$/i.test(G.TERM)?2<span class="branch-0 cbranch-no" title="branch not covered" >:</span>/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(G.TERM)||"COLORTERM"in G?1:t}</span>function Mc(e){let r=bi(e,e&amp;&amp;e.isTTY);return yi(r)}ss.exports={supportsColor:Mc,stdout:yi(bi(!0,os.isatty(1))),stderr:yi(bi(!0,os.isatty(2)))}});var cs=ue((Lg,us)=&gt;{"use strict";var $c=as(),br=hi();<span class="fstat-no" title="function not covered" >function ls(e){if(/^\d{3,4}$/.test(e)){let t=/(\d{1,2})(\d{2})/.exec(e)||[];return{major:0,minor:parseInt(t[1],10),patch:parseInt(t[2],10)}}let r=(e||"").split(".").map(t=&gt;parseInt(t,10));return{major:r[0],minor:r[1],patch:r[2]}}f</span>unction Ei(e){let{CI:r,FORCE_HYPERLINK:t,NETLIFY:n,TEAMCITY_VERSION:i,TERM_PROGRAM:o,TERM_PROGRAM_VERSION:s,VTE_VERSION:a,TERM:l}=process.env;if(t)<span class="branch-0 cbranch-no" title="branch not covered" >return!(t.length&gt;0&amp;&amp;parseInt(t,10)===0);i</span>f(br("no-hyperlink")||br("no-hyperlinks")||br("hyperlink=false")||br("hyperlink=never"))<span class="branch-0 cbranch-no" title="branch not covered" >return!1;i</span>f(br("hyperlink=true")||br("hyperlink=always")||n)<span class="branch-0 cbranch-no" title="branch not covered" >return!0;i</span>f(!$c.supportsColor(e)||e&amp;&amp;!e.isTTY)<span class="branch-0 cbranch-no" title="branch not covered" >return!1;i</span>f("WT_SESSION"in process.env)<span class="branch-0 cbranch-no" title="branch not covered" >return!0;i</span>f(process.platform==="win32"<span class="branch-0 cbranch-no" title="branch not covered" >||r<span class="branch-0 cbranch-no" title="branch not covered" >|</span>|i)</span>return!1<span class="branch-0 cbranch-no" title="branch not covered" >;if(o){let u=ls(s||"");switch(o){case"iTerm.app":return u.major===3?u.minor&gt;=1:u.major&gt;3;case"WezTerm":return u.major&gt;=20200620;case"vscode":return u.major&gt;1||u.major===1&amp;&amp;u.minor&gt;=72;case"ghostty":return!0}}if(a){if(a==="0.50.0")return!1;let u=ls(a);return u.major&gt;0||u.minor&gt;=50}switch(l){case"alacritty":return!0<span class="branch-0 cbranch-no" title="branch not covered" >}r</span>eturn!1}u</span>s.exports={supportsHyperlink:Ei,stdout:Ei(process.stdout),stderr:Ei(process.stderr)}});var ps=ue((Kg,qc)=&gt;{qc.exports={name:"@prisma/internals",version:"6.16.2",description:"This package is intended for Prisma's internal use",main:"dist/index.js",types:"dist/index.d.ts",repository:{type:"git",url:"https://github.com/prisma/prisma.git",directory:"packages/internals"},homepage:"https://www.prisma.io",author:"Tim Suchanek &lt;suchanek@prisma.io&gt;",bugs:"https://github.com/prisma/prisma/issues",license:"Apache-2.0",scripts:{dev:"DEV=true tsx helpers/build.ts",build:"tsx helpers/build.ts",test:"dotenv -e ../../.db.env -- jest --silent",prepublishOnly:"pnpm run build"},files:["README.md","dist","!**/libquery_engine*","!dist/get-generators/engines/*","scripts"],devDependencies:{"@babel/helper-validator-identifier":"7.25.9","@opentelemetry/api":"1.9.0","@swc/core":"1.11.5","@swc/jest":"0.2.37","@types/babel__helper-validator-identifier":"7.15.2","@types/jest":"29.5.14","@types/node":"18.19.76","@types/resolve":"1.20.6",archiver:"6.0.2","checkpoint-client":"1.1.33","cli-truncate":"4.0.0",dotenv:"16.5.0",empathic:"2.0.0","escape-string-regexp":"5.0.0",execa:"5.1.1","fast-glob":"3.3.3","find-up":"7.0.0","fp-ts":"2.16.9","fs-extra":"11.3.0","fs-jetpack":"5.1.0","global-directory":"4.0.0",globby:"11.1.0","identifier-regex":"1.0.0","indent-string":"4.0.0","is-windows":"1.0.2","is-wsl":"3.1.0",jest:"29.7.0","jest-junit":"16.0.0",kleur:"4.1.5","mock-stdin":"1.0.0","new-github-issue-url":"0.2.1","node-fetch":"3.3.2","npm-packlist":"5.1.3",open:"7.4.2","p-map":"4.0.0",resolve:"1.22.10","string-width":"7.2.0","strip-indent":"4.0.0","temp-dir":"2.0.0",tempy:"1.0.1","terminal-link":"4.0.0",tmp:"0.2.3","ts-pattern":"5.6.2","ts-toolbelt":"9.6.0",typescript:"5.4.5",yarn:"1.22.22"},dependencies:{"@prisma/config":"workspace:*","@prisma/debug":"workspace:*","@prisma/dmmf":"workspace:*","@prisma/driver-adapter-utils":"workspace:*","@prisma/engines":"workspace:*","@prisma/fetch-engine":"workspace:*","@prisma/generator":"workspace:*","@prisma/generator-helper":"workspace:*","@prisma/get-platform":"workspace:*","@prisma/prisma-schema-wasm":"6.16.0-7.1c57fdcd7e44b29b9313256c76699e91c3ac3c43","@prisma/schema-engine-wasm":"6.16.0-7.1c57fdcd7e44b29b9313256c76699e91c3ac3c43","@prisma/schema-files-loader":"workspace:*",arg:"5.0.2",prompts:"2.4.2"},peerDependencies:{typescript:"&gt;=5.1.0"},peerDependenciesMeta:{typescript:{optional:!0}},sideEffects:!1}});var Ti=ue((gh,Qc)=&gt;{Qc.exports={name:"@prisma/engines-version",version:"6.16.0-7.1c57fdcd7e44b29b9313256c76699e91c3ac3c43",main:"index.js",types:"index.d.ts",license:"Apache-2.0",author:"Tim Suchanek &lt;suchanek@prisma.io&gt;",prisma:{enginesVersion:"1c57fdcd7e44b29b9313256c76699e91c3ac3c43"},repository:{type:"git",url:"https://github.com/prisma/engines-wrapper.git",directory:"packages/engines-version"},devDependencies:{"@types/node":"18.19.76",typescript:"4.9.5"},files:["index.js","index.d.ts"],scripts:{build:"tsc -d"}}});var on=ue(nn=&gt;{"use strict";Object.defineProperty(nn,"__esModule",{value:!0});nn.enginesVersion=void 0;nn.enginesVersion=Ti().prisma.enginesVersion});var hs=ue((Ih,gs)=&gt;{"use strict";gs.exports=<span class="fstat-no" title="function not covered" >e=&gt;{let r=e.match(/^[ \t]*(?=\S)/gm);return r?r.reduce((t,n)=&gt;Math.min(t,n.length),1/0):0}}</span>);var Di=ue((kh,Es)=&gt;{"use strict";Es.exports=<span class="fstat-no" title="function not covered" >(e,r=1,t)=&gt;{if(t={indent:" ",includeEmptyLines:!1,...t},typeof e!="string")throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e}\``);if(typeof r!="number")throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof r}\``);if(typeof t.indent!="string")throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof t.indent}\``);if(r===0)return e;let n=t.includeEmptyLines?/^/gm:/^(?!\s*$)/gm;return e.replace(n,t.indent.repeat(r))}}</span>);var vs=ue((jh,tp)=&gt;{tp.exports={name:"dotenv",version:"16.5.0",description:"Loads environment variables from .env file",main:"lib/main.js",types:"lib/main.d.ts",exports:{".":{types:"./lib/main.d.ts",require:"./lib/main.js",default:"./lib/main.js"},"./config":"./config.js","./config.js":"./config.js","./lib/env-options":"./lib/env-options.js","./lib/env-options.js":"./lib/env-options.js","./lib/cli-options":"./lib/cli-options.js","./lib/cli-options.js":"./lib/cli-options.js","./package.json":"./package.json"},scripts:{"dts-check":"tsc --project tests/types/tsconfig.json",lint:"standard",pretest:"npm run lint &amp;&amp; npm run dts-check",test:"tap run --allow-empty-coverage --disable-coverage --timeout=60000","test:coverage":"tap run --show-full-coverage --timeout=60000 --coverage-report=lcov",prerelease:"npm test",release:"standard-version"},repository:{type:"git",url:"git://github.com/motdotla/dotenv.git"},homepage:"https://github.com/motdotla/dotenv#readme",funding:"https://dotenvx.com",keywords:["dotenv","env",".env","environment","variables","config","settings"],readmeFilename:"README.md",license:"BSD-2-Clause",devDependencies:{"@types/node":"^18.11.3",decache:"^4.6.2",sinon:"^14.0.1",standard:"^17.0.0","standard-version":"^9.5.0",tap:"^19.2.0",typescript:"^4.8.4"},engines:{node:"&gt;=12"},browser:{fs:!1}}});var As=ue((Bh,_e)=&gt;{"use strict";var Fi=require("node:fs"),Mi=require("node:path"),np=require("node:os"),ip=require("node:crypto"),op=vs(),Ts=op.version,sp=/(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;function ap(e){let r={},t=e.toString();t=t.replace(/\r\n?/mg,`
`);let n;for(;(n=sp.exec(t))!=null;){let i=n[1],o=n[2]<span class="branch-0 cbranch-no" title="branch not covered" >||"";</span>o=o.trim();let s=o[0];o=o.replace(/^(['"`])([\s\S]*)\1$/mg,"$2"),s==='"'&amp;&amp;(o=o.replace(/\\n/g,`
`),o=o.replace(/\\r/g,"\r")),r[i]=o}return r}<span class="fstat-no" title="function not covered" >function lp(e){let r=Rs(e),t=B.configDotenv({path:r});if(!t.parsed){let s=new Error(`MISSING_DATA: Cannot parse ${r} for an unknown reason`);throw s.code="MISSING_DATA",s}let n=Ss(e).split(","),i=n.length,o;for(let s=0;s&lt;i;s++)try{let a=n[s].trim(),l=cp(t,a);o=B.decrypt(l.ciphertext,l.key);break}catch(a){if(s+1&gt;=i)throw a}return B.parse(o)}<span class="fstat-no" title="function not covered" >f</span>unction up(e){console.log(`[dotenv@${Ts}][WARN] ${e}`)}<span class="fstat-no" title="function not covered" >f</span>unction ot(e){console.log(`[dotenv@${Ts}][DEBUG] ${e}`)}f</span>unction Ss(e){return e&amp;&amp;e.DOTENV_KEY<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;e.DOTENV_KEY.length&gt;0<span class="branch-0 cbranch-no" title="branch not covered" >?</span>e.DOTENV_KEY:</span>process.env.DOTENV_KEY<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;process.env.DOTENV_KEY.length&gt;0<span class="branch-0 cbranch-no" title="branch not covered" >?</span>process.env.DOTENV_KEY:</span>""}<span class="fstat-no" title="function not covered" >function cp(e,r){let t;try{t=new URL(r)}catch(a){if(a.code==="ERR_INVALID_URL"){let l=new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");throw l.code="INVALID_DOTENV_KEY",l}throw a}let n=t.password;if(!n){let a=new Error("INVALID_DOTENV_KEY: Missing key part");throw a.code="INVALID_DOTENV_KEY",a}let i=t.searchParams.get("environment");if(!i){let a=new Error("INVALID_DOTENV_KEY: Missing environment part");throw a.code="INVALID_DOTENV_KEY",a}let o=`DOTENV_VAULT_${i.toUpperCase()}`,s=e.parsed[o];if(!s){let a=new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${o} in your .env.vault file.`);throw a.code="NOT_FOUND_DOTENV_ENVIRONMENT",a}return{ciphertext:s,key:n}}<span class="fstat-no" title="function not covered" >f</span>unction Rs(e){let r=null;if(e&amp;&amp;e.path&amp;&amp;e.path.length&gt;0)if(Array.isArray(e.path))for(let t of e.path)Fi.existsSync(t)&amp;&amp;(r=t.endsWith(".vault")?t:`${t}.vault`);else r=e.path.endsWith(".vault")?e.path:`${e.path}.vault`;else r=Mi.resolve(process.cwd(),".env.vault");return Fi.existsSync(r)?r:null}f</span>unction Ps(e){return e[0]==="~"<span class="branch-0 cbranch-no" title="branch not covered" >?Mi.join(np.homedir(),e.slice(1)):</span>e}<span class="fstat-no" title="function not covered" >function pp(e){!!(e&amp;&amp;e.debug)&amp;&amp;ot("Loading env from encrypted .env.vault");let t=B._parseVault(e),n=process.env;return e&amp;&amp;e.processEnv!=null&amp;&amp;(n=e.processEnv),B.populate(n,t,e),{parsed:t}}f</span>unction dp(e){let r=Mi.resolve(process.cwd(),".env"),t="utf8",n=!!(e&amp;&amp;e.debug);e&amp;&amp;e.encoding<span class="branch-0 cbranch-no" title="branch not covered" >?t=e.encoding:</span>n<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;ot("No encoding is specified. UTF-8 is used by default");</span>let i=[r];if(e&amp;&amp;e.path)if(!Array.isArray(e.path))i=[Ps(e.path)];<span class="branch-0 cbranch-no" title="branch not covered" >else{i=[];for(let l of e.path)i.push(Ps(l))}l</span>et o,s={};for(let l of i)try{let u=B.parse(Fi.readFileSync(l,{encoding:t}));B.populate(s,u,e)}<span class="branch-0 cbranch-no" title="branch not covered" >catch(u){n&amp;&amp;ot(`Failed to load ${l} ${u.message}`),o=u}l</span>et a=process.env;return e&amp;&amp;e.processEnv!=null<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(a=e.processEnv),</span>B.populate(a,s,e),o<span class="branch-0 cbranch-no" title="branch not covered" >?{parsed:s,error:o}:</span>{parsed:s}}function mp(e){if(Ss(e).length===0)return B.configDotenv(e)<span class="branch-0 cbranch-no" title="branch not covered" >;let r=Rs(e);return r?B._configVault(e)<span class="branch-0 cbranch-no" title="branch not covered" >:</span>(up(`You set DOTENV_KEY but you are missing a .env.vault file at ${r}. Did you forget to build it?`),B.configDotenv(e))}<span class="fstat-no" title="function not covered" ></span>function fp(e,r){let t=Buffer.from(r.slice(-64),"hex"),n=Buffer.from(e,"base64"),i=n.subarray(0,12),o=n.subarray(-16);n=n.subarray(12,-16);try{let s=ip.createDecipheriv("aes-256-gcm",t,i);return s.setAuthTag(o),`${s.update(n)}${s.final()}`}catch(s){let a=s instanceof RangeError,l=s.message==="Invalid key length",u=s.message==="Unsupported state or unable to authenticate data";if(a||l){let c=new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");throw c.code="INVALID_DOTENV_KEY",c}else if(u){let c=new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");throw c.code="DECRYPTION_FAILED",c}else throw s}}f</span>unction gp(e,r,t={}){let n=!!(t&amp;&amp;t.debug),i=!!(t&amp;&amp;t.override);if(typeof r!="object")<span class="branch-0 cbranch-no" title="branch not covered" >{let o=new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");throw o.code="OBJECT_REQUIRED",o}f</span>or(let o of Object.keys(r))Object.prototype.hasOwnProperty.call(e,o)?(i===!0<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(e[o]=r[o]),</span>n<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;ot(i===!0?`"${o}" is already defined and WAS overwritten`:`"${o}" is already defined and was NOT overwritten`))</span>:e[o]=r[o]}var B={configDotenv:dp,_configVault:pp,_parseVault:lp,config:mp,decrypt:fp,parse:ap,populate:gp};_e.exports.configDotenv=B.configDotenv;_e.exports._configVault=B._configVault;_e.exports._parseVault=B._parseVault;_e.exports.config=B.config;_e.exports.decrypt=B.decrypt;_e.exports.parse=B.parse;_e.exports.populate=B.populate;_e.exports=B});var Os=ue((Kh,cn)=&gt;{"use strict";cn.exports=<span class="fstat-no" title="function not covered" >(e={})=&gt;{let r;if(e.repoUrl)r=e.repoUrl;else if(e.user&amp;&amp;e.repo)r=`https://github.com/${e.user}/${e.repo}`;else throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");let t=new URL(`${r}/issues/new`),n=["body","title","labels","template","milestone","assignee","projects"];for(let i of n){let o=e[i];if(o!==void 0){if(i==="labels"||i==="projects"){if(!Array.isArray(o))throw new TypeError(`The \`${i}\` option should be an array`);o=o.join(",")}t.searchParams.set(i,o)}}return t.toString()};</span>cn.exports.default=cn.exports});var Ki=ue((vb,ea)=&gt;{"use strict";ea.exports=function(){<span class="fstat-no" title="function not covered" >function e(r,t,n,i,o){return r&lt;t||n&lt;t?r&gt;n?n+1:r+1:i===o?t:t+1}r</span>eturn function(r,t){if(r===t)return 0;if(r.length&gt;t.length){var n=r;r=t,t=n}for(var i=r.length,o=t.length;i&gt;0&amp;&amp;r.charCodeAt(i-1)===t.charCodeAt(o-1);)i--,o--;for(var s=0;s&lt;i&amp;&amp;r.charCodeAt(s)===t.charCodeAt(s);)s++;if(i-=s,o-=s,i===0||o&lt;3)return o;var a=0,l,u,c,p,d,f,h,g,I,T,S,b,D=[];for(l=0;l&lt;i;l++)D.push(l+1),D.push(r.charCodeAt(s+l));for(var me=D.length-1;a&lt;o-3;)for(I=t.charCodeAt(s+(u=a)),T=t.charCodeAt(s+(c=a+1)),S=t.charCodeAt(s+(p=a+2)),b=t.charCodeAt(s+(d=a+3)),f=a+=4,l=0;l&lt;me;l+=2)h=D[l],g=D[l+1],u=e(h,u,c,I,g),c=e(u,c,p,T,g),p=e(c,p,d,S,g),f=e(p,d,f,b,g),D[l]=f,d=p,p=c,c=u,u=h;for(;a&lt;o;)for(I=t.charCodeAt(s+(u=a)),f=++a,l=0;l&lt;me;l+=2)h=D[l],D[l]=f=e(h,u,f,I,D[l+1]),u=h;return f}}()});var oa=Do(()=&gt;{"use strict"});var sa=Do(()=&gt;{"use strict"});var jf={};tr(jf,{DMMF:<span class="fstat-no" title="function not covered" >()=&gt;ct,</span>Debug:()=&gt;N,Decimal:()=&gt;Fe,Extensions:()=&gt;ni,MetricsClient:<span class="fstat-no" title="function not covered" >()=&gt;Lr,</span>PrismaClientInitializationError:()=&gt;P,PrismaClientKnownRequestError:()=&gt;z,PrismaClientRustPanicError:()=&gt;ae,PrismaClientUnknownRequestError:()=&gt;V,PrismaClientValidationError:()=&gt;Z,Public:()=&gt;ii,Sql:<span class="fstat-no" title="function not covered" >()=&gt;ie,</span>createParam:()=&gt;va,defineDmmfProperty:()=&gt;Ca,deserializeJsonResponse:<span class="fstat-no" title="function not covered" >()=&gt;Vr,</span>deserializeRawResult:<span class="fstat-no" title="function not covered" >()=&gt;Xn,</span>dmmfToRuntimeDataModel:<span class="fstat-no" title="function not covered" >()=&gt;Ns,</span>empty:()=&gt;Oa,getPrismaClient:()=&gt;fu,getRuntime:()=&gt;Kn,join:()=&gt;Da,makeStrictEnum:()=&gt;gu,makeTypedQueryFactory:<span class="fstat-no" title="function not covered" >()=&gt;Ia,</span>objectEnumValues:()=&gt;On,raw:()=&gt;no,serializeJsonQuery:<span class="fstat-no" title="function not covered" >()=&gt;$n,</span>skip:()=&gt;Mn,sqltag:()=&gt;io,warnEnvConflicts:()=&gt;hu,warnOnce:()=&gt;at});module.exports=vu(jf);var ni={};tr(ni,{defineExtension:()=&gt;ko,getExtensionContext:()=&gt;_o});<span class="fstat-no" title="function not covered" >function ko(e){return typeof e=="function"?e:r=&gt;r.$extends(e)}<span class="fstat-no" title="function not covered" >f</span>unction _o(e){return e}v</span>ar ii={};tr(ii,{validator:()=&gt;No});<span class="fstat-no" title="function not covered" >function No(...e){return r=&gt;r}v</span>ar Bt={};tr(Bt,{$:<span class="fstat-no" title="function not covered" >()=&gt;qo,</span>bgBlack:<span class="fstat-no" title="function not covered" >()=&gt;ku,</span>bgBlue:<span class="fstat-no" title="function not covered" >()=&gt;Fu,</span>bgCyan:<span class="fstat-no" title="function not covered" >()=&gt;$u,</span>bgGreen:<span class="fstat-no" title="function not covered" >()=&gt;Nu,</span>bgMagenta:<span class="fstat-no" title="function not covered" >()=&gt;Mu,</span>bgRed:<span class="fstat-no" title="function not covered" >()=&gt;_u,</span>bgWhite:<span class="fstat-no" title="function not covered" >()=&gt;qu,</span>bgYellow:<span class="fstat-no" title="function not covered" >()=&gt;Lu,</span>black:<span class="fstat-no" title="function not covered" >()=&gt;Cu,</span>blue:<span class="fstat-no" title="function not covered" >()=&gt;nr,</span>bold:<span class="fstat-no" title="function not covered" >()=&gt;W,</span>cyan:<span class="fstat-no" title="function not covered" >()=&gt;De,</span>dim:<span class="fstat-no" title="function not covered" >()=&gt;Ce,</span>gray:<span class="fstat-no" title="function not covered" >()=&gt;Hr,</span>green:<span class="fstat-no" title="function not covered" >()=&gt;qe,</span>grey:<span class="fstat-no" title="function not covered" >()=&gt;Ou,</span>hidden:<span class="fstat-no" title="function not covered" >()=&gt;Ru,</span>inverse:<span class="fstat-no" title="function not covered" >()=&gt;Su,</span>italic:<span class="fstat-no" title="function not covered" >()=&gt;Tu,</span>magenta:<span class="fstat-no" title="function not covered" >()=&gt;Iu,</span>red:<span class="fstat-no" title="function not covered" >()=&gt;ce,</span>reset:<span class="fstat-no" title="function not covered" >()=&gt;Pu,</span>strikethrough:<span class="fstat-no" title="function not covered" >()=&gt;Au,</span>underline:<span class="fstat-no" title="function not covered" >()=&gt;Y,</span>white:<span class="fstat-no" title="function not covered" >()=&gt;Du,</span>yellow:<span class="fstat-no" title="function not covered" >()=&gt;Ie}</span>);var oi,Lo,Fo,Mo,$o=!0;typeof process&lt;"u"&amp;&amp;({FORCE_COLOR:oi,NODE_DISABLE_COLORS:Lo,NO_COLOR:Fo,TERM:Mo}=process.env<span class="branch-0 cbranch-no" title="branch not covered" >||{},</span>$o=process.stdout&amp;&amp;process.stdout.isTTY);var qo={enabled:!Lo&amp;&amp;Fo==null&amp;&amp;Mo!=="dumb"&amp;&amp;(oi!=null<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;oi!=="0"|</span>|$o)};function F(e,r){let t=new RegExp(`\\x1b\\[${r}m`,"g"),n=`\x1B[${e}m`,i=`\x1B[${r}m`;return function(o){return!qo.enabled||o==null<span class="branch-0 cbranch-no" title="branch not covered" >?o:</span>n+(~(""+o).indexOf(i)<span class="branch-0 cbranch-no" title="branch not covered" >?o.replace(t,i+n):</span>o)+i}}var Pu=F(0,0),W=F(1,22),Ce=F(2,22),Tu=F(3,23),Y=F(4,24),Su=F(7,27),Ru=F(8,28),Au=F(9,29),Cu=F(30,39),ce=F(31,39),qe=F(32,39),Ie=F(33,39),nr=F(34,39),Iu=F(35,39),De=F(36,39),Du=F(37,39),Hr=F(90,39),Ou=F(90,39),ku=F(40,49),_u=F(41,49),Nu=F(42,49),Lu=F(43,49),Fu=F(44,49),Mu=F(45,49),$u=F(46,49),qu=F(47,49);var Vu=100,Vo=["green","yellow","blue","magenta","cyan","red"],Yr=[],jo=Date.now(),ju=0,si=typeof process&lt;"u"?process.env<span class="branch-0 cbranch-no" title="branch not covered" >:{};</span>globalThis.DEBUG??=si.DEBUG??"";globalThis.DEBUG_COLORS??=si.DEBUG_COLORS<span class="branch-0 cbranch-no" title="branch not covered" >?si.DEBUG_COLORS==="true":</span>!0;var zr={<span class="fstat-no" title="function not covered" >enable(e){typeof e=="string"&amp;&amp;(globalThis.DEBUG=e)},<span class="fstat-no" title="function not covered" ></span>disable(){let e=globalThis.DEBUG;return globalThis.DEBUG="",e},</span>enabled(e){let r=globalThis.DEBUG.split(",").map(i=&gt;i.replace(/[.+?^${}()|[\]\\]/g,"\\$&amp;")),t=r.some(i=&gt;i===""<span class="branch-0 cbranch-no" title="branch not covered" >||i[0]==="-"?</span>!1<span class="branch-0 cbranch-no" title="branch not covered" >:e.match(RegExp(i.split("*").join(".*")+"$")))</span>,n=r.some(i=&gt;i===""<span class="branch-0 cbranch-no" title="branch not covered" >||i[0]!=="-"?</span>!1<span class="branch-0 cbranch-no" title="branch not covered" >:e.match(RegExp(i.slice(1).split("*").join(".*")+"$")))</span>;return t<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;!n}</span>,log:<span class="fstat-no" title="function not covered" >(...e)=&gt;{let[r,t,...n]=e;(console.warn??console.log)(`${r} ${t}`,...n)},</span>formatters:{}};function Bu(e){let r={color:Vo[ju++%Vo.length],enabled:zr.enabled(e),namespace:e,log:zr.log,extend:<span class="fstat-no" title="function not covered" >()=&gt;{}}</span>,t=(...n)=&gt;{let{enabled:i,namespace:o,color:s,log:a}=r;if(n.length!==0&amp;&amp;Yr.push([o,...n]),Yr.length&gt;Vu&amp;&amp;Yr.shift(),zr.enabled(o)||i)<span class="branch-0 cbranch-no" title="branch not covered" >{let l=n.map(c=&gt;typeof c=="string"?c:Uu(c)),u=`+${Date.now()-jo}ms`;jo=Date.now(),globalThis.DEBUG_COLORS?a(Bt[s](W(o)),...l,Bt[s](u)):a(o,...l,u)}}</span>;return new Proxy(t,{get:<span class="fstat-no" title="function not covered" >(n,i)=&gt;r[i],</span>set:<span class="fstat-no" title="function not covered" >(n,i,o)=&gt;r[i]=o}</span>)}var N=new Proxy(Bu,{get:(e,r)=&gt;zr[r],set:<span class="fstat-no" title="function not covered" >(e,r,t)=&gt;zr[r]=t}</span>);<span class="fstat-no" title="function not covered" >function Uu(e,r=2){let t=new Set;return JSON.stringify(e,(n,i)=&gt;{if(typeof i=="object"&amp;&amp;i!==null){if(t.has(i))return"[Circular *]";t.add(i)}else if(typeof i=="bigint")return i.toString();return i},r)}<span class="fstat-no" title="function not covered" >f</span>unction Bo(e=7500){let r=Yr.map(([t,...n])=&gt;`${t} ${n.map(i=&gt;typeof i=="string"?i:JSON.stringify(i)).join(" ")}`).join(`</span>
`);return r.length&lt;e?r:r.slice(-e)}<span class="fstat-no" title="function not covered" >function Uo(){Yr.length=0}v</span>ar gr=N;var Go=O(require("node:fs"));function ai(){let e=process.env.PRISMA_QUERY_ENGINE_LIBRARY;if(!(e<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;Go.default.existsSync(e))</span>&amp;&amp;process.arch==="ia32")<span class="branch-0 cbranch-no" title="branch not covered" >throw new Error('The default query engine type (Node-API, "library") is currently not supported for 32bit Node. Please set `engineType = "binary"` in the "generator" block of your "schema.prisma" file (or use the environment variables "PRISMA_CLIENT_ENGINE_TYPE=binary" and/or "PRISMA_CLI_QUERY_ENGINE_TYPE=binary".)')}v</span>ar li=["darwin","darwin-arm64","debian-openssl-1.0.x","debian-openssl-1.1.x","debian-openssl-3.0.x","rhel-openssl-1.0.x","rhel-openssl-1.1.x","rhel-openssl-3.0.x","linux-arm64-openssl-1.1.x","linux-arm64-openssl-1.0.x","linux-arm64-openssl-3.0.x","linux-arm-openssl-1.1.x","linux-arm-openssl-1.0.x","linux-arm-openssl-3.0.x","linux-musl","linux-musl-openssl-3.0.x","linux-musl-arm64-openssl-1.1.x","linux-musl-arm64-openssl-3.0.x","linux-nixos","linux-static-x64","linux-static-arm64","windows","freebsd11","freebsd12","freebsd13","freebsd14","freebsd15","openbsd","netbsd","arm"];var Ut="libquery_engine";function Gt(e,r){let t=r==="url";return e.includes("windows")?t<span class="branch-0 cbranch-no" title="branch not covered" >?"query_engine.dll.node":</span>`query_engine-${e}.dll.node`<span class="branch-0 cbranch-no" title="branch not covered" >:e.includes("darwin")?t?`${Ut}.dylib.node`:`${Ut}-${e}.dylib.node`:t?`${Ut}.so.node`:`${Ut}-${e}.so.node`}</span>var Ko=O(require("node:child_process")),mi=O(require("node:fs/promises")),Ht=O(require("node:os"));var Oe=Symbol.for("@ts-pattern/matcher"),Gu=Symbol.for("@ts-pattern/isVariadic"),Wt="@ts-pattern/anonymous-select-key",ui=<span class="fstat-no" title="function not covered" >e=&gt;!!(e&amp;&amp;typeof e=="object"),</span>Qt=<span class="fstat-no" title="function not covered" >e=&gt;e&amp;&amp;!!e[Oe],</span>Ee=<span class="fstat-no" title="function not covered" >(e,r,t)=&gt;{if(Qt(e)){let n=e[Oe](),{matched:i,selections:o}=n.match(r);return i&amp;&amp;o&amp;&amp;Object.keys(o).forEach(s=&gt;t(s,o[s])),i}if(ui(e)){if(!ui(r))return!1;if(Array.isArray(e)){if(!Array.isArray(r))return!1;let n=[],i=[],o=[];for(let s of e.keys()){let a=e[s];Qt(a)&amp;&amp;a[Gu]?o.push(a):o.length?i.push(a):n.push(a)}if(o.length){if(o.length&gt;1)throw new Error("Pattern error: Using `...P.array(...)` several times in a single pattern is not allowed.");if(r.length&lt;n.length+i.length)return!1;let s=r.slice(0,n.length),a=i.length===0?[]:r.slice(-i.length),l=r.slice(n.length,i.length===0?1/0:-i.length);return n.every((u,c)=&gt;Ee(u,s[c],t))&amp;&amp;i.every((u,c)=&gt;Ee(u,a[c],t))&amp;&amp;(o.length===0||Ee(o[0],l,t))}return e.length===r.length&amp;&amp;e.every((s,a)=&gt;Ee(s,r[a],t))}return Reflect.ownKeys(e).every(n=&gt;{let i=e[n];return(n in r||Qt(o=i)&amp;&amp;o[Oe]().matcherType==="optional")&amp;&amp;Ee(i,r[n],t);var o})}return Object.is(r,e)},</span>Ge=<span class="fstat-no" title="function not covered" >e=&gt;{var r,t,n;return ui(e)?Qt(e)?(r=(t=(n=e[Oe]()).getSelectionKeys)==null?void 0:t.call(n))!=null?r:[]:Array.isArray(e)?Zr(e,Ge):Zr(Object.values(e),Ge):[]},</span>Zr=<span class="fstat-no" title="function not covered" >(e,r)=&gt;e.reduce((t,n)=&gt;t.concat(r(n)),[]);</span>function pe(e){return Object.assign(e,{optional:<span class="fstat-no" title="function not covered" >()=&gt;Qu(e),</span>and:<span class="fstat-no" title="function not covered" >r=&gt;q(e,r),</span>or:<span class="fstat-no" title="function not covered" >r=&gt;Wu(e,r),</span>select:<span class="fstat-no" title="function not covered" >r=&gt;r===void 0?Qo(e):Qo(r,e)}</span>)}<span class="fstat-no" title="function not covered" >function Qu(e){return pe({[Oe]:()=&gt;({match:r=&gt;{let t={},n=(i,o)=&gt;{t[i]=o};return r===void 0?(Ge(e).forEach(i=&gt;n(i,void 0)),{matched:!0,selections:t}):{matched:Ee(e,r,n),selections:t}},getSelectionKeys:()=&gt;Ge(e),matcherType:"optional"})})}<span class="fstat-no" title="function not covered" >f</span>unction q(...e){return pe({[Oe]:()=&gt;({match:r=&gt;{let t={},n=(i,o)=&gt;{t[i]=o};return{matched:e.every(i=&gt;Ee(i,r,n)),selections:t}},getSelectionKeys:()=&gt;Zr(e,Ge),matcherType:"and"})})}<span class="fstat-no" title="function not covered" >f</span>unction Wu(...e){return pe({[Oe]:()=&gt;({match:r=&gt;{let t={},n=(i,o)=&gt;{t[i]=o};return Zr(e,Ge).forEach(i=&gt;n(i,void 0)),{matched:e.some(i=&gt;Ee(i,r,n)),selections:t}},getSelectionKeys:()=&gt;Zr(e,Ge),matcherType:"or"})})}f</span>unction A(e){return{[Oe]:<span class="fstat-no" title="function not covered" >()=&gt;({match:r=&gt;({matched:!!e(r)})})}</span>}<span class="fstat-no" title="function not covered" >function Qo(...e){let r=typeof e[0]=="string"?e[0]:void 0,t=e.length===2?e[1]:typeof e[0]=="string"?void 0:e[0];return pe({[Oe]:()=&gt;({match:n=&gt;{let i={[r??Wt]:n};return{matched:t===void 0||Ee(t,n,(o,s)=&gt;{i[o]=s}),selections:i}},getSelectionKeys:()=&gt;[r??Wt].concat(t===void 0?[]:Ge(t))})})}<span class="fstat-no" title="function not covered" >f</span>unction ye(e){return typeof e=="number"}<span class="fstat-no" title="function not covered" >f</span>unction Ve(e){return typeof e=="string"}<span class="fstat-no" title="function not covered" >f</span>unction je(e){return typeof e=="bigint"}v</span>ar eg=pe(A(function(e){return!0}));var Be=e=&gt;Object.assign(pe(e),{startsWith:<span class="fstat-no" title="function not covered" >r=&gt;{return Be(q(e,(t=r,A(n=&gt;Ve(n)&amp;&amp;n.startsWith(t)))));var t},</span>endsWith:<span class="fstat-no" title="function not covered" >r=&gt;{return Be(q(e,(t=r,A(n=&gt;Ve(n)&amp;&amp;n.endsWith(t)))));var t},</span>minLength:<span class="fstat-no" title="function not covered" >r=&gt;Be(q(e,(t=&gt;A(n=&gt;Ve(n)&amp;&amp;n.length&gt;=t))(r))),</span>length:<span class="fstat-no" title="function not covered" >r=&gt;Be(q(e,(t=&gt;A(n=&gt;Ve(n)&amp;&amp;n.length===t))(r))),</span>maxLength:<span class="fstat-no" title="function not covered" >r=&gt;Be(q(e,(t=&gt;A(n=&gt;Ve(n)&amp;&amp;n.length&lt;=t))(r))),</span>includes:<span class="fstat-no" title="function not covered" >r=&gt;{return Be(q(e,(t=r,A(n=&gt;Ve(n)&amp;&amp;n.includes(t)))));var t},</span>regex:<span class="fstat-no" title="function not covered" >r=&gt;{return Be(q(e,(t=r,A(n=&gt;Ve(n)&amp;&amp;!!n.match(t)))));var t}}</span>),rg=Be(A(Ve)),be=e=&gt;Object.assign(pe(e),{between:<span class="fstat-no" title="function not covered" >(r,t)=&gt;be(q(e,((n,i)=&gt;A(o=&gt;ye(o)&amp;&amp;n&lt;=o&amp;&amp;i&gt;=o))(r,t))),</span>lt:<span class="fstat-no" title="function not covered" >r=&gt;be(q(e,(t=&gt;A(n=&gt;ye(n)&amp;&amp;n&lt;t))(r))),</span>gt:<span class="fstat-no" title="function not covered" >r=&gt;be(q(e,(t=&gt;A(n=&gt;ye(n)&amp;&amp;n&gt;t))(r))),</span>lte:<span class="fstat-no" title="function not covered" >r=&gt;be(q(e,(t=&gt;A(n=&gt;ye(n)&amp;&amp;n&lt;=t))(r))),</span>gte:<span class="fstat-no" title="function not covered" >r=&gt;be(q(e,(t=&gt;A(n=&gt;ye(n)&amp;&amp;n&gt;=t))(r))),</span>int:<span class="fstat-no" title="function not covered" >()=&gt;be(q(e,A(r=&gt;ye(r)&amp;&amp;Number.isInteger(r)))),</span>finite:<span class="fstat-no" title="function not covered" >()=&gt;be(q(e,A(r=&gt;ye(r)&amp;&amp;Number.isFinite(r)))),</span>positive:<span class="fstat-no" title="function not covered" >()=&gt;be(q(e,A(r=&gt;ye(r)&amp;&amp;r&gt;0))),</span>negative:<span class="fstat-no" title="function not covered" >()=&gt;be(q(e,A(r=&gt;ye(r)&amp;&amp;r&lt;0)))}</span>),tg=be(A(ye)),Ue=e=&gt;Object.assign(pe(e),{between:<span class="fstat-no" title="function not covered" >(r,t)=&gt;Ue(q(e,((n,i)=&gt;A(o=&gt;je(o)&amp;&amp;n&lt;=o&amp;&amp;i&gt;=o))(r,t))),</span>lt:<span class="fstat-no" title="function not covered" >r=&gt;Ue(q(e,(t=&gt;A(n=&gt;je(n)&amp;&amp;n&lt;t))(r))),</span>gt:<span class="fstat-no" title="function not covered" >r=&gt;Ue(q(e,(t=&gt;A(n=&gt;je(n)&amp;&amp;n&gt;t))(r))),</span>lte:<span class="fstat-no" title="function not covered" >r=&gt;Ue(q(e,(t=&gt;A(n=&gt;je(n)&amp;&amp;n&lt;=t))(r))),</span>gte:<span class="fstat-no" title="function not covered" >r=&gt;Ue(q(e,(t=&gt;A(n=&gt;je(n)&amp;&amp;n&gt;=t))(r))),</span>positive:<span class="fstat-no" title="function not covered" >()=&gt;Ue(q(e,A(r=&gt;je(r)&amp;&amp;r&gt;0))),</span>negative:<span class="fstat-no" title="function not covered" >()=&gt;Ue(q(e,A(r=&gt;je(r)&amp;&amp;r&lt;0)))}</span>),ng=Ue(A(je)),ig=pe(A(function(e){return typeof e=="boolean"})),og=pe(A(function(e){return typeof e=="symbol"})),sg=pe(A(function(e){return e==null})),ag=pe(A(function(e){return e!=null}));var ci=class extends Error{<span class="fstat-no" title="function not covered" >constructor(r){let t;try{t=JSON.stringify(r)}catch{t=r}super(`Pattern matching error: no pattern matches value ${t}`),this.input=void 0,this.input=r}}</span>,pi={matched:!1,value:void 0};<span class="fstat-no" title="function not covered" >function hr(e){return new di(e,pi)}v</span>ar di=class e{<span class="fstat-no" title="function not covered" >constructor(r,t){this.input=void 0,this.state=void 0,this.input=r,this.state=t}<span class="fstat-no" title="function not covered" >w</span>ith(...r){if(this.state.matched)return this;let t=r[r.length-1],n=[r[0]],i;r.length===3&amp;&amp;typeof r[1]=="function"?i=r[1]:r.length&gt;2&amp;&amp;n.push(...r.slice(1,r.length-1));let o=!1,s={},a=(u,c)=&gt;{o=!0,s[u]=c},l=!n.some(u=&gt;Ee(u,this.input,a))||i&amp;&amp;!i(this.input)?pi:{matched:!0,value:t(o?Wt in s?s[Wt]:s:this.input,this.input)};return new e(this.input,l)}<span class="fstat-no" title="function not covered" >w</span>hen(r,t){if(this.state.matched)return this;let n=!!r(this.input);return new e(this.input,n?{matched:!0,value:t(this.input,this.input)}:pi)}<span class="fstat-no" title="function not covered" >o</span>therwise(r){return this.state.matched?this.state.value:r(this.input)}<span class="fstat-no" title="function not covered" >e</span>xhaustive(){if(this.state.matched)return this.state.value;throw new ci(this.input)}<span class="fstat-no" title="function not covered" >r</span>un(){return this.exhaustive()}<span class="fstat-no" title="function not covered" >r</span>eturnType(){return this}}</span>;var Ho=require("node:util");var Ju={warn:Ie("prisma:warn")},Ku={warn:<span class="fstat-no" title="function not covered" >()=&gt;!process.env.PRISMA_DISABLE_WARNINGS}</span>;<span class="fstat-no" title="function not covered" >function Jt(e,...r){Ku.warn()&amp;&amp;console.warn(`${Ju.warn} ${e}`,...r)}v</span>ar Hu=(0,Ho.promisify)(Ko.default.exec),ee=gr("prisma:get-platform"),Yu=["1.0.x","1.1.x","3.0.x"];async function Yo(){let e=Ht.default.platform(),r=process.arch;if(e==="freebsd")<span class="branch-0 cbranch-no" title="branch not covered" >{let s=await Yt("freebsd-version");if(s&amp;&amp;s.trim().length&gt;0){let l=/^(\d+)\.?/.exec(s);if(l)return{platform:"freebsd",targetDistro:`freebsd${l[1]}`,arch:r}}}i</span>f(e!=="linux")return{platform:e,arch:r}<span class="branch-0 cbranch-no" title="branch not covered" >;let t=await Zu(),n=await sc(),i=ec({arch:r,archFromUname:n,familyDistro:t.familyDistro}),{libssl:o}=await rc(i);return{platform:"linux",libssl:o,arch:r,archFromUname:n,...t}}<span class="fstat-no" title="function not covered" >f</span>unction zu(e){let r=/^ID="?([^"\n]*)"?$/im,t=/^ID_LIKE="?([^"\n]*)"?$/im,n=r.exec(e),i=n&amp;&amp;n[1]&amp;&amp;n[1].toLowerCase()||"",o=t.exec(e),s=o&amp;&amp;o[1]&amp;&amp;o[1].toLowerCase()||"",a=hr({id:i,idLike:s}).with({id:"alpine"},({id:l})=&gt;({targetDistro:"musl",familyDistro:l,originalDistro:l})).with({id:"raspbian"},({id:l})=&gt;({targetDistro:"arm",familyDistro:"debian",originalDistro:l})).with({id:"nixos"},({id:l})=&gt;({targetDistro:"nixos",originalDistro:l,familyDistro:"nixos"})).with({id:"debian"},{id:"ubuntu"},({id:l})=&gt;({targetDistro:"debian",familyDistro:"debian",originalDistro:l})).with({id:"rhel"},{id:"centos"},{id:"fedora"},({id:l})=&gt;({targetDistro:"rhel",familyDistro:"rhel",originalDistro:l})).when(({idLike:l})=&gt;l.includes("debian")||l.includes("ubuntu"),({id:l})=&gt;({targetDistro:"debian",familyDistro:"debian",originalDistro:l})).when(({idLike:l})=&gt;i==="arch"||l.includes("arch"),({id:l})=&gt;({targetDistro:"debian",familyDistro:"arch",originalDistro:l})).when(({idLike:l})=&gt;l.includes("centos")||l.includes("fedora")||l.includes("rhel")||l.includes("suse"),({id:l})=&gt;({targetDistro:"rhel",familyDistro:"rhel",originalDistro:l})).otherwise(({id:l})=&gt;({targetDistro:void 0,familyDistro:void 0,originalDistro:l}));return ee(`Found distro info:</span>
${JSON.stringify(a,null,2)}`),a}<span class="fstat-no" title="function not covered" >async function Zu(){let e="/etc/os-release";try{let r=await mi.default.readFile(e,{encoding:"utf-8"});return zu(r)}catch{return{targetDistro:void 0,familyDistro:void 0,originalDistro:void 0}}}<span class="fstat-no" title="function not covered" >f</span>unction Xu(e){let r=/^OpenSSL\s(\d+\.\d+)\.\d+/.exec(e);if(r){let t=`${r[1]}.x`;return zo(t)}}<span class="fstat-no" title="function not covered" >f</span>unction Wo(e){let r=/libssl\.so\.(\d)(\.\d)?/.exec(e);if(r){let t=`${r[1]}${r[2]??".0"}.x`;return zo(t)}}<span class="fstat-no" title="function not covered" >f</span>unction zo(e){let r=(()=&gt;{if(Xo(e))return e;let t=e.split(".");return t[1]="0",t.join(".")})();if(Yu.includes(r))return r}<span class="fstat-no" title="function not covered" >f</span>unction ec(e){return hr(e).with({familyDistro:"musl"},()=&gt;(ee('Trying platform-specific paths for "alpine"'),["/lib","/usr/lib"])).with({familyDistro:"debian"},({archFromUname:r})=&gt;(ee('Trying platform-specific paths for "debian" (and "ubuntu")'),[`/usr/lib/${r}-linux-gnu`,`/lib/${r}-linux-gnu`])).with({familyDistro:"rhel"},()=&gt;(ee('Trying platform-specific paths for "rhel"'),["/lib64","/usr/lib64"])).otherwise(({familyDistro:r,arch:t,archFromUname:n})=&gt;(ee(`Don't know any platform-specific paths for "${r}" on ${t} (${n})`),[]))}<span class="fstat-no" title="function not covered" >a</span>sync function rc(e){let r='grep -v "libssl.so.0"',t=await Jo(e);if(t){ee(`Found libssl.so file using platform-specific paths: ${t}`);let o=Wo(t);if(ee(`The parsed libssl version is: ${o}`),o)return{libssl:o,strategy:"libssl-specific-path"}}ee('Falling back to "ldconfig" and other generic paths');let n=await Yt(`ldconfig -p | sed "s/.*=&gt;s*//" | sed "s|.*/||" | grep libssl | sort | ${r}`);if(n||(n=await Jo(["/lib64","/usr/lib64","/lib","/usr/lib"])),n){ee(`Found libssl.so file using "ldconfig" or other generic paths: ${n}`);let o=Wo(n);if(ee(`The parsed libssl version is: ${o}`),o)return{libssl:o,strategy:"ldconfig"}}let i=await Yt("openssl version -v");if(i){ee(`Found openssl binary with version: ${i}`);let o=Xu(i);if(ee(`The parsed openssl version is: ${o}`),o)return{libssl:o,strategy:"openssl-binary"}}return ee("Couldn't find any version of libssl or OpenSSL in the system"),{}}<span class="fstat-no" title="function not covered" >a</span>sync function Jo(e){for(let r of e){let t=await tc(r);if(t)return t}}<span class="fstat-no" title="function not covered" >a</span>sync function tc(e){try{return(await mi.default.readdir(e)).find(t=&gt;t.startsWith("libssl.so.")&amp;&amp;!t.startsWith("libssl.so.0"))}catch(r){if(r.code==="ENOENT")return;throw r}}a</span>sync function ir(){let{binaryTarget:e}=await Zo();return e}function nc(e){return e.binaryTarget!==void 0}async function fi(){let{memoized:e,...r}=await Zo();return r}var Kt={};async function Zo(){if(nc(Kt))return Promise.resolve({...Kt,memoized:!0});let e=await Yo(),r=ic(e);return Kt={...e,binaryTarget:r},{...Kt,memoized:!1}}function ic(e){let{platform:r,arch:t,archFromUname:n,libssl:i,targetDistro:o,familyDistro:s,originalDistro:a}=e;r==="linux"<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;!["x64","arm64"].includes(t)<span class="branch-0 cbranch-no" title="branch not covered" >&amp;</span>&amp;Jt(`Prisma only officially supports Linux on amd64 (x86_64) and arm64 (aarch64) system architectures (detected "${t}" instead). If you are using your own custom Prisma engines, you can ignore this warning, as long as you've compiled the engines for your system architecture "${n}".`);</span>let l="1.1.x";if(r==="linux"<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;i===void 0)<span class="branch-0 cbranch-no" title="branch not covered" ></span>{let c=hr({familyDistro:s}).with({familyDistro:"debian"},()=&gt;"Please manually install OpenSSL via `apt-get update -y &amp;&amp; apt-get install -y openssl` and try installing Prisma again. If you're running Prisma on Docker, add this command to your Dockerfile, or switch to an image that already has OpenSSL installed.").otherwise(()=&gt;"Please manually install OpenSSL and try installing Prisma again.");Jt(`Prisma failed to detect the libssl/openssl version to use, and may not work as expected. Defaulting to "openssl-${l}".</span>
${c}`)}let u="debian";if(r==="linux"<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;o===void 0<span class="branch-0 cbranch-no" title="branch not covered" >&amp;</span>&amp;ee(`Distro is "${a}". Falling back to Prisma engines built for "${u}".`),</span>r==="darwin"<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;t==="arm64")<span class="branch-0 cbranch-no" title="branch not covered" ></span>return"darwin-arm64";i</span>f(r==="darwin")<span class="branch-0 cbranch-no" title="branch not covered" >return"darwin";i</span>f(r==="win32")return"windows"<span class="branch-0 cbranch-no" title="branch not covered" >;if(r==="freebsd")return o;if(r==="openbsd")return"openbsd";if(r==="netbsd")return"netbsd";if(r==="linux"&amp;&amp;o==="nixos")<span class="branch-0 cbranch-no" title="branch not covered" ></span>return"linux-nixos";if(r==="linux"&amp;&amp;t==="arm64")<span class="branch-0 cbranch-no" title="branch not covered" ></span>return`${o==="musl"?"linux-musl-arm64":"linux-arm64"}-openssl-${i||l}`;if(r==="linux"&amp;&amp;t==="arm")<span class="branch-0 cbranch-no" title="branch not covered" ></span>return`linux-arm-openssl-${i||l}`;if(r==="linux"&amp;&amp;o==="musl")<span class="branch-0 cbranch-no" title="branch not covered" ></span>{let c="linux-musl";return!i||Xo(i)?c:`${c}-openssl-${i}`}return r==="linux"&amp;&amp;o<span class="branch-0 cbranch-no" title="branch not covered" >&amp;</span>&amp;i<span class="branch-0 cbranch-no" title="branch not covered" >?</span>`${o}-openssl-${i}`<span class="branch-0 cbranch-no" title="branch not covered" >:</span>(r!=="linux"&amp;&amp;Jt(`Prisma detected unknown OS "${r}" and may not work as expected. Defaulting to "linux".`),i?`${u}-openssl-${i}`:o?`${o}-openssl-${l}`:`${u}-openssl-${l}`)}<span class="fstat-no" title="function not covered" ></span>async function oc(e){try{return await e()}catch{return}}<span class="fstat-no" title="function not covered" >f</span>unction Yt(e){return oc(async()=&gt;{let r=await Hu(e);return ee(`Command "${e}" successfully returned "${r.stdout}"`),r.stdout})}<span class="fstat-no" title="function not covered" >a</span>sync function sc(){return typeof Ht.default.machine=="function"?Ht.default.machine():(await Yt("uname -m"))?.trim()}<span class="fstat-no" title="function not covered" >f</span>unction Xo(e){return e.startsWith("1.")}v</span>ar Xt={};tr(Xt,{beep:<span class="fstat-no" title="function not covered" >()=&gt;kc,</span>clearScreen:<span class="fstat-no" title="function not covered" >()=&gt;Cc,</span>clearTerminal:<span class="fstat-no" title="function not covered" >()=&gt;Ic,</span>cursorBackward:<span class="fstat-no" title="function not covered" >()=&gt;mc,</span>cursorDown:<span class="fstat-no" title="function not covered" >()=&gt;pc,</span>cursorForward:<span class="fstat-no" title="function not covered" >()=&gt;dc,</span>cursorGetPosition:<span class="fstat-no" title="function not covered" >()=&gt;hc,</span>cursorHide:<span class="fstat-no" title="function not covered" >()=&gt;Ec,</span>cursorLeft:<span class="fstat-no" title="function not covered" >()=&gt;ts,</span>cursorMove:<span class="fstat-no" title="function not covered" >()=&gt;cc,</span>cursorNextLine:<span class="fstat-no" title="function not covered" >()=&gt;yc,</span>cursorPrevLine:<span class="fstat-no" title="function not covered" >()=&gt;bc,</span>cursorRestorePosition:<span class="fstat-no" title="function not covered" >()=&gt;gc,</span>cursorSavePosition:<span class="fstat-no" title="function not covered" >()=&gt;fc,</span>cursorShow:<span class="fstat-no" title="function not covered" >()=&gt;wc,</span>cursorTo:<span class="fstat-no" title="function not covered" >()=&gt;uc,</span>cursorUp:<span class="fstat-no" title="function not covered" >()=&gt;rs,</span>enterAlternativeScreen:<span class="fstat-no" title="function not covered" >()=&gt;Dc,</span>eraseDown:<span class="fstat-no" title="function not covered" >()=&gt;Tc,</span>eraseEndLine:<span class="fstat-no" title="function not covered" >()=&gt;vc,</span>eraseLine:<span class="fstat-no" title="function not covered" >()=&gt;ns,</span>eraseLines:<span class="fstat-no" title="function not covered" >()=&gt;xc,</span>eraseScreen:<span class="fstat-no" title="function not covered" >()=&gt;gi,</span>eraseStartLine:<span class="fstat-no" title="function not covered" >()=&gt;Pc,</span>eraseUp:<span class="fstat-no" title="function not covered" >()=&gt;Sc,</span>exitAlternativeScreen:<span class="fstat-no" title="function not covered" >()=&gt;Oc,</span>iTerm:<span class="fstat-no" title="function not covered" >()=&gt;Lc,</span>image:<span class="fstat-no" title="function not covered" >()=&gt;Nc,</span>link:<span class="fstat-no" title="function not covered" >()=&gt;_c,</span>scrollDown:<span class="fstat-no" title="function not covered" >()=&gt;Ac,</span>scrollUp:<span class="fstat-no" title="function not covered" >()=&gt;Rc}</span>);var Zt=O(require("node:process"),1);var zt=globalThis.window<span class="branch-0 cbranch-no" title="branch not covered" >?.document!</span>==void 0,gg=globalThis.process?.versions?.node!==void 0,hg=globalThis.process?.versions?.bun!==void 0,yg=globalThis.Deno<span class="branch-0 cbranch-no" title="branch not covered" >?.version?.deno!</span>==void 0,bg=globalThis.process?.versions?.electron!==void 0,Eg=globalThis.navigator?.userAgent?.includes("jsdom")===!0,wg=typeof WorkerGlobalScope&lt;"u"<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;globalThis instanceof WorkerGlobalScope,</span>xg=typeof DedicatedWorkerGlobalScope&lt;"u"<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;globalThis instanceof DedicatedWorkerGlobalScope,</span>vg=typeof SharedWorkerGlobalScope&lt;"u"<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;globalThis instanceof SharedWorkerGlobalScope,</span>Pg=typeof ServiceWorkerGlobalScope&lt;"u"<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;globalThis instanceof ServiceWorkerGlobalScope,</span>Xr=globalThis.navigator?.userAgentData<span class="branch-0 cbranch-no" title="branch not covered" >?.platform,</span>Tg=Xr==="macOS"||globalThis.navigator?.platform==="MacIntel"||globalThis.navigator?.userAgent?.includes(" Mac ")===!0||globalThis.process?.platform==="darwin",Sg=Xr==="Windows"||globalThis.navigator?.platform==="Win32"<span class="branch-0 cbranch-no" title="branch not covered" >||globalThis.process?.platform==="win32",</span>Rg=Xr==="Linux"||globalThis.navigator?.platform?.startsWith("Linux")===!0||globalThis.navigator?.userAgent?.includes(" Linux ")===!0||globalThis.process?.platform==="linux",Ag=Xr==="iOS"||globalThis.navigator?.platform==="MacIntel"<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;globalThis.navigator?.maxTouchPoints&gt;1|</span>|/iPad|iPhone|iPod/.test(globalThis.navigator?.platform),Cg=Xr==="Android"||globalThis.navigator?.platform==="Android"||globalThis.navigator?.userAgent?.includes(" Android ")===!0||globalThis.process?.platform==="android";var C="\x1B[",rt="\x1B]",yr="\x07",et=";",es=!zt&amp;&amp;Zt.default.env.TERM_PROGRAM==="Apple_Terminal",ac=!zt&amp;&amp;Zt.default.platform==="win32",lc=zt<span class="branch-0 cbranch-no" title="branch not covered" >?<span class="fstat-no" title="function not covered" >()=&gt;{throw new Error("`process.cwd()` only works in Node.js, not the browser.")}:</span></span>Zt.default.cwd,uc=<span class="fstat-no" title="function not covered" >(e,r)=&gt;{if(typeof e!="number")throw new TypeError("The `x` argument is required");return typeof r!="number"?C+(e+1)+"G":C+(r+1)+et+(e+1)+"H"},</span>cc=<span class="fstat-no" title="function not covered" >(e,r)=&gt;{if(typeof e!="number")throw new TypeError("The `x` argument is required");let t="";return e&lt;0?t+=C+-e+"D":e&gt;0&amp;&amp;(t+=C+e+"C"),r&lt;0?t+=C+-r+"A":r&gt;0&amp;&amp;(t+=C+r+"B"),t},</span>rs=<span class="fstat-no" title="function not covered" >(e=1)=&gt;C+e+"A",</span>pc=<span class="fstat-no" title="function not covered" >(e=1)=&gt;C+e+"B",</span>dc=<span class="fstat-no" title="function not covered" >(e=1)=&gt;C+e+"C",</span>mc=<span class="fstat-no" title="function not covered" >(e=1)=&gt;C+e+"D",</span>ts=C+"G",fc=es<span class="branch-0 cbranch-no" title="branch not covered" >?"\x1B7":</span>C+"s",gc=es<span class="branch-0 cbranch-no" title="branch not covered" >?"\x1B8":</span>C+"u",hc=C+"6n",yc=C+"E",bc=C+"F",Ec=C+"?25l",wc=C+"?25h",xc=<span class="fstat-no" title="function not covered" >e=&gt;{let r="";for(let t=0;t&lt;e;t++)r+=ns+(t&lt;e-1?rs():"");return e&amp;&amp;(r+=ts),r},</span>vc=C+"K",Pc=C+"1K",ns=C+"2K",Tc=C+"J",Sc=C+"1J",gi=C+"2J",Rc=C+"S",Ac=C+"T",Cc="\x1Bc",Ic=ac?`${gi}${C}0f`<span class="branch-0 cbranch-no" title="branch not covered" >:`${gi}${C}3J${C}H`,</span>Dc=C+"?1049h",Oc=C+"?1049l",kc=yr,_c=<span class="fstat-no" title="function not covered" >(e,r)=&gt;[rt,"8",et,et,r,yr,e,rt,"8",et,et,yr].join(""),</span>Nc=<span class="fstat-no" title="function not covered" >(e,r={})=&gt;{let t=`${rt}1337;File=inline=1`;return r.width&amp;&amp;(t+=`;width=${r.width}`),r.height&amp;&amp;(t+=`;height=${r.height}`),r.preserveAspectRatio===!1&amp;&amp;(t+=";preserveAspectRatio=0"),t+":"+Buffer.from(e).toString("base64")+yr},</span>Lc={setCwd:<span class="fstat-no" title="function not covered" >(e=lc())=&gt;`${rt}50;CurrentDir=${e}${yr}`,<span class="fstat-no" title="function not covered" ></span>annotation(e,r={}){let t=`${rt}1337;`,n=r.x!==void 0,i=r.y!==void 0;if((n||i)&amp;&amp;!(n&amp;&amp;i&amp;&amp;r.length!==void 0))throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");return e=e.replaceAll("|",""),t+=r.isHidden?"AddHiddenAnnotation=":"AddAnnotation=",r.length&gt;0?t+=(n?[e,r.length,r.x,r.y]:[r.length,e]).join("|"):t+=e,t+yr}}</span>;var en=O(cs(),1);<span class="fstat-no" title="function not covered" >function or(e,r,{target:t="stdout",...n}={}){return en.default[t]?Xt.link(e,r):n.fallback===!1?e:typeof n.fallback=="function"?n.fallback(e,r):`${e} (\u200B${r}\u200B)`}o</span>r.isSupported=en.default.stdout;or.stderr=<span class="fstat-no" title="function not covered" >(e,r,t={})=&gt;or(e,r,{target:"stderr",...t});</span>or.stderr.isSupported=en.default.stderr;<span class="fstat-no" title="function not covered" >function wi(e){return or(e,e,{fallback:Y})}v</span>ar Vc=ps(),xi=Vc.version;function Er(e){let r=jc();return r||(e?.config.engineType==="library"?"library"<span class="branch-0 cbranch-no" title="branch not covered" >:e?.config.engineType==="binary"?"binary":e?.config.engineType==="client"?"client":Bc())</span>}function jc(){let e=process.env.PRISMA_CLIENT_ENGINE_TYPE;return e==="library"<span class="branch-0 cbranch-no" title="branch not covered" >?"library":</span>e==="binary"<span class="branch-0 cbranch-no" title="branch not covered" >?"binary":</span>e==="client"<span class="branch-0 cbranch-no" title="branch not covered" >?"client":</span>void 0}<span class="fstat-no" title="function not covered" >function Bc(){return"library"}<span class="fstat-no" title="function not covered" >f</span>unction vi(e){return e.name==="DriverAdapterError"&amp;&amp;typeof e.cause=="object"}<span class="fstat-no" title="function not covered" >f</span>unction rn(e){return{ok:!0,value:e,map(r){return rn(r(e))},flatMap(r){return r(e)}}}<span class="fstat-no" title="function not covered" >f</span>unction sr(e){return{ok:!1,error:e,map(){return sr(e)},flatMap(){return sr(e)}}}v</span>ar ds=N("driver-adapter-utils"),Pi=class<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{registeredErrors=[];consumeError(r){return this.registeredErrors[r]}registerNewError(r){let t=0;for(;this.registeredErrors[t]!==void 0;)t++;return this.registeredErrors[t]={error:r},t}};</span></span>var tn=<span class="fstat-no" title="function not covered" >(e,r=new Pi)=&gt;{let t={adapterName:e.adapterName,errorRegistry:r,queryRaw:ke(r,e.queryRaw.bind(e)),executeRaw:ke(r,e.executeRaw.bind(e)),executeScript:ke(r,e.executeScript.bind(e)),dispose:ke(r,e.dispose.bind(e)),provider:e.provider,startTransaction:async(...n)=&gt;(await ke(r,e.startTransaction.bind(e))(...n)).map(o=&gt;Uc(r,o))};return e.getConnectionInfo&amp;&amp;(t.getConnectionInfo=Gc(r,e.getConnectionInfo.bind(e))),t},</span>Uc=<span class="fstat-no" title="function not covered" >(e,r)=&gt;({adapterName:r.adapterName,provider:r.provider,options:r.options,queryRaw:ke(e,r.queryRaw.bind(r)),executeRaw:ke(e,r.executeRaw.bind(r)),commit:ke(e,r.commit.bind(r)),rollback:ke(e,r.rollback.bind(r))});<span class="fstat-no" title="function not covered" ></span>function ke(e,r){return async(...t)=&gt;{try{return rn(await r(...t))}catch(n){if(ds("[error@wrapAsync]",n),vi(n))return sr(n.cause);let i=e.registerNewError(n);return sr({kind:"GenericJs",id:i})}}}<span class="fstat-no" title="function not covered" >f</span>unction Gc(e,r){return(...t)=&gt;{try{return rn(r(...t))}catch(n){if(ds("[error@wrapSync]",n),vi(n))return sr(n.cause);let i=e.registerNewError(n);return sr({kind:"GenericJs",id:i})}}}v</span>ar Wc=O(on());var M=O(require("node:path")),Jc=O(on()),wh=N("prisma:engines");<span class="fstat-no" title="function not covered" >function ms(){return M.default.join(__dirname,"../")}v</span>ar xh="libquery-engine";M.default.join(__dirname,"../query-engine-darwin");M.default.join(__dirname,"../query-engine-darwin-arm64");M.default.join(__dirname,"../query-engine-debian-openssl-1.0.x");M.default.join(__dirname,"../query-engine-debian-openssl-1.1.x");M.default.join(__dirname,"../query-engine-debian-openssl-3.0.x");M.default.join(__dirname,"../query-engine-linux-static-x64");M.default.join(__dirname,"../query-engine-linux-static-arm64");M.default.join(__dirname,"../query-engine-rhel-openssl-1.0.x");M.default.join(__dirname,"../query-engine-rhel-openssl-1.1.x");M.default.join(__dirname,"../query-engine-rhel-openssl-3.0.x");M.default.join(__dirname,"../libquery_engine-darwin.dylib.node");M.default.join(__dirname,"../libquery_engine-darwin-arm64.dylib.node");M.default.join(__dirname,"../libquery_engine-debian-openssl-1.0.x.so.node");M.default.join(__dirname,"../libquery_engine-debian-openssl-1.1.x.so.node");M.default.join(__dirname,"../libquery_engine-debian-openssl-3.0.x.so.node");M.default.join(__dirname,"../libquery_engine-linux-arm64-openssl-1.0.x.so.node");M.default.join(__dirname,"../libquery_engine-linux-arm64-openssl-1.1.x.so.node");M.default.join(__dirname,"../libquery_engine-linux-arm64-openssl-3.0.x.so.node");M.default.join(__dirname,"../libquery_engine-linux-musl.so.node");M.default.join(__dirname,"../libquery_engine-linux-musl-openssl-3.0.x.so.node");M.default.join(__dirname,"../libquery_engine-rhel-openssl-1.0.x.so.node");M.default.join(__dirname,"../libquery_engine-rhel-openssl-1.1.x.so.node");M.default.join(__dirname,"../libquery_engine-rhel-openssl-3.0.x.so.node");M.default.join(__dirname,"../query_engine-windows.dll.node");var Si=O(require("node:fs")),fs=gr("chmodPlusX");<span class="fstat-no" title="function not covered" >function Ri(e){if(process.platform==="win32")return;let r=Si.default.statSync(e),t=r.mode|64|8|1;if(r.mode===t){fs(`Execution permissions of ${e} are fine`);return}let n=t.toString(8).slice(-3);fs(`Have to call chmodPlusX on ${e}`),Si.default.chmodSync(e,n)}<span class="fstat-no" title="function not covered" >f</span>unction Ai(e){let r=e.e,t=a=&gt;`Prisma cannot find the required \`${a}\` system library in your system`,n=r.message.includes("cannot open shared object file"),i=`Please refer to the documentation about Prisma's system requirements: ${wi("https://pris.ly/d/system-requirements")}`,o=`Unable to require(\`${Ce(e.id)}\`).`,s=hr({message:r.message,code:r.code}).with({code:"ENOENT"},()=&gt;"File does not exist.").when(({message:a})=&gt;n&amp;&amp;a.includes("libz"),()=&gt;`${t("libz")}. Please install it and try again.`).when(({message:a})=&gt;n&amp;&amp;a.includes("libgcc_s"),()=&gt;`${t("libgcc_s")}. Please install it and try again.`).when(({message:a})=&gt;n&amp;&amp;a.includes("libssl"),()=&gt;{let a=e.platformInfo.libssl?`openssl-${e.platformInfo.libssl}`:"openssl";return`${t("libssl")}. Please install ${a} and try again.`}).when(({message:a})=&gt;a.includes("GLIBC"),()=&gt;`Prisma has detected an incompatible version of the \`glibc\` C standard library installed in your system. This probably means your system may be too old to run Prisma. ${i}`).when(({message:a})=&gt;e.platformInfo.platform==="linux"&amp;&amp;a.includes("symbol not found"),()=&gt;`The Prisma engines are not compatible with your system ${e.platformInfo.originalDistro} on (${e.platformInfo.archFromUname}) which uses the \`${e.platformInfo.binaryTarget}\` binaryTarget by default. ${i}`).otherwise(()=&gt;`The Prisma engines do not seem to be compatible with your system. ${i}`);return`${o}</span>
<span class="cstat-no" title="statement not covered" >${s}</span>
<span class="cstat-no" title="statement not covered" ></span>
Details: ${r.message}`}var ys=O(hs(),1);<span class="fstat-no" title="function not covered" >function Ci(e){let r=(0,ys.default)(e);if(r===0)return e;let t=new RegExp(`^[ \\t]{${r}}`,"gm");return e.replace(t,"")}v</span>ar bs="prisma+postgres",sn=`${bs}:`;function an(e){return e?.toString().startsWith(`${sn}//`)<span class="branch-0 cbranch-no" title="branch not covered" >??!1}<span class="fstat-no" title="function not covered" ></span>function Ii(e){if(!an(e))return!1;let{host:r}=new URL(e);return r.includes("localhost")||r.includes("127.0.0.1")||r.includes("[::1]")}v</span>ar ws=O(Di());<span class="fstat-no" title="function not covered" >function ki(e){return String(new Oi(e))}v</span>ar Oi=class{<span class="fstat-no" title="function not covered" >constructor(r){this.config=r}<span class="fstat-no" title="function not covered" >t</span>oString(){let{config:r}=this,t=r.provider.fromEnvVar?`env("${r.provider.fromEnvVar}")`:r.provider.value,n=JSON.parse(JSON.stringify({provider:t,binaryTargets:Kc(r.binaryTargets)}));return`generator ${r.name} {</span>
<span class="cstat-no" title="statement not covered" >${(0,ws.default)(Hc(n),2)}</span>
}`}};<span class="fstat-no" title="function not covered" >function Kc(e){let r;if(e.length&gt;0){let t=e.find(n=&gt;n.fromEnvVar!==null);t?r=`env("${t.fromEnvVar}")`:r=e.map(n=&gt;n.native?"native":n.value)}else r=void 0;return r}<span class="fstat-no" title="function not covered" >f</span>unction Hc(e){let r=Object.keys(e).reduce((t,n)=&gt;Math.max(t,n.length),0);return Object.entries(e).map(([t,n])=&gt;`${t.padEnd(r)} = ${Yc(n)}`).join(`</span>
`)}<span class="fstat-no" title="function not covered" >function Yc(e){return JSON.parse(JSON.stringify(e,(r,t)=&gt;Array.isArray(t)?`[${t.map(n=&gt;JSON.stringify(n)).join(", ")}]`:JSON.stringify(t)))}v</span>ar nt={};tr(nt,{error:<span class="fstat-no" title="function not covered" >()=&gt;Xc,</span>info:<span class="fstat-no" title="function not covered" >()=&gt;Zc,</span>log:<span class="fstat-no" title="function not covered" >()=&gt;zc,</span>query:<span class="fstat-no" title="function not covered" >()=&gt;ep,</span>should:<span class="fstat-no" title="function not covered" >()=&gt;xs,</span>tags:<span class="fstat-no" title="function not covered" >()=&gt;tt,</span>warn:<span class="fstat-no" title="function not covered" >()=&gt;_i}</span>);var tt={error:ce("prisma:error"),warn:Ie("prisma:warn"),info:De("prisma:info"),query:nr("prisma:query")},xs={warn:<span class="fstat-no" title="function not covered" >()=&gt;!process.env.PRISMA_DISABLE_WARNINGS}</span>;<span class="fstat-no" title="function not covered" >function zc(...e){console.log(...e)}<span class="fstat-no" title="function not covered" >f</span>unction _i(e,...r){xs.warn()&amp;&amp;console.warn(`${tt.warn} ${e}`,...r)}<span class="fstat-no" title="function not covered" >f</span>unction Zc(e,...r){console.info(`${tt.info} ${e}`,...r)}<span class="fstat-no" title="function not covered" >f</span>unction Xc(e,...r){console.error(`${tt.error} ${e}`,...r)}<span class="fstat-no" title="function not covered" >f</span>unction ep(e,...r){console.log(`${tt.query} ${e}`,...r)}<span class="fstat-no" title="function not covered" >f</span>unction ln(e,r){if(!e)throw new Error(`${r}. This should never happen. If you see this error, please, open an issue at https://pris.ly/prisma-prisma-bug-report`)}<span class="fstat-no" title="function not covered" >f</span>unction ar(e,r){throw new Error(r)}f</span>unction Ni({onlyFirst:e=!1}={}){let t=["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&amp;.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&amp;.:=?%@~_]*)*)?(?:\\u0007|\\u001B\\u005C|\\u009C))","(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=&gt;&lt;~]))"].join("|");return new RegExp(t,e<span class="branch-0 cbranch-no" title="branch not covered" >?void 0:</span>"g")}var rp=Ni();<span class="fstat-no" title="function not covered" >function wr(e){if(typeof e!="string")throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``);return e.replace(rp,"")}v</span>ar it=O(require("node:path"));<span class="fstat-no" title="function not covered" >function Li(e){return it.default.sep===it.default.posix.sep?e:e.split(it.default.sep).join(it.default.posix.sep)}v</span>ar qi=O(As()),un=O(require("node:fs"));var xr=O(require("node:path"));function Cs(e){let r=e.ignoreProcessEnv<span class="branch-0 cbranch-no" title="branch not covered" >?{}:</span>process.env,t=n=&gt;n.match(/(.?\${(?:[a-zA-Z0-9_]+)?})/g)<span class="branch-0 cbranch-no" title="branch not covered" >?.reduce(</span>function(o,s){let a=/(.?)\${([a-zA-Z0-9_]+)?}/g.exec(s);if(!a)return o;let l=a[1],u,c;if(l==="\\")c=a[0],u=c.replace("\\$","$");else{let p=a[2];c=a[0].substring(l.length),u=Object.hasOwnProperty.call(r,p)?r[p]:e.parsed[p]||"",u=t(u)}return o.replace(c,u)},n)??n;for(let n in e.parsed){let i=Object.hasOwnProperty.call(r,n)?r[n]<span class="branch-0 cbranch-no" title="branch not covered" >:e.parsed[n];</span>e.parsed[n]=t(i)}for(let n in e.parsed)r[n]=e.parsed[n];return e}var $i=gr("prisma:tryLoadEnv");function st({rootEnvPath:e,schemaEnvPath:r},t={conflictCheck:"none"}){let n=Is(e);t.conflictCheck!=="none"&amp;&amp;hp(n,r,t.conflictCheck);let i=null;return Ds(n<span class="branch-0 cbranch-no" title="branch not covered" >?.path,</span>r)||(i=Is(r)),!n&amp;&amp;!i<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;$i("No Environment variables loaded"),</span>i?.dotenvResult.error<span class="branch-0 cbranch-no" title="branch not covered" >?console.error(ce(W("Schema Env Error: "))+i.dotenvResult.error):</span>{message:[n<span class="branch-0 cbranch-no" title="branch not covered" >?.message,</span>i?.message].filter(Boolean).join(`
`),parsed:{...n<span class="branch-0 cbranch-no" title="branch not covered" >?.dotenvResult?.parsed,</span>...i?.dotenvResult?.parsed}}}function hp(e,r,t){let n=e<span class="branch-0 cbranch-no" title="branch not covered" >?.dotenvResult.</span>parsed,i=!Ds(e<span class="branch-0 cbranch-no" title="branch not covered" >?.path,</span>r);if(n<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;r<span class="branch-0 cbranch-no" title="branch not covered" >&amp;</span>&amp;i<span class="branch-0 cbranch-no" title="branch not covered" >&amp;</span>&amp;un.default.existsSync(r))<span class="branch-0 cbranch-no" title="branch not covered" ></span>{let o=qi.default.parse(un.default.readFileSync(r)),s=[];for(let a in o)n[a]===o[a]&amp;&amp;s.push(a);if(s.length&gt;0){let a=xr.default.relative(process.cwd(),e.path),l=xr.default.relative(process.cwd(),r);if(t==="error"){let u=`There is a conflict between env var${s.length&gt;1?"s":""} in ${Y(a)} and ${Y(l)}</span>
<span class="cstat-no" title="statement not covered" >Conflicting env vars:</span>
<span class="cstat-no" title="statement not covered" >${s.map(c=&gt;`  ${W(c)}`).join(`</span>
<span class="cstat-no" title="statement not covered" >`)}</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >We suggest to move the contents of ${Y(l)} to ${Y(a)} to consolidate your env vars.</span>
<span class="cstat-no" title="statement not covered" >`;throw new Error(u)}else if(t==="warn"){let u=`Conflict for env var${s.length&gt;1?"s":""} ${s.map(c=&gt;W(c)).join(", ")} in ${Y(a)} and ${Y(l)}</span>
<span class="cstat-no" title="statement not covered" >Env vars from ${Y(l)} overwrite the ones from ${Y(a)}</span>
      `;console.warn(`${Ie("warn(prisma)")} ${u}`)}}}}function Is(e){if(yp(e)){$i(`Environment variables loaded from ${e}`);let r=qi.default.config({path:e,debug:process.env.DOTENV_CONFIG_DEBUG<span class="branch-0 cbranch-no" title="branch not covered" >?!0:</span>void 0});return{dotenvResult:Cs(r),message:Ce(`Environment variables loaded from ${xr.default.relative(process.cwd(),e)}`),path:e}}else $i(`Environment variables not found at ${e}`);return null}function Ds(e,r){return e<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;r<span class="branch-0 cbranch-no" title="branch not covered" >&amp;</span>&amp;xr.default.resolve(e)===xr.default.resolve(r)}</span>function yp(e){return!!(e&amp;&amp;un.default.existsSync(e))}<span class="fstat-no" title="function not covered" >function Vi(e,r){return Object.prototype.hasOwnProperty.call(e,r)}<span class="fstat-no" title="function not covered" >f</span>unction pn(e,r){let t={};for(let n of Object.keys(e))t[n]=r(e[n],n);return t}<span class="fstat-no" title="function not covered" >f</span>unction ji(e,r){if(e.length===0)return;let t=e[0];for(let n=1;n&lt;e.length;n++)r(t,e[n])&lt;0&amp;&amp;(t=e[n]);return t}f</span>unction x(e,r){Object.defineProperty(e,"name",{value:r,configurable:!0})}var ks=new Set,at=<span class="fstat-no" title="function not covered" >(e,r,...t)=&gt;{ks.has(e)||(ks.add(e),_i(r,...t))};</span>var P=class e extends Error<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{clientVersion;errorCode;retryable;constructor(r,t,n){super(r),this.name="PrismaClientInitializationError",this.clientVersion=t,this.errorCode=n,Error.captureStackTrace(e)}get[Symbol.toStringTag](){return"PrismaClientInitializationError"}};x</span></span>(P,"PrismaClientInitializationError");var z=class extends Error<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{code;meta;clientVersion;batchRequestIdx;constructor(r,{code:t,clientVersion:n,meta:i,batchRequestIdx:o}){super(r),this.name="PrismaClientKnownRequestError",this.code=t,this.clientVersion=n,this.meta=i,Object.defineProperty(this,"batchRequestIdx",{value:o,enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return"PrismaClientKnownRequestError"}};x</span></span>(z,"PrismaClientKnownRequestError");var ae=class extends Error<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{clientVersion;constructor(r,t){super(r),this.name="PrismaClientRustPanicError",this.clientVersion=t}get[Symbol.toStringTag](){return"PrismaClientRustPanicError"}};x</span></span>(ae,"PrismaClientRustPanicError");var V=class extends Error<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{clientVersion;batchRequestIdx;constructor(r,{clientVersion:t,batchRequestIdx:n}){super(r),this.name="PrismaClientUnknownRequestError",this.clientVersion=t,Object.defineProperty(this,"batchRequestIdx",{value:n,writable:!0,enumerable:!1})}get[Symbol.toStringTag](){return"PrismaClientUnknownRequestError"}};x</span></span>(V,"PrismaClientUnknownRequestError");var Z=class extends Error<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{name="PrismaClientValidationError";clientVersion;constructor(r,{clientVersion:t}){super(r),this.clientVersion=t}get[Symbol.toStringTag](){return"PrismaClientValidationError"}};x</span></span>(Z,"PrismaClientValidationError");var we=class{_map=new Map;<span class="fstat-no" title="function not covered" >get(r){return this._map.get(r)?.value}s</span>et(r,t){this._map.set(r,{value:t})}getOrCreate(r,t){let n=this._map.get(r);if(n)return n.value;let i=t();return this.set(r,i),i}};<span class="fstat-no" title="function not covered" >function We(e){return e.substring(0,1).toLowerCase()+e.substring(1)}<span class="fstat-no" title="function not covered" >f</span>unction _s(e,r){let t={};for(let n of e){let i=n[r];t[i]=n}return t}f</span>unction lt(e){let r;return{<span class="fstat-no" title="function not covered" >get(){return r||(r={value:e()}),r.value}}</span>}<span class="fstat-no" title="function not covered" >function Ns(e){return{models:Bi(e.models),enums:Bi(e.enums),types:Bi(e.types)}}<span class="fstat-no" title="function not covered" >f</span>unction Bi(e){let r={};for(let{name:t,...n}of e)r[t]=n;return r}f</span>unction vr(e){return e instanceof Date||Object.prototype.toString.call(e)==="[object Date]"}function mn(e){return e.toString()!=="Invalid Date"}var Pr=9e15,Ye=1e9,Ui="0123456789abcdef",hn="2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058",yn="3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789",Gi={precision:20,rounding:4,modulo:1,toExpNeg:-7,toExpPos:21,minE:-Pr,maxE:Pr,crypto:!1},$s,Ne,w=!0,En="[DecimalError] ",He=En+"Invalid argument: ",qs=En+"Precision limit exceeded",Vs=En+"crypto unavailable",js="[object Decimal]",X=Math.floor,U=Math.pow,bp=/^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,Ep=/^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,wp=/^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,Bs=/^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,fe=1e7,E=7,xp=9007199254740991,vp=hn.length-1,Qi=yn.length-1,m={toStringTag:js};m.absoluteValue=m.abs=<span class="fstat-no" title="function not covered" >function(){var e=new this.constructor(this);return e.s&lt;0&amp;&amp;(e.s=1),y(e)};m</span>.ceil=<span class="fstat-no" title="function not covered" >function(){return y(new this.constructor(this),this.e+1,2)};m</span>.clampedTo=m.clamp=<span class="fstat-no" title="function not covered" >function(e,r){var t,n=this,i=n.constructor;if(e=new i(e),r=new i(r),!e.s||!r.s)return new i(NaN);if(e.gt(r))throw Error(He+r);return t=n.cmp(e),t&lt;0?e:n.cmp(r)&gt;0?r:new i(n)};m</span>.comparedTo=m.cmp=<span class="fstat-no" title="function not covered" >function(e){var r,t,n,i,o=this,s=o.d,a=(e=new o.constructor(e)).d,l=o.s,u=e.s;if(!s||!a)return!l||!u?NaN:l!==u?l:s===a?0:!s^l&lt;0?1:-1;if(!s[0]||!a[0])return s[0]?l:a[0]?-u:0;if(l!==u)return l;if(o.e!==e.e)return o.e&gt;e.e^l&lt;0?1:-1;for(n=s.length,i=a.length,r=0,t=n&lt;i?n:i;r&lt;t;++r)if(s[r]!==a[r])return s[r]&gt;a[r]^l&lt;0?1:-1;return n===i?0:n&gt;i^l&lt;0?1:-1};m</span>.cosine=m.cos=<span class="fstat-no" title="function not covered" >function(){var e,r,t=this,n=t.constructor;return t.d?t.d[0]?(e=n.precision,r=n.rounding,n.precision=e+Math.max(t.e,t.sd())+E,n.rounding=1,t=Pp(n,Js(n,t)),n.precision=e,n.rounding=r,y(Ne==2||Ne==3?t.neg():t,e,r,!0)):new n(1):new n(NaN)};m</span>.cubeRoot=m.cbrt=<span class="fstat-no" title="function not covered" >function(){var e,r,t,n,i,o,s,a,l,u,c=this,p=c.constructor;if(!c.isFinite()||c.isZero())return new p(c);for(w=!1,o=c.s*U(c.s*c,1/3),!o||Math.abs(o)==1/0?(t=J(c.d),e=c.e,(o=(e-t.length+1)%3)&amp;&amp;(t+=o==1||o==-2?"0":"00"),o=U(t,1/3),e=X((e+1)/3)-(e%3==(e&lt;0?-1:2)),o==1/0?t="5e"+e:(t=o.toExponential(),t=t.slice(0,t.indexOf("e")+1)+e),n=new p(t),n.s=c.s):n=new p(o.toString()),s=(e=p.precision)+3;;)if(a=n,l=a.times(a).times(a),u=l.plus(c),n=L(u.plus(c).times(a),u.plus(l),s+2,1),J(a.d).slice(0,s)===(t=J(n.d)).slice(0,s))if(t=t.slice(s-3,s+1),t=="9999"||!i&amp;&amp;t=="4999"){if(!i&amp;&amp;(y(a,e+1,0),a.times(a).times(a).eq(c))){n=a;break}s+=4,i=1}else{(!+t||!+t.slice(1)&amp;&amp;t.charAt(0)=="5")&amp;&amp;(y(n,e+1,1),r=!n.times(n).times(n).eq(c));break}return w=!0,y(n,e,p.rounding,r)};m</span>.decimalPlaces=m.dp=<span class="fstat-no" title="function not covered" >function(){var e,r=this.d,t=NaN;if(r){if(e=r.length-1,t=(e-X(this.e/E))*E,e=r[e],e)for(;e%10==0;e/=10)t--;t&lt;0&amp;&amp;(t=0)}return t};m</span>.dividedBy=m.div=<span class="fstat-no" title="function not covered" >function(e){return L(this,new this.constructor(e))};m</span>.dividedToIntegerBy=m.divToInt=<span class="fstat-no" title="function not covered" >function(e){var r=this,t=r.constructor;return y(L(r,new t(e),0,1,1),t.precision,t.rounding)};m</span>.equals=m.eq=<span class="fstat-no" title="function not covered" >function(e){return this.cmp(e)===0};m</span>.floor=<span class="fstat-no" title="function not covered" >function(){return y(new this.constructor(this),this.e+1,3)};m</span>.greaterThan=m.gt=<span class="fstat-no" title="function not covered" >function(e){return this.cmp(e)&gt;0};m</span>.greaterThanOrEqualTo=m.gte=<span class="fstat-no" title="function not covered" >function(e){var r=this.cmp(e);return r==1||r===0};m</span>.hyperbolicCosine=m.cosh=<span class="fstat-no" title="function not covered" >function(){var e,r,t,n,i,o=this,s=o.constructor,a=new s(1);if(!o.isFinite())return new s(o.s?1/0:NaN);if(o.isZero())return a;t=s.precision,n=s.rounding,s.precision=t+Math.max(o.e,o.sd())+4,s.rounding=1,i=o.d.length,i&lt;32?(e=Math.ceil(i/3),r=(1/xn(4,e)).toString()):(e=16,r="2.3283064365386962890625e-10"),o=Tr(s,1,o.times(r),new s(1),!0);for(var l,u=e,c=new s(8);u--;)l=o.times(o),o=a.minus(l.times(c.minus(l.times(c))));return y(o,s.precision=t,s.rounding=n,!0)};m</span>.hyperbolicSine=m.sinh=<span class="fstat-no" title="function not covered" >function(){var e,r,t,n,i=this,o=i.constructor;if(!i.isFinite()||i.isZero())return new o(i);if(r=o.precision,t=o.rounding,o.precision=r+Math.max(i.e,i.sd())+4,o.rounding=1,n=i.d.length,n&lt;3)i=Tr(o,2,i,i,!0);else{e=1.4*Math.sqrt(n),e=e&gt;16?16:e|0,i=i.times(1/xn(5,e)),i=Tr(o,2,i,i,!0);for(var s,a=new o(5),l=new o(16),u=new o(20);e--;)s=i.times(i),i=i.times(a.plus(s.times(l.times(s).plus(u))))}return o.precision=r,o.rounding=t,y(i,r,t,!0)};m</span>.hyperbolicTangent=m.tanh=<span class="fstat-no" title="function not covered" >function(){var e,r,t=this,n=t.constructor;return t.isFinite()?t.isZero()?new n(t):(e=n.precision,r=n.rounding,n.precision=e+7,n.rounding=1,L(t.sinh(),t.cosh(),n.precision=e,n.rounding=r)):new n(t.s)};m</span>.inverseCosine=m.acos=<span class="fstat-no" title="function not covered" >function(){var e=this,r=e.constructor,t=e.abs().cmp(1),n=r.precision,i=r.rounding;return t!==-1?t===0?e.isNeg()?xe(r,n,i):new r(0):new r(NaN):e.isZero()?xe(r,n+4,i).times(.5):(r.precision=n+6,r.rounding=1,e=new r(1).minus(e).div(e.plus(1)).sqrt().atan(),r.precision=n,r.rounding=i,e.times(2))};m</span>.inverseHyperbolicCosine=m.acosh=<span class="fstat-no" title="function not covered" >function(){var e,r,t=this,n=t.constructor;return t.lte(1)?new n(t.eq(1)?0:NaN):t.isFinite()?(e=n.precision,r=n.rounding,n.precision=e+Math.max(Math.abs(t.e),t.sd())+4,n.rounding=1,w=!1,t=t.times(t).minus(1).sqrt().plus(t),w=!0,n.precision=e,n.rounding=r,t.ln()):new n(t)};m</span>.inverseHyperbolicSine=m.asinh=<span class="fstat-no" title="function not covered" >function(){var e,r,t=this,n=t.constructor;return!t.isFinite()||t.isZero()?new n(t):(e=n.precision,r=n.rounding,n.precision=e+2*Math.max(Math.abs(t.e),t.sd())+6,n.rounding=1,w=!1,t=t.times(t).plus(1).sqrt().plus(t),w=!0,n.precision=e,n.rounding=r,t.ln())};m</span>.inverseHyperbolicTangent=m.atanh=<span class="fstat-no" title="function not covered" >function(){var e,r,t,n,i=this,o=i.constructor;return i.isFinite()?i.e&gt;=0?new o(i.abs().eq(1)?i.s/0:i.isZero()?i:NaN):(e=o.precision,r=o.rounding,n=i.sd(),Math.max(n,e)&lt;2*-i.e-1?y(new o(i),e,r,!0):(o.precision=t=n-i.e,i=L(i.plus(1),new o(1).minus(i),t+e,1),o.precision=e+4,o.rounding=1,i=i.ln(),o.precision=e,o.rounding=r,i.times(.5))):new o(NaN)};m</span>.inverseSine=m.asin=<span class="fstat-no" title="function not covered" >function(){var e,r,t,n,i=this,o=i.constructor;return i.isZero()?new o(i):(r=i.abs().cmp(1),t=o.precision,n=o.rounding,r!==-1?r===0?(e=xe(o,t+4,n).times(.5),e.s=i.s,e):new o(NaN):(o.precision=t+6,o.rounding=1,i=i.div(new o(1).minus(i.times(i)).sqrt().plus(1)).atan(),o.precision=t,o.rounding=n,i.times(2)))};m</span>.inverseTangent=m.atan=<span class="fstat-no" title="function not covered" >function(){var e,r,t,n,i,o,s,a,l,u=this,c=u.constructor,p=c.precision,d=c.rounding;if(u.isFinite()){if(u.isZero())return new c(u);if(u.abs().eq(1)&amp;&amp;p+4&lt;=Qi)return s=xe(c,p+4,d).times(.25),s.s=u.s,s}else{if(!u.s)return new c(NaN);if(p+4&lt;=Qi)return s=xe(c,p+4,d).times(.5),s.s=u.s,s}for(c.precision=a=p+10,c.rounding=1,t=Math.min(28,a/E+2|0),e=t;e;--e)u=u.div(u.times(u).plus(1).sqrt().plus(1));for(w=!1,r=Math.ceil(a/E),n=1,l=u.times(u),s=new c(u),i=u;e!==-1;)if(i=i.times(l),o=s.minus(i.div(n+=2)),i=i.times(l),s=o.plus(i.div(n+=2)),s.d[r]!==void 0)for(e=r;s.d[e]===o.d[e]&amp;&amp;e--;);return t&amp;&amp;(s=s.times(2&lt;&lt;t-1)),w=!0,y(s,c.precision=p,c.rounding=d,!0)};m</span>.isFinite=<span class="fstat-no" title="function not covered" >function(){return!!this.d};m</span>.isInteger=m.isInt=<span class="fstat-no" title="function not covered" >function(){return!!this.d&amp;&amp;X(this.e/E)&gt;this.d.length-2};m</span>.isNaN=<span class="fstat-no" title="function not covered" >function(){return!this.s};m</span>.isNegative=m.isNeg=<span class="fstat-no" title="function not covered" >function(){return this.s&lt;0};m</span>.isPositive=m.isPos=<span class="fstat-no" title="function not covered" >function(){return this.s&gt;0};m</span>.isZero=<span class="fstat-no" title="function not covered" >function(){return!!this.d&amp;&amp;this.d[0]===0};m</span>.lessThan=m.lt=<span class="fstat-no" title="function not covered" >function(e){return this.cmp(e)&lt;0};m</span>.lessThanOrEqualTo=m.lte=<span class="fstat-no" title="function not covered" >function(e){return this.cmp(e)&lt;1};m</span>.logarithm=m.log=<span class="fstat-no" title="function not covered" >function(e){var r,t,n,i,o,s,a,l,u=this,c=u.constructor,p=c.precision,d=c.rounding,f=5;if(e==null)e=new c(10),r=!0;else{if(e=new c(e),t=e.d,e.s&lt;0||!t||!t[0]||e.eq(1))return new c(NaN);r=e.eq(10)}if(t=u.d,u.s&lt;0||!t||!t[0]||u.eq(1))return new c(t&amp;&amp;!t[0]?-1/0:u.s!=1?NaN:t?0:1/0);if(r)if(t.length&gt;1)o=!0;else{for(i=t[0];i%10===0;)i/=10;o=i!==1}if(w=!1,a=p+f,s=Ke(u,a),n=r?bn(c,a+10):Ke(e,a),l=L(s,n,a,1),ut(l.d,i=p,d))do if(a+=10,s=Ke(u,a),n=r?bn(c,a+10):Ke(e,a),l=L(s,n,a,1),!o){+J(l.d).slice(i+1,i+15)+1==1e14&amp;&amp;(l=y(l,p+1,0));break}while(ut(l.d,i+=10,d));return w=!0,y(l,p,d)};m</span>.minus=m.sub=<span class="fstat-no" title="function not covered" >function(e){var r,t,n,i,o,s,a,l,u,c,p,d,f=this,h=f.constructor;if(e=new h(e),!f.d||!e.d)return!f.s||!e.s?e=new h(NaN):f.d?e.s=-e.s:e=new h(e.d||f.s!==e.s?f:NaN),e;if(f.s!=e.s)return e.s=-e.s,f.plus(e);if(u=f.d,d=e.d,a=h.precision,l=h.rounding,!u[0]||!d[0]){if(d[0])e.s=-e.s;else if(u[0])e=new h(f);else return new h(l===3?-0:0);return w?y(e,a,l):e}if(t=X(e.e/E),c=X(f.e/E),u=u.slice(),o=c-t,o){for(p=o&lt;0,p?(r=u,o=-o,s=d.length):(r=d,t=c,s=u.length),n=Math.max(Math.ceil(a/E),s)+2,o&gt;n&amp;&amp;(o=n,r.length=1),r.reverse(),n=o;n--;)r.push(0);r.reverse()}else{for(n=u.length,s=d.length,p=n&lt;s,p&amp;&amp;(s=n),n=0;n&lt;s;n++)if(u[n]!=d[n]){p=u[n]&lt;d[n];break}o=0}for(p&amp;&amp;(r=u,u=d,d=r,e.s=-e.s),s=u.length,n=d.length-s;n&gt;0;--n)u[s++]=0;for(n=d.length;n&gt;o;){if(u[--n]&lt;d[n]){for(i=n;i&amp;&amp;u[--i]===0;)u[i]=fe-1;--u[i],u[n]+=fe}u[n]-=d[n]}for(;u[--s]===0;)u.pop();for(;u[0]===0;u.shift())--t;return u[0]?(e.d=u,e.e=wn(u,t),w?y(e,a,l):e):new h(l===3?-0:0)};m</span>.modulo=m.mod=<span class="fstat-no" title="function not covered" >function(e){var r,t=this,n=t.constructor;return e=new n(e),!t.d||!e.s||e.d&amp;&amp;!e.d[0]?new n(NaN):!e.d||t.d&amp;&amp;!t.d[0]?y(new n(t),n.precision,n.rounding):(w=!1,n.modulo==9?(r=L(t,e.abs(),0,3,1),r.s*=e.s):r=L(t,e,0,n.modulo,1),r=r.times(e),w=!0,t.minus(r))};m</span>.naturalExponential=m.exp=<span class="fstat-no" title="function not covered" >function(){return Wi(this)};m</span>.naturalLogarithm=m.ln=<span class="fstat-no" title="function not covered" >function(){return Ke(this)};m</span>.negated=m.neg=<span class="fstat-no" title="function not covered" >function(){var e=new this.constructor(this);return e.s=-e.s,y(e)};m</span>.plus=m.add=<span class="fstat-no" title="function not covered" >function(e){var r,t,n,i,o,s,a,l,u,c,p=this,d=p.constructor;if(e=new d(e),!p.d||!e.d)return!p.s||!e.s?e=new d(NaN):p.d||(e=new d(e.d||p.s===e.s?p:NaN)),e;if(p.s!=e.s)return e.s=-e.s,p.minus(e);if(u=p.d,c=e.d,a=d.precision,l=d.rounding,!u[0]||!c[0])return c[0]||(e=new d(p)),w?y(e,a,l):e;if(o=X(p.e/E),n=X(e.e/E),u=u.slice(),i=o-n,i){for(i&lt;0?(t=u,i=-i,s=c.length):(t=c,n=o,s=u.length),o=Math.ceil(a/E),s=o&gt;s?o+1:s+1,i&gt;s&amp;&amp;(i=s,t.length=1),t.reverse();i--;)t.push(0);t.reverse()}for(s=u.length,i=c.length,s-i&lt;0&amp;&amp;(i=s,t=c,c=u,u=t),r=0;i;)r=(u[--i]=u[i]+c[i]+r)/fe|0,u[i]%=fe;for(r&amp;&amp;(u.unshift(r),++n),s=u.length;u[--s]==0;)u.pop();return e.d=u,e.e=wn(u,n),w?y(e,a,l):e};m</span>.precision=m.sd=<span class="fstat-no" title="function not covered" >function(e){var r,t=this;if(e!==void 0&amp;&amp;e!==!!e&amp;&amp;e!==1&amp;&amp;e!==0)throw Error(He+e);return t.d?(r=Us(t.d),e&amp;&amp;t.e+1&gt;r&amp;&amp;(r=t.e+1)):r=NaN,r};m</span>.round=<span class="fstat-no" title="function not covered" >function(){var e=this,r=e.constructor;return y(new r(e),e.e+1,r.rounding)};m</span>.sine=m.sin=<span class="fstat-no" title="function not covered" >function(){var e,r,t=this,n=t.constructor;return t.isFinite()?t.isZero()?new n(t):(e=n.precision,r=n.rounding,n.precision=e+Math.max(t.e,t.sd())+E,n.rounding=1,t=Sp(n,Js(n,t)),n.precision=e,n.rounding=r,y(Ne&gt;2?t.neg():t,e,r,!0)):new n(NaN)};m</span>.squareRoot=m.sqrt=<span class="fstat-no" title="function not covered" >function(){var e,r,t,n,i,o,s=this,a=s.d,l=s.e,u=s.s,c=s.constructor;if(u!==1||!a||!a[0])return new c(!u||u&lt;0&amp;&amp;(!a||a[0])?NaN:a?s:1/0);for(w=!1,u=Math.sqrt(+s),u==0||u==1/0?(r=J(a),(r.length+l)%2==0&amp;&amp;(r+="0"),u=Math.sqrt(r),l=X((l+1)/2)-(l&lt;0||l%2),u==1/0?r="5e"+l:(r=u.toExponential(),r=r.slice(0,r.indexOf("e")+1)+l),n=new c(r)):n=new c(u.toString()),t=(l=c.precision)+3;;)if(o=n,n=o.plus(L(s,o,t+2,1)).times(.5),J(o.d).slice(0,t)===(r=J(n.d)).slice(0,t))if(r=r.slice(t-3,t+1),r=="9999"||!i&amp;&amp;r=="4999"){if(!i&amp;&amp;(y(o,l+1,0),o.times(o).eq(s))){n=o;break}t+=4,i=1}else{(!+r||!+r.slice(1)&amp;&amp;r.charAt(0)=="5")&amp;&amp;(y(n,l+1,1),e=!n.times(n).eq(s));break}return w=!0,y(n,l,c.rounding,e)};m</span>.tangent=m.tan=<span class="fstat-no" title="function not covered" >function(){var e,r,t=this,n=t.constructor;return t.isFinite()?t.isZero()?new n(t):(e=n.precision,r=n.rounding,n.precision=e+10,n.rounding=1,t=t.sin(),t.s=1,t=L(t,new n(1).minus(t.times(t)).sqrt(),e+10,0),n.precision=e,n.rounding=r,y(Ne==2||Ne==4?t.neg():t,e,r,!0)):new n(NaN)};m</span>.times=m.mul=<span class="fstat-no" title="function not covered" >function(e){var r,t,n,i,o,s,a,l,u,c=this,p=c.constructor,d=c.d,f=(e=new p(e)).d;if(e.s*=c.s,!d||!d[0]||!f||!f[0])return new p(!e.s||d&amp;&amp;!d[0]&amp;&amp;!f||f&amp;&amp;!f[0]&amp;&amp;!d?NaN:!d||!f?e.s/0:e.s*0);for(t=X(c.e/E)+X(e.e/E),l=d.length,u=f.length,l&lt;u&amp;&amp;(o=d,d=f,f=o,s=l,l=u,u=s),o=[],s=l+u,n=s;n--;)o.push(0);for(n=u;--n&gt;=0;){for(r=0,i=l+n;i&gt;n;)a=o[i]+f[n]*d[i-n-1]+r,o[i--]=a%fe|0,r=a/fe|0;o[i]=(o[i]+r)%fe|0}for(;!o[--s];)o.pop();return r?++t:o.shift(),e.d=o,e.e=wn(o,t),w?y(e,p.precision,p.rounding):e};m</span>.toBinary=<span class="fstat-no" title="function not covered" >function(e,r){return Ji(this,2,e,r)};m</span>.toDecimalPlaces=m.toDP=<span class="fstat-no" title="function not covered" >function(e,r){var t=this,n=t.constructor;return t=new n(t),e===void 0?t:(ne(e,0,Ye),r===void 0?r=n.rounding:ne(r,0,8),y(t,e+t.e+1,r))};m</span>.toExponential=<span class="fstat-no" title="function not covered" >function(e,r){var t,n=this,i=n.constructor;return e===void 0?t=ve(n,!0):(ne(e,0,Ye),r===void 0?r=i.rounding:ne(r,0,8),n=y(new i(n),e+1,r),t=ve(n,!0,e+1)),n.isNeg()&amp;&amp;!n.isZero()?"-"+t:t};m</span>.toFixed=<span class="fstat-no" title="function not covered" >function(e,r){var t,n,i=this,o=i.constructor;return e===void 0?t=ve(i):(ne(e,0,Ye),r===void 0?r=o.rounding:ne(r,0,8),n=y(new o(i),e+i.e+1,r),t=ve(n,!1,e+n.e+1)),i.isNeg()&amp;&amp;!i.isZero()?"-"+t:t};m</span>.toFraction=<span class="fstat-no" title="function not covered" >function(e){var r,t,n,i,o,s,a,l,u,c,p,d,f=this,h=f.d,g=f.constructor;if(!h)return new g(f);if(u=t=new g(1),n=l=new g(0),r=new g(n),o=r.e=Us(h)-f.e-1,s=o%E,r.d[0]=U(10,s&lt;0?E+s:s),e==null)e=o&gt;0?r:u;else{if(a=new g(e),!a.isInt()||a.lt(u))throw Error(He+a);e=a.gt(r)?o&gt;0?r:u:a}for(w=!1,a=new g(J(h)),c=g.precision,g.precision=o=h.length*E*2;p=L(a,r,0,1,1),i=t.plus(p.times(n)),i.cmp(e)!=1;)t=n,n=i,i=u,u=l.plus(p.times(i)),l=i,i=r,r=a.minus(p.times(i)),a=i;return i=L(e.minus(t),n,0,1,1),l=l.plus(i.times(u)),t=t.plus(i.times(n)),l.s=u.s=f.s,d=L(u,n,o,1).minus(f).abs().cmp(L(l,t,o,1).minus(f).abs())&lt;1?[u,n]:[l,t],g.precision=c,w=!0,d};m</span>.toHexadecimal=m.toHex=<span class="fstat-no" title="function not covered" >function(e,r){return Ji(this,16,e,r)};m</span>.toNearest=<span class="fstat-no" title="function not covered" >function(e,r){var t=this,n=t.constructor;if(t=new n(t),e==null){if(!t.d)return t;e=new n(1),r=n.rounding}else{if(e=new n(e),r===void 0?r=n.rounding:ne(r,0,8),!t.d)return e.s?t:e;if(!e.d)return e.s&amp;&amp;(e.s=t.s),e}return e.d[0]?(w=!1,t=L(t,e,0,r,1).times(e),w=!0,y(t)):(e.s=t.s,t=e),t};m</span>.toNumber=<span class="fstat-no" title="function not covered" >function(){return+this};m</span>.toOctal=<span class="fstat-no" title="function not covered" >function(e,r){return Ji(this,8,e,r)};m</span>.toPower=m.pow=<span class="fstat-no" title="function not covered" >function(e){var r,t,n,i,o,s,a=this,l=a.constructor,u=+(e=new l(e));if(!a.d||!e.d||!a.d[0]||!e.d[0])return new l(U(+a,u));if(a=new l(a),a.eq(1))return a;if(n=l.precision,o=l.rounding,e.eq(1))return y(a,n,o);if(r=X(e.e/E),r&gt;=e.d.length-1&amp;&amp;(t=u&lt;0?-u:u)&lt;=xp)return i=Gs(l,a,t,n),e.s&lt;0?new l(1).div(i):y(i,n,o);if(s=a.s,s&lt;0){if(r&lt;e.d.length-1)return new l(NaN);if((e.d[r]&amp;1)==0&amp;&amp;(s=1),a.e==0&amp;&amp;a.d[0]==1&amp;&amp;a.d.length==1)return a.s=s,a}return t=U(+a,u),r=t==0||!isFinite(t)?X(u*(Math.log("0."+J(a.d))/Math.LN10+a.e+1)):new l(t+"").e,r&gt;l.maxE+1||r&lt;l.minE-1?new l(r&gt;0?s/0:0):(w=!1,l.rounding=a.s=1,t=Math.min(12,(r+"").length),i=Wi(e.times(Ke(a,n+t)),n),i.d&amp;&amp;(i=y(i,n+5,1),ut(i.d,n,o)&amp;&amp;(r=n+10,i=y(Wi(e.times(Ke(a,r+t)),r),r+5,1),+J(i.d).slice(n+1,n+15)+1==1e14&amp;&amp;(i=y(i,n+1,0)))),i.s=s,w=!0,l.rounding=o,y(i,n,o))};m</span>.toPrecision=<span class="fstat-no" title="function not covered" >function(e,r){var t,n=this,i=n.constructor;return e===void 0?t=ve(n,n.e&lt;=i.toExpNeg||n.e&gt;=i.toExpPos):(ne(e,1,Ye),r===void 0?r=i.rounding:ne(r,0,8),n=y(new i(n),e,r),t=ve(n,e&lt;=n.e||n.e&lt;=i.toExpNeg,e)),n.isNeg()&amp;&amp;!n.isZero()?"-"+t:t};m</span>.toSignificantDigits=m.toSD=<span class="fstat-no" title="function not covered" >function(e,r){var t=this,n=t.constructor;return e===void 0?(e=n.precision,r=n.rounding):(ne(e,1,Ye),r===void 0?r=n.rounding:ne(r,0,8)),y(new n(t),e,r)};m</span>.toString=<span class="fstat-no" title="function not covered" >function(){var e=this,r=e.constructor,t=ve(e,e.e&lt;=r.toExpNeg||e.e&gt;=r.toExpPos);return e.isNeg()&amp;&amp;!e.isZero()?"-"+t:t};m</span>.truncated=m.trunc=<span class="fstat-no" title="function not covered" >function(){return y(new this.constructor(this),this.e+1,1)};m</span>.valueOf=m.toJSON=<span class="fstat-no" title="function not covered" >function(){var e=this,r=e.constructor,t=ve(e,e.e&lt;=r.toExpNeg||e.e&gt;=r.toExpPos);return e.isNeg()?"-"+t:t};<span class="fstat-no" title="function not covered" >f</span>unction J(e){var r,t,n,i=e.length-1,o="",s=e[0];if(i&gt;0){for(o+=s,r=1;r&lt;i;r++)n=e[r]+"",t=E-n.length,t&amp;&amp;(o+=Je(t)),o+=n;s=e[r],n=s+"",t=E-n.length,t&amp;&amp;(o+=Je(t))}else if(s===0)return"0";for(;s%10===0;)s/=10;return o+s}<span class="fstat-no" title="function not covered" >f</span>unction ne(e,r,t){if(e!==~~e||e&lt;r||e&gt;t)throw Error(He+e)}<span class="fstat-no" title="function not covered" >f</span>unction ut(e,r,t,n){var i,o,s,a;for(o=e[0];o&gt;=10;o/=10)--r;return--r&lt;0?(r+=E,i=0):(i=Math.ceil((r+1)/E),r%=E),o=U(10,E-r),a=e[i]%o|0,n==null?r&lt;3?(r==0?a=a/100|0:r==1&amp;&amp;(a=a/10|0),s=t&lt;4&amp;&amp;a==99999||t&gt;3&amp;&amp;a==49999||a==5e4||a==0):s=(t&lt;4&amp;&amp;a+1==o||t&gt;3&amp;&amp;a+1==o/2)&amp;&amp;(e[i+1]/o/100|0)==U(10,r-2)-1||(a==o/2||a==0)&amp;&amp;(e[i+1]/o/100|0)==0:r&lt;4?(r==0?a=a/1e3|0:r==1?a=a/100|0:r==2&amp;&amp;(a=a/10|0),s=(n||t&lt;4)&amp;&amp;a==9999||!n&amp;&amp;t&gt;3&amp;&amp;a==4999):s=((n||t&lt;4)&amp;&amp;a+1==o||!n&amp;&amp;t&gt;3&amp;&amp;a+1==o/2)&amp;&amp;(e[i+1]/o/1e3|0)==U(10,r-3)-1,s}<span class="fstat-no" title="function not covered" >f</span>unction fn(e,r,t){for(var n,i=[0],o,s=0,a=e.length;s&lt;a;){for(o=i.length;o--;)i[o]*=r;for(i[0]+=Ui.indexOf(e.charAt(s++)),n=0;n&lt;i.length;n++)i[n]&gt;t-1&amp;&amp;(i[n+1]===void 0&amp;&amp;(i[n+1]=0),i[n+1]+=i[n]/t|0,i[n]%=t)}return i.reverse()}<span class="fstat-no" title="function not covered" >f</span>unction Pp(e,r){var t,n,i;if(r.isZero())return r;n=r.d.length,n&lt;32?(t=Math.ceil(n/3),i=(1/xn(4,t)).toString()):(t=16,i="2.3283064365386962890625e-10"),e.precision+=t,r=Tr(e,1,r.times(i),new e(1));for(var o=t;o--;){var s=r.times(r);r=s.times(s).minus(s).times(8).plus(1)}return e.precision-=t,r}v</span>ar L=function(){<span class="fstat-no" title="function not covered" >function e(n,i,o){var s,a=0,l=n.length;for(n=n.slice();l--;)s=n[l]*i+a,n[l]=s%o|0,a=s/o|0;return a&amp;&amp;n.unshift(a),n}<span class="fstat-no" title="function not covered" >f</span>unction r(n,i,o,s){var a,l;if(o!=s)l=o&gt;s?1:-1;else for(a=l=0;a&lt;o;a++)if(n[a]!=i[a]){l=n[a]&gt;i[a]?1:-1;break}return l}<span class="fstat-no" title="function not covered" >f</span>unction t(n,i,o,s){for(var a=0;o--;)n[o]-=a,a=n[o]&lt;i[o]?1:0,n[o]=a*s+n[o]-i[o];for(;!n[0]&amp;&amp;n.length&gt;1;)n.shift()}r</span>eturn function(n,i,o,s,a,l){var u,c,p,d,f,h,g,I,T,S,b,D,me,se,Kr,j,te,Ae,K,fr,Vt=n.constructor,ti=n.s==i.s?1:-1,H=n.d,k=i.d;if(!H||!H[0]||!k||!k[0])return new Vt(!n.s||!i.s||(H?k&amp;&amp;H[0]==k[0]:!k)?NaN:H&amp;&amp;H[0]==0||!k?ti*0:ti/0);for(l?(f=1,c=n.e-i.e):(l=fe,f=E,c=X(n.e/f)-X(i.e/f)),K=k.length,te=H.length,T=new Vt(ti),S=T.d=[],p=0;k[p]==(H[p]||0);p++);if(k[p]&gt;(H[p]||0)&amp;&amp;c--,o==null?(se=o=Vt.precision,s=Vt.rounding):a?se=o+(n.e-i.e)+1:se=o,se&lt;0)S.push(1),h=!0;else{if(se=se/f+2|0,p=0,K==1){for(d=0,k=k[0],se++;(p&lt;te||d)&amp;&amp;se--;p++)Kr=d*l+(H[p]||0),S[p]=Kr/k|0,d=Kr%k|0;h=d||p&lt;te}else{for(d=l/(k[0]+1)|0,d&gt;1&amp;&amp;(k=e(k,d,l),H=e(H,d,l),K=k.length,te=H.length),j=K,b=H.slice(0,K),D=b.length;D&lt;K;)b[D++]=0;fr=k.slice(),fr.unshift(0),Ae=k[0],k[1]&gt;=l/2&amp;&amp;++Ae;do d=0,u=r(k,b,K,D),u&lt;0?(me=b[0],K!=D&amp;&amp;(me=me*l+(b[1]||0)),d=me/Ae|0,d&gt;1?(d&gt;=l&amp;&amp;(d=l-1),g=e(k,d,l),I=g.length,D=b.length,u=r(g,b,I,D),u==1&amp;&amp;(d--,t(g,K&lt;I?fr:k,I,l))):(d==0&amp;&amp;(u=d=1),g=k.slice()),I=g.length,I&lt;D&amp;&amp;g.unshift(0),t(b,g,D,l),u==-1&amp;&amp;(D=b.length,u=r(k,b,K,D),u&lt;1&amp;&amp;(d++,t(b,K&lt;D?fr:k,D,l))),D=b.length):u===0&amp;&amp;(d++,b=[0]),S[p++]=d,u&amp;&amp;b[0]?b[D++]=H[j]||0:(b=[H[j]],D=1);while((j++&lt;te||b[0]!==void 0)&amp;&amp;se--);h=b[0]!==void 0}S[0]||S.shift()}if(f==1)T.e=c,$s=h;else{for(p=1,d=S[0];d&gt;=10;d/=10)p++;T.e=p+c*f-1,y(T,a?o+T.e+1:o,s,h)}return T}}();<span class="fstat-no" title="function not covered" >function y(e,r,t,n){var i,o,s,a,l,u,c,p,d,f=e.constructor;e:if(r!=null){if(p=e.d,!p)return e;for(i=1,a=p[0];a&gt;=10;a/=10)i++;if(o=r-i,o&lt;0)o+=E,s=r,c=p[d=0],l=c/U(10,i-s-1)%10|0;else if(d=Math.ceil((o+1)/E),a=p.length,d&gt;=a)if(n){for(;a++&lt;=d;)p.push(0);c=l=0,i=1,o%=E,s=o-E+1}else break e;else{for(c=a=p[d],i=1;a&gt;=10;a/=10)i++;o%=E,s=o-E+i,l=s&lt;0?0:c/U(10,i-s-1)%10|0}if(n=n||r&lt;0||p[d+1]!==void 0||(s&lt;0?c:c%U(10,i-s-1)),u=t&lt;4?(l||n)&amp;&amp;(t==0||t==(e.s&lt;0?3:2)):l&gt;5||l==5&amp;&amp;(t==4||n||t==6&amp;&amp;(o&gt;0?s&gt;0?c/U(10,i-s):0:p[d-1])%10&amp;1||t==(e.s&lt;0?8:7)),r&lt;1||!p[0])return p.length=0,u?(r-=e.e+1,p[0]=U(10,(E-r%E)%E),e.e=-r||0):p[0]=e.e=0,e;if(o==0?(p.length=d,a=1,d--):(p.length=d+1,a=U(10,E-o),p[d]=s&gt;0?(c/U(10,i-s)%U(10,s)|0)*a:0),u)for(;;)if(d==0){for(o=1,s=p[0];s&gt;=10;s/=10)o++;for(s=p[0]+=a,a=1;s&gt;=10;s/=10)a++;o!=a&amp;&amp;(e.e++,p[0]==fe&amp;&amp;(p[0]=1));break}else{if(p[d]+=a,p[d]!=fe)break;p[d--]=0,a=1}for(o=p.length;p[--o]===0;)p.pop()}return w&amp;&amp;(e.e&gt;f.maxE?(e.d=null,e.e=NaN):e.e&lt;f.minE&amp;&amp;(e.e=0,e.d=[0])),e}<span class="fstat-no" title="function not covered" >f</span>unction ve(e,r,t){if(!e.isFinite())return Ws(e);var n,i=e.e,o=J(e.d),s=o.length;return r?(t&amp;&amp;(n=t-s)&gt;0?o=o.charAt(0)+"."+o.slice(1)+Je(n):s&gt;1&amp;&amp;(o=o.charAt(0)+"."+o.slice(1)),o=o+(e.e&lt;0?"e":"e+")+e.e):i&lt;0?(o="0."+Je(-i-1)+o,t&amp;&amp;(n=t-s)&gt;0&amp;&amp;(o+=Je(n))):i&gt;=s?(o+=Je(i+1-s),t&amp;&amp;(n=t-i-1)&gt;0&amp;&amp;(o=o+"."+Je(n))):((n=i+1)&lt;s&amp;&amp;(o=o.slice(0,n)+"."+o.slice(n)),t&amp;&amp;(n=t-s)&gt;0&amp;&amp;(i+1===s&amp;&amp;(o+="."),o+=Je(n))),o}<span class="fstat-no" title="function not covered" >f</span>unction wn(e,r){var t=e[0];for(r*=E;t&gt;=10;t/=10)r++;return r}<span class="fstat-no" title="function not covered" >f</span>unction bn(e,r,t){if(r&gt;vp)throw w=!0,t&amp;&amp;(e.precision=t),Error(qs);return y(new e(hn),r,1,!0)}<span class="fstat-no" title="function not covered" >f</span>unction xe(e,r,t){if(r&gt;Qi)throw Error(qs);return y(new e(yn),r,t,!0)}<span class="fstat-no" title="function not covered" >f</span>unction Us(e){var r=e.length-1,t=r*E+1;if(r=e[r],r){for(;r%10==0;r/=10)t--;for(r=e[0];r&gt;=10;r/=10)t++}return t}<span class="fstat-no" title="function not covered" >f</span>unction Je(e){for(var r="";e--;)r+="0";return r}<span class="fstat-no" title="function not covered" >f</span>unction Gs(e,r,t,n){var i,o=new e(1),s=Math.ceil(n/E+4);for(w=!1;;){if(t%2&amp;&amp;(o=o.times(r),Fs(o.d,s)&amp;&amp;(i=!0)),t=X(t/2),t===0){t=o.d.length-1,i&amp;&amp;o.d[t]===0&amp;&amp;++o.d[t];break}r=r.times(r),Fs(r.d,s)}return w=!0,o}<span class="fstat-no" title="function not covered" >f</span>unction Ls(e){return e.d[e.d.length-1]&amp;1}<span class="fstat-no" title="function not covered" >f</span>unction Qs(e,r,t){for(var n,i,o=new e(r[0]),s=0;++s&lt;r.length;){if(i=new e(r[s]),!i.s){o=i;break}n=o.cmp(i),(n===t||n===0&amp;&amp;o.s===t)&amp;&amp;(o=i)}return o}<span class="fstat-no" title="function not covered" >f</span>unction Wi(e,r){var t,n,i,o,s,a,l,u=0,c=0,p=0,d=e.constructor,f=d.rounding,h=d.precision;if(!e.d||!e.d[0]||e.e&gt;17)return new d(e.d?e.d[0]?e.s&lt;0?0:1/0:1:e.s?e.s&lt;0?0:e:NaN);for(r==null?(w=!1,l=h):l=r,a=new d(.03125);e.e&gt;-2;)e=e.times(a),p+=5;for(n=Math.log(U(2,p))/Math.LN10*2+5|0,l+=n,t=o=s=new d(1),d.precision=l;;){if(o=y(o.times(e),l,1),t=t.times(++c),a=s.plus(L(o,t,l,1)),J(a.d).slice(0,l)===J(s.d).slice(0,l)){for(i=p;i--;)s=y(s.times(s),l,1);if(r==null)if(u&lt;3&amp;&amp;ut(s.d,l-n,f,u))d.precision=l+=10,t=o=a=new d(1),c=0,u++;else return y(s,d.precision=h,f,w=!0);else return d.precision=h,s}s=a}}<span class="fstat-no" title="function not covered" >f</span>unction Ke(e,r){var t,n,i,o,s,a,l,u,c,p,d,f=1,h=10,g=e,I=g.d,T=g.constructor,S=T.rounding,b=T.precision;if(g.s&lt;0||!I||!I[0]||!g.e&amp;&amp;I[0]==1&amp;&amp;I.length==1)return new T(I&amp;&amp;!I[0]?-1/0:g.s!=1?NaN:I?0:g);if(r==null?(w=!1,c=b):c=r,T.precision=c+=h,t=J(I),n=t.charAt(0),Math.abs(o=g.e)&lt;15e14){for(;n&lt;7&amp;&amp;n!=1||n==1&amp;&amp;t.charAt(1)&gt;3;)g=g.times(e),t=J(g.d),n=t.charAt(0),f++;o=g.e,n&gt;1?(g=new T("0."+t),o++):g=new T(n+"."+t.slice(1))}else return u=bn(T,c+2,b).times(o+""),g=Ke(new T(n+"."+t.slice(1)),c-h).plus(u),T.precision=b,r==null?y(g,b,S,w=!0):g;for(p=g,l=s=g=L(g.minus(1),g.plus(1),c,1),d=y(g.times(g),c,1),i=3;;){if(s=y(s.times(d),c,1),u=l.plus(L(s,new T(i),c,1)),J(u.d).slice(0,c)===J(l.d).slice(0,c))if(l=l.times(2),o!==0&amp;&amp;(l=l.plus(bn(T,c+2,b).times(o+""))),l=L(l,new T(f),c,1),r==null)if(ut(l.d,c-h,S,a))T.precision=c+=h,u=s=g=L(p.minus(1),p.plus(1),c,1),d=y(g.times(g),c,1),i=a=1;else return y(l,T.precision=b,S,w=!0);else return T.precision=b,l;l=u,i+=2}}<span class="fstat-no" title="function not covered" >f</span>unction Ws(e){return String(e.s*e.s/0)}f</span>unction gn(e,r){var t,n,i;for((t=r.indexOf("."))&gt;-1&amp;&amp;(r=r.replace(".","")),(n=r.search(/e/i))&gt;0<span class="branch-0 cbranch-no" title="branch not covered" >?(t&lt;0&amp;&amp;(t=n),t+=+r.slice(n+1),r=r.substring(0,n)):t</span>&lt;0<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(t=r.length),</span>n=0;r.charCodeAt(n)===48;n++)<span class="branch-0 cbranch-no" title="branch not covered" >;f</span>or(i=r.length;r.charCodeAt(i-1)===48;--i)<span class="branch-0 cbranch-no" title="branch not covered" >;i</span>f(r=r.slice(n,i),r){if(i-=n,e.e=t=t-n-1,e.d=[],n=(t+1)%E,t&lt;0<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(n+=E),</span>n&lt;i){for(n&amp;&amp;e.d.push(+r.slice(0,n)),i-=E;n&lt;i;)e.d.push(+r.slice(n,n+=E));r=r.slice(n),n=E-r.length}<span class="branch-0 cbranch-no" title="branch not covered" >else n-=i;f</span>or(;n--;)r+="0";e.d.push(+r),w&amp;&amp;(e.e&gt;e.constructor.maxE<span class="branch-0 cbranch-no" title="branch not covered" >?(e.d=null,e.e=NaN):e</span>.e&lt;e.constructor.minE<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(e.e=0,e.d=[0]))</span>}<span class="branch-0 cbranch-no" title="branch not covered" >else e.e=0,e.d=[0];r</span>eturn e}<span class="fstat-no" title="function not covered" >function Tp(e,r){var t,n,i,o,s,a,l,u,c;if(r.indexOf("_")&gt;-1){if(r=r.replace(/(\d)_(?=\d)/g,"$1"),Bs.test(r))return gn(e,r)}else if(r==="Infinity"||r==="NaN")return+r||(e.s=NaN),e.e=NaN,e.d=null,e;if(Ep.test(r))t=16,r=r.toLowerCase();else if(bp.test(r))t=2;else if(wp.test(r))t=8;else throw Error(He+r);for(o=r.search(/p/i),o&gt;0?(l=+r.slice(o+1),r=r.substring(2,o)):r=r.slice(2),o=r.indexOf("."),s=o&gt;=0,n=e.constructor,s&amp;&amp;(r=r.replace(".",""),a=r.length,o=a-o,i=Gs(n,new n(t),o,o*2)),u=fn(r,t,fe),c=u.length-1,o=c;u[o]===0;--o)u.pop();return o&lt;0?new n(e.s*0):(e.e=wn(u,c),e.d=u,w=!1,s&amp;&amp;(e=L(e,i,a*4)),l&amp;&amp;(e=e.times(Math.abs(l)&lt;54?U(2,l):Le.pow(2,l))),w=!0,e)}<span class="fstat-no" title="function not covered" >f</span>unction Sp(e,r){var t,n=r.d.length;if(n&lt;3)return r.isZero()?r:Tr(e,2,r,r);t=1.4*Math.sqrt(n),t=t&gt;16?16:t|0,r=r.times(1/xn(5,t)),r=Tr(e,2,r,r);for(var i,o=new e(5),s=new e(16),a=new e(20);t--;)i=r.times(r),r=r.times(o.plus(i.times(s.times(i).minus(a))));return r}<span class="fstat-no" title="function not covered" >f</span>unction Tr(e,r,t,n,i){var o,s,a,l,u=1,c=e.precision,p=Math.ceil(c/E);for(w=!1,l=t.times(t),a=new e(n);;){if(s=L(a.times(l),new e(r++*r++),c,1),a=i?n.plus(s):n.minus(s),n=L(s.times(l),new e(r++*r++),c,1),s=a.plus(n),s.d[p]!==void 0){for(o=p;s.d[o]===a.d[o]&amp;&amp;o--;);if(o==-1)break}o=a,a=n,n=s,s=o,u++}return w=!0,s.d.length=p+1,s}<span class="fstat-no" title="function not covered" >f</span>unction xn(e,r){for(var t=e;--r;)t*=e;return t}<span class="fstat-no" title="function not covered" >f</span>unction Js(e,r){var t,n=r.s&lt;0,i=xe(e,e.precision,1),o=i.times(.5);if(r=r.abs(),r.lte(o))return Ne=n?4:1,r;if(t=r.divToInt(i),t.isZero())Ne=n?3:2;else{if(r=r.minus(t.times(i)),r.lte(o))return Ne=Ls(t)?n?2:3:n?4:1,r;Ne=Ls(t)?n?1:4:n?3:2}return r.minus(i).abs()}<span class="fstat-no" title="function not covered" >f</span>unction Ji(e,r,t,n){var i,o,s,a,l,u,c,p,d,f=e.constructor,h=t!==void 0;if(h?(ne(t,1,Ye),n===void 0?n=f.rounding:ne(n,0,8)):(t=f.precision,n=f.rounding),!e.isFinite())c=Ws(e);else{for(c=ve(e),s=c.indexOf("."),h?(i=2,r==16?t=t*4-3:r==8&amp;&amp;(t=t*3-2)):i=r,s&gt;=0&amp;&amp;(c=c.replace(".",""),d=new f(1),d.e=c.length-s,d.d=fn(ve(d),10,i),d.e=d.d.length),p=fn(c,10,i),o=l=p.length;p[--l]==0;)p.pop();if(!p[0])c=h?"0p+0":"0";else{if(s&lt;0?o--:(e=new f(e),e.d=p,e.e=o,e=L(e,d,t,n,0,i),p=e.d,o=e.e,u=$s),s=p[t],a=i/2,u=u||p[t+1]!==void 0,u=n&lt;4?(s!==void 0||u)&amp;&amp;(n===0||n===(e.s&lt;0?3:2)):s&gt;a||s===a&amp;&amp;(n===4||u||n===6&amp;&amp;p[t-1]&amp;1||n===(e.s&lt;0?8:7)),p.length=t,u)for(;++p[--t]&gt;i-1;)p[t]=0,t||(++o,p.unshift(1));for(l=p.length;!p[l-1];--l);for(s=0,c="";s&lt;l;s++)c+=Ui.charAt(p[s]);if(h){if(l&gt;1)if(r==16||r==8){for(s=r==16?4:3,--l;l%s;l++)c+="0";for(p=fn(c,i,r),l=p.length;!p[l-1];--l);for(s=1,c="1.";s&lt;l;s++)c+=Ui.charAt(p[s])}else c=c.charAt(0)+"."+c.slice(1);c=c+(o&lt;0?"p":"p+")+o}else if(o&lt;0){for(;++o;)c="0"+c;c="0."+c}else if(++o&gt;l)for(o-=l;o--;)c+="0";else o&lt;l&amp;&amp;(c=c.slice(0,o)+"."+c.slice(o))}c=(r==16?"0x":r==2?"0b":r==8?"0o":"")+c}return e.s&lt;0?"-"+c:c}<span class="fstat-no" title="function not covered" >f</span>unction Fs(e,r){if(e.length&gt;r)return e.length=r,!0}<span class="fstat-no" title="function not covered" >f</span>unction Rp(e){return new this(e).abs()}<span class="fstat-no" title="function not covered" >f</span>unction Ap(e){return new this(e).acos()}<span class="fstat-no" title="function not covered" >f</span>unction Cp(e){return new this(e).acosh()}<span class="fstat-no" title="function not covered" >f</span>unction Ip(e,r){return new this(e).plus(r)}<span class="fstat-no" title="function not covered" >f</span>unction Dp(e){return new this(e).asin()}<span class="fstat-no" title="function not covered" >f</span>unction Op(e){return new this(e).asinh()}<span class="fstat-no" title="function not covered" >f</span>unction kp(e){return new this(e).atan()}<span class="fstat-no" title="function not covered" >f</span>unction _p(e){return new this(e).atanh()}<span class="fstat-no" title="function not covered" >f</span>unction Np(e,r){e=new this(e),r=new this(r);var t,n=this.precision,i=this.rounding,o=n+4;return!e.s||!r.s?t=new this(NaN):!e.d&amp;&amp;!r.d?(t=xe(this,o,1).times(r.s&gt;0?.25:.75),t.s=e.s):!r.d||e.isZero()?(t=r.s&lt;0?xe(this,n,i):new this(0),t.s=e.s):!e.d||r.isZero()?(t=xe(this,o,1).times(.5),t.s=e.s):r.s&lt;0?(this.precision=o,this.rounding=1,t=this.atan(L(e,r,o,1)),r=xe(this,o,1),this.precision=n,this.rounding=i,t=e.s&lt;0?t.minus(r):t.plus(r)):t=this.atan(L(e,r,o,1)),t}<span class="fstat-no" title="function not covered" >f</span>unction Lp(e){return new this(e).cbrt()}<span class="fstat-no" title="function not covered" >f</span>unction Fp(e){return y(e=new this(e),e.e+1,2)}<span class="fstat-no" title="function not covered" >f</span>unction Mp(e,r,t){return new this(e).clamp(r,t)}f</span>unction $p(e){if(!e||typeof e!="object")<span class="branch-0 cbranch-no" title="branch not covered" >throw Error(En+"Object expected");v</span>ar r,t,n,i=e.defaults===!0,o=["precision",1,Ye,"rounding",0,8,"toExpNeg",-Pr,0,"toExpPos",0,Pr,"maxE",0,Pr,"minE",-Pr,0,"modulo",0,9];for(r=0;r&lt;o.length;r+=3)if(t=o[r],i<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(this[t]=Gi[t]),</span>(n=e[t])!==void 0)if(X(n)===n&amp;&amp;n&gt;=o[r+1]&amp;&amp;n&lt;=o[r+2])this[t]=n;<span class="branch-0 cbranch-no" title="branch not covered" >else throw Error(He+t+": "+n);i</span>f(t="crypto",i<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(this[t]=Gi[t]),</span>(n=e[t])!==void 0)if(n===!0||n===!1<span class="branch-0 cbranch-no" title="branch not covered" >||n===0<span class="branch-0 cbranch-no" title="branch not covered" >|</span>|n===1)</span>if(n<span class="branch-0 cbranch-no" title="branch not covered" >)if(typeof crypto&lt;"u"&amp;&amp;crypto&amp;&amp;(crypto.getRandomValues||crypto.randomBytes))this[t]=!0;else throw Error(Vs);else t</span>his[t]=!1;<span class="branch-0 cbranch-no" title="branch not covered" >else throw Error(He+t+": "+n);r</span>eturn this}<span class="fstat-no" title="function not covered" >function qp(e){return new this(e).cos()}<span class="fstat-no" title="function not covered" >f</span>unction Vp(e){return new this(e).cosh()}f</span>unction Ks(e){var r,t,n;function i(o){var s,a,l,u=this;if(!(u instanceof i))<span class="branch-0 cbranch-no" title="branch not covered" >return new i(o);i</span>f(u.constructor=i,Ms(o))<span class="branch-0 cbranch-no" title="branch not covered" >{u.s=o.s,w?!o.d||o.e&gt;i.maxE?(u.e=NaN,u.d=null):o.e&lt;i.minE?(u.e=0,u.d=[0]):(u.e=o.e,u.d=o.d.slice()):(u.e=o.e,u.d=o.d?o.d.slice():o.d);return}i</span>f(l=typeof o,l==="number")<span class="branch-0 cbranch-no" title="branch not covered" >{if(o===0){u.s=1/o&lt;0?-1:1,u.e=0,u.d=[0];return}if(o&lt;0?(o=-o,u.s=-1):u.s=1,o===~~o&amp;&amp;o&lt;1e7){for(s=0,a=o;a&gt;=10;a/=10)s++;w?s&gt;i.maxE?(u.e=NaN,u.d=null):s&lt;i.minE?(u.e=0,u.d=[0]):(u.e=s,u.d=[o]):(u.e=s,u.d=[o]);return}if(o*0!==0){o||(u.s=NaN),u.e=NaN,u.d=null;return}return gn(u,o.toString())}i</span>f(l==="string")return(a=o.charCodeAt(0))===45<span class="branch-0 cbranch-no" title="branch not covered" >?(o=o.slice(1),u.s=-1):(a</span>===43<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(o=o.slice(1)),</span>u.s=1),Bs.test(o)?gn(u,o)<span class="branch-0 cbranch-no" title="branch not covered" >:Tp(u,o)<span class="branch-0 cbranch-no" title="branch not covered" >;</span>if(l==="bigint")return o&lt;0?(o=-o,u.s=-1):u.s=1,gn(u,o.toString());throw Error(He+o)}i</span>f(i.prototype=m,i.ROUND_UP=0,i.ROUND_DOWN=1,i.ROUND_CEIL=2,i.ROUND_FLOOR=3,i.ROUND_HALF_UP=4,i.ROUND_HALF_DOWN=5,i.ROUND_HALF_EVEN=6,i.ROUND_HALF_CEIL=7,i.ROUND_HALF_FLOOR=8,i.EUCLID=9,i.config=i.set=$p,i.clone=Ks,i.isDecimal=Ms,i.abs=Rp,i.acos=Ap,i.acosh=Cp,i.add=Ip,i.asin=Dp,i.asinh=Op,i.atan=kp,i.atanh=_p,i.atan2=Np,i.cbrt=Lp,i.ceil=Fp,i.clamp=Mp,i.cos=qp,i.cosh=Vp,i.div=jp,i.exp=Bp,i.floor=Up,i.hypot=Gp,i.ln=Qp,i.log=Wp,i.log10=Kp,i.log2=Jp,i.max=Hp,i.min=Yp,i.mod=zp,i.mul=Zp,i.pow=Xp,i.random=ed,i.round=rd,i.sign=td,i.sin=nd,i.sinh=id,i.sqrt=od,i.sub=sd,i.sum=ad,i.tan=ld,i.tanh=ud,i.trunc=cd,e===void 0<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(e={}),</span>e&amp;&amp;e.defaults!==!0)for(n=["precision","rounding","toExpNeg","toExpPos","maxE","minE","modulo","crypto"],r=0;r&lt;n.length;)e.hasOwnProperty(t=n[r++])<span class="branch-0 cbranch-no" title="branch not covered" >||(e[t]=this[t]);</span>return i.config(e),i}<span class="fstat-no" title="function not covered" >function jp(e,r){return new this(e).div(r)}<span class="fstat-no" title="function not covered" >f</span>unction Bp(e){return new this(e).exp()}<span class="fstat-no" title="function not covered" >f</span>unction Up(e){return y(e=new this(e),e.e+1,3)}<span class="fstat-no" title="function not covered" >f</span>unction Gp(){var e,r,t=new this(0);for(w=!1,e=0;e&lt;arguments.length;)if(r=new this(arguments[e++]),r.d)t.d&amp;&amp;(t=t.plus(r.times(r)));else{if(r.s)return w=!0,new this(1/0);t=r}return w=!0,t.sqrt()}f</span>unction Ms(e){return e instanceof Le||e&amp;&amp;e.toStringTag===js||!1}<span class="fstat-no" title="function not covered" >function Qp(e){return new this(e).ln()}<span class="fstat-no" title="function not covered" >f</span>unction Wp(e,r){return new this(e).log(r)}<span class="fstat-no" title="function not covered" >f</span>unction Jp(e){return new this(e).log(2)}<span class="fstat-no" title="function not covered" >f</span>unction Kp(e){return new this(e).log(10)}<span class="fstat-no" title="function not covered" >f</span>unction Hp(){return Qs(this,arguments,-1)}<span class="fstat-no" title="function not covered" >f</span>unction Yp(){return Qs(this,arguments,1)}<span class="fstat-no" title="function not covered" >f</span>unction zp(e,r){return new this(e).mod(r)}<span class="fstat-no" title="function not covered" >f</span>unction Zp(e,r){return new this(e).mul(r)}<span class="fstat-no" title="function not covered" >f</span>unction Xp(e,r){return new this(e).pow(r)}<span class="fstat-no" title="function not covered" >f</span>unction ed(e){var r,t,n,i,o=0,s=new this(1),a=[];if(e===void 0?e=this.precision:ne(e,1,Ye),n=Math.ceil(e/E),this.crypto)if(crypto.getRandomValues)for(r=crypto.getRandomValues(new Uint32Array(n));o&lt;n;)i=r[o],i&gt;=429e7?r[o]=crypto.getRandomValues(new Uint32Array(1))[0]:a[o++]=i%1e7;else if(crypto.randomBytes){for(r=crypto.randomBytes(n*=4);o&lt;n;)i=r[o]+(r[o+1]&lt;&lt;8)+(r[o+2]&lt;&lt;16)+((r[o+3]&amp;127)&lt;&lt;24),i&gt;=214e7?crypto.randomBytes(4).copy(r,o):(a.push(i%1e7),o+=4);o=n/4}else throw Error(Vs);else for(;o&lt;n;)a[o++]=Math.random()*1e7|0;for(n=a[--o],e%=E,n&amp;&amp;e&amp;&amp;(i=U(10,E-e),a[o]=(n/i|0)*i);a[o]===0;o--)a.pop();if(o&lt;0)t=0,a=[0];else{for(t=-1;a[0]===0;t-=E)a.shift();for(n=1,i=a[0];i&gt;=10;i/=10)n++;n&lt;E&amp;&amp;(t-=E-n)}return s.e=t,s.d=a,s}<span class="fstat-no" title="function not covered" >f</span>unction rd(e){return y(e=new this(e),e.e+1,this.rounding)}<span class="fstat-no" title="function not covered" >f</span>unction td(e){return e=new this(e),e.d?e.d[0]?e.s:0*e.s:e.s||NaN}<span class="fstat-no" title="function not covered" >f</span>unction nd(e){return new this(e).sin()}<span class="fstat-no" title="function not covered" >f</span>unction id(e){return new this(e).sinh()}<span class="fstat-no" title="function not covered" >f</span>unction od(e){return new this(e).sqrt()}<span class="fstat-no" title="function not covered" >f</span>unction sd(e,r){return new this(e).sub(r)}<span class="fstat-no" title="function not covered" >f</span>unction ad(){var e=0,r=arguments,t=new this(r[e]);for(w=!1;t.s&amp;&amp;++e&lt;r.length;)t=t.plus(r[e]);return w=!0,y(t,this.precision,this.rounding)}<span class="fstat-no" title="function not covered" >f</span>unction ld(e){return new this(e).tan()}<span class="fstat-no" title="function not covered" >f</span>unction ud(e){return new this(e).tanh()}<span class="fstat-no" title="function not covered" >f</span>unction cd(e){return y(e=new this(e),e.e+1,1)}m</span>[Symbol.for("nodejs.util.inspect.custom")]=m.toString;m[Symbol.toStringTag]="Decimal";var Le=m.constructor=Ks(Gi);hn=new Le(hn);yn=new Le(yn);var Fe=Le;function Sr(e){return Le.isDecimal(e)<span class="branch-0 cbranch-no" title="branch not covered" >?!0:</span>e!==null&amp;&amp;typeof e=="object"&amp;&amp;typeof e.s=="number"<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;typeof e.e=="number"<span class="branch-0 cbranch-no" title="branch not covered" >&amp;</span>&amp;typeof e.toFixed=="function"<span class="branch-0 cbranch-no" title="branch not covered" >&amp;</span>&amp;Array.isArray(e.d)}</span>var ct={};tr(ct,{ModelAction:<span class="fstat-no" title="function not covered" >()=&gt;Rr,</span>datamodelEnumToSchemaEnum:<span class="fstat-no" title="function not covered" >()=&gt;pd}</span>);<span class="fstat-no" title="function not covered" >function pd(e){return{name:e.name,values:e.values.map(r=&gt;r.name)}}v</span>ar Rr=(b=&gt;(b.findUnique="findUnique",b.findUniqueOrThrow="findUniqueOrThrow",b.findFirst="findFirst",b.findFirstOrThrow="findFirstOrThrow",b.findMany="findMany",b.create="create",b.createMany="createMany",b.createManyAndReturn="createManyAndReturn",b.update="update",b.updateMany="updateMany",b.updateManyAndReturn="updateManyAndReturn",b.upsert="upsert",b.delete="delete",b.deleteMany="deleteMany",b.groupBy="groupBy",b.count="count",b.aggregate="aggregate",b.findRaw="findRaw",b.aggregateRaw="aggregateRaw",b))(Rr||{});var Xs=O(Di());var Zs=O(require("node:fs"));var Hs={keyword:De,entity:De,value:<span class="fstat-no" title="function not covered" >e=&gt;W(nr(e)),</span>punctuation:nr,directive:De,function:De,variable:<span class="fstat-no" title="function not covered" >e=&gt;W(nr(e)),</span>string:<span class="fstat-no" title="function not covered" >e=&gt;W(qe(e)),</span>boolean:Ie,number:De,comment:Hr};var dd=<span class="fstat-no" title="function not covered" >e=&gt;e,</span>vn={},md=0,v={manual:vn.Prism<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;vn.Prism.manual,</span>disableWorkerMessageHandler:vn.Prism<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;vn.Prism.disableWorkerMessageHandler,</span>util:{encode:<span class="fstat-no" title="function not covered" >function(e){if(e instanceof ge){let r=e;return new ge(r.type,v.util.encode(r.content),r.alias)}else return Array.isArray(e)?e.map(v.util.encode):e.replace(/&amp;/g,"&amp;amp;").replace(/&lt;/g,"&amp;lt;").replace(/\u00a0/g," ")},</span>type:function(e){return Object.prototype.toString.call(e).slice(8,-1)},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++md}),e.__id},clone:function e(r,t){let n,i,o=v.util.type(r);switch(t=t||{},o){case"Object":if(i=v.util.objId(r),t[i])return t[i];n={},t[i]=n;for(let s in r)r.hasOwnProperty(s)&amp;&amp;(n[s]=e(r[s],t));return n;case"Array":return i=v.util.objId(r),t[i]<span class="branch-0 cbranch-no" title="branch not covered" >?t[i]:</span>(n=[],t[i]=n,r.forEach(function(s,a){n[a]=e(s,t)}),n);default:return r}}},languages:{extend:function(e,r){let t=v.util.clone(v.languages[e]);for(let n in r)t[n]=r[n];return t},insertBefore:function(e,r,t,n){n=n||v.languages;let i=n[e],o={};for(let a in i)if(i.hasOwnProperty(a)){if(a==r)for(let l in t)t.hasOwnProperty(l)&amp;&amp;(o[l]=t[l]);t.hasOwnProperty(a)||(o[a]=i[a])}let s=n[e];return n[e]=o,v.languages.DFS(v.languages,function(a,l){l===s&amp;&amp;a!=e&amp;&amp;(this[a]=o)}),o},DFS:function e(r,t,n,i){i=i||{};let o=v.util.objId;for(let s in r)if(r.hasOwnProperty(s)){t.call(r,s,r[s],n||s);let a=r[s],l=v.util.type(a);l==="Object"&amp;&amp;!i[o(a)]?(i[o(a)]=!0,e(a,t,null,i)):l==="Array"&amp;&amp;!i[o(a)]&amp;&amp;(i[o(a)]=!0,e(a,t,s,i))}}},plugins:{},highlight:<span class="fstat-no" title="function not covered" >function(e,r,t){let n={code:e,grammar:r,language:t};return v.hooks.run("before-tokenize",n),n.tokens=v.tokenize(n.code,n.grammar),v.hooks.run("after-tokenize",n),ge.stringify(v.util.encode(n.tokens),n.language)},</span>matchGrammar:<span class="fstat-no" title="function not covered" >function(e,r,t,n,i,o,s){for(let g in t){if(!t.hasOwnProperty(g)||!t[g])continue;if(g==s)return;let I=t[g];I=v.util.type(I)==="Array"?I:[I];for(let T=0;T&lt;I.length;++T){let S=I[T],b=S.inside,D=!!S.lookbehind,me=!!S.greedy,se=0,Kr=S.alias;if(me&amp;&amp;!S.pattern.global){let j=S.pattern.toString().match(/[imuy]*$/)[0];S.pattern=RegExp(S.pattern.source,j+"g")}S=S.pattern||S;for(let j=n,te=i;j&lt;r.length;te+=r[j].length,++j){let Ae=r[j];if(r.length&gt;e.length)return;if(Ae instanceof ge)continue;if(me&amp;&amp;j!=r.length-1){S.lastIndex=te;var p=S.exec(e);if(!p)break;var c=p.index+(D?p[1].length:0),d=p.index+p[0].length,a=j,l=te;for(let k=r.length;a&lt;k&amp;&amp;(l&lt;d||!r[a].type&amp;&amp;!r[a-1].greedy);++a)l+=r[a].length,c&gt;=l&amp;&amp;(++j,te=l);if(r[j]instanceof ge)continue;u=a-j,Ae=e.slice(te,l),p.index-=te}else{S.lastIndex=0;var p=S.exec(Ae),u=1}if(!p){if(o)break;continue}D&amp;&amp;(se=p[1]?p[1].length:0);var c=p.index+se,p=p[0].slice(se),d=c+p.length,f=Ae.slice(0,c),h=Ae.slice(d);let K=[j,u];f&amp;&amp;(++j,te+=f.length,K.push(f));let fr=new ge(g,b?v.tokenize(p,b):p,Kr,p,me);if(K.push(fr),h&amp;&amp;K.push(h),Array.prototype.splice.apply(r,K),u!=1&amp;&amp;v.matchGrammar(e,r,t,j,te,!0,g),o)break}}}},</span>tokenize:<span class="fstat-no" title="function not covered" >function(e,r){let t=[e],n=r.rest;if(n){for(let i in n)r[i]=n[i];delete r.rest}return v.matchGrammar(e,t,r,0,0,!1),t},</span>hooks:{all:{},add:<span class="fstat-no" title="function not covered" >function(e,r){let t=v.hooks.all;t[e]=t[e]||[],t[e].push(r)},</span>run:<span class="fstat-no" title="function not covered" >function(e,r){let t=v.hooks.all[e];if(!(!t||!t.length))for(var n=0,i;i=t[n++];)i(r)}}</span>,Token:ge};v.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0,greedy:!0}],string:{pattern:/(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,lookbehind:!0,inside:{punctuation:/[.\\]/}},keyword:/\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,boolean:/\b(?:true|false)\b/,function:/\w+(?=\()/,number:/\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,operator:/--?|\+\+?|!=?=?|&lt;=?|&gt;=?|==?=?|&amp;&amp;?|\|\|?|\?|\*|\/|~|\^|%/,punctuation:/[{}[\];(),.:]/};v.languages.javascript=v.languages.extend("clike",{"class-name":[v.languages.clike["class-name"],{pattern:/(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/,lookbehind:!0}],keyword:[{pattern:/((?:^|})\s*)(?:catch|finally)\b/,lookbehind:!0},{pattern:/(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,lookbehind:!0}],number:/\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,function:/[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,operator:/-[-=]?|\+[+=]?|!=?=?|&lt;&lt;?=?|&gt;&gt;?&gt;?=?|=(?:==?|&gt;)?|&amp;[&amp;=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/});v.languages.javascript["class-name"][0].pattern=/(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;v.languages.insertBefore("javascript","keyword",{regex:{pattern:/((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/,lookbehind:!0,greedy:!0},"function-variable":{pattern:/[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=&gt;))/,alias:"function"},parameter:[{pattern:/(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/,lookbehind:!0,inside:v.languages.javascript},{pattern:/[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=&gt;)/i,inside:v.languages.javascript},{pattern:/(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=&gt;)/,lookbehind:!0,inside:v.languages.javascript},{pattern:/((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/,lookbehind:!0,inside:v.languages.javascript}],constant:/\b[A-Z](?:[A-Z_]|\dx?)*\b/});v.languages.markup<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;v.languages.markup.tag.addInlined("script","javascript");</span>v.languages.js=v.languages.javascript;v.languages.typescript=v.languages.extend("javascript",{keyword:/\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/,builtin:/\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/});v.languages.ts=v.languages.typescript;<span class="fstat-no" title="function not covered" >function ge(e,r,t,n,i){this.type=e,this.content=r,this.alias=t,this.length=(n||"").length|0,this.greedy=!!i}g</span>e.stringify=<span class="fstat-no" title="function not covered" >function(e,r){return typeof e=="string"?e:Array.isArray(e)?e.map(function(t){return ge.stringify(t,r)}).join(""):fd(e.type)(e.content)};<span class="fstat-no" title="function not covered" >f</span>unction fd(e){return Hs[e]||dd}<span class="fstat-no" title="function not covered" >f</span>unction Ys(e){return gd(e,v.languages.javascript)}<span class="fstat-no" title="function not covered" >f</span>unction gd(e,r){return v.tokenize(e,r).map(n=&gt;ge.stringify(n)).join("")}<span class="fstat-no" title="function not covered" >f</span>unction zs(e){return Ci(e)}v</span>ar Pn=class e<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{firstLineNumber;lines;static read(r){let t;try{t=Zs.default.readFileSync(r,"utf-8")}catch{return null}return e.fromContent(t)}static fromContent(r){let t=r.split(/\r?\n/);return new e(1,t)}constructor(r,t){this.firstLineNumber=r,this.lines=t}get lastLineNumber(){return this.firstLineNumber+this.lines.length-1}mapLineAt(r,t){if(r&lt;this.firstLineNumber||r&gt;this.lines.length+this.firstLineNumber)return this;let n=r-this.firstLineNumber,i=[...this.lines];return i[n]=t(i[n]),new e(this.firstLineNumber,i)}mapLines(r){return new e(this.firstLineNumber,this.lines.map((t,n)=&gt;r(t,this.firstLineNumber+n)))}lineAt(r){return this.lines[r-this.firstLineNumber]}prependSymbolAt(r,t){return this.mapLines((n,i)=&gt;i===r?`${t} ${n}`:`  ${n}`)}slice(r,t){let n=this.lines.slice(r-1,t).join(`</span></span>
<span class="cstat-no" title="statement not covered" >`);return new e(r,zs(n).split(`</span>
<span class="cstat-no" title="statement not covered" >`))}highlight(){let r=Ys(this.toString());return new e(this.firstLineNumber,r.split(`</span>
<span class="cstat-no" title="statement not covered" >`))}toString(){return this.lines.join(`</span>
`)}};var hd={red:ce,gray:Hr,dim:Ce,bold:W,underline:Y,highlightSource:<span class="fstat-no" title="function not covered" >e=&gt;e.highlight()}</span>,yd={red:<span class="fstat-no" title="function not covered" >e=&gt;e,</span>gray:<span class="fstat-no" title="function not covered" >e=&gt;e,</span>dim:<span class="fstat-no" title="function not covered" >e=&gt;e,</span>bold:<span class="fstat-no" title="function not covered" >e=&gt;e,</span>underline:<span class="fstat-no" title="function not covered" >e=&gt;e,</span>highlightSource:<span class="fstat-no" title="function not covered" >e=&gt;e}</span>;<span class="fstat-no" title="function not covered" >function bd({message:e,originalMethod:r,isPanic:t,callArguments:n}){return{functionName:`prisma.${r}()`,message:e,isPanic:t??!1,callArguments:n}}<span class="fstat-no" title="function not covered" >f</span>unction Ed({callsite:e,message:r,originalMethod:t,isPanic:n,callArguments:i},o){let s=bd({message:r,originalMethod:t,isPanic:n,callArguments:i});if(!e||typeof window&lt;"u"||process.env.NODE_ENV==="production")return s;let a=e.getLocation();if(!a||!a.lineNumber||!a.columnNumber)return s;let l=Math.max(1,a.lineNumber-3),u=Pn.read(a.fileName)?.slice(l,a.lineNumber),c=u?.lineAt(a.lineNumber);if(u&amp;&amp;c){let p=xd(c),d=wd(c);if(!d)return s;s.functionName=`${d.code})`,s.location=a,n||(u=u.mapLineAt(a.lineNumber,h=&gt;h.slice(0,d.openingBraceIndex))),u=o.highlightSource(u);let f=String(u.lastLineNumber).length;if(s.contextLines=u.mapLines((h,g)=&gt;o.gray(String(g).padStart(f))+" "+h).mapLines(h=&gt;o.dim(h)).prependSymbolAt(a.lineNumber,o.bold(o.red("\u2192"))),i){let h=p+f+1;h+=2,s.callArguments=(0,Xs.default)(i,h).slice(h)}}return s}<span class="fstat-no" title="function not covered" >f</span>unction wd(e){let r=Object.keys(Rr).join("|"),n=new RegExp(String.raw`\.(${r})\(`).exec(e);if(n){let i=n.index+n[0].length,o=e.lastIndexOf(" ",n.index)+1;return{code:e.slice(o,i),openingBraceIndex:i}}return null}<span class="fstat-no" title="function not covered" >f</span>unction xd(e){let r=0;for(let t=0;t&lt;e.length;t++){if(e.charAt(t)!==" ")return r;r++}return r}<span class="fstat-no" title="function not covered" >f</span>unction vd({functionName:e,location:r,message:t,isPanic:n,contextLines:i,callArguments:o},s){let a=[""],l=r?" in":":";if(n?(a.push(s.red(`Oops, an unknown error occurred! This is ${s.bold("on us")}, you did nothing wrong.`)),a.push(s.red(`It occurred in the ${s.bold(`\`${e}\``)} invocation${l}`))):a.push(s.red(`Invalid ${s.bold(`\`${e}\``)} invocation${l}`)),r&amp;&amp;a.push(s.underline(Pd(r))),i){a.push("");let u=[i.toString()];o&amp;&amp;(u.push(o),u.push(s.dim(")"))),a.push(u.join("")),o&amp;&amp;a.push("")}else a.push(""),o&amp;&amp;a.push(o),a.push("");return a.push(t),a.join(`</span>
`)}<span class="fstat-no" title="function not covered" >function Pd(e){let r=[e.fileName];return e.lineNumber&amp;&amp;r.push(String(e.lineNumber)),e.columnNumber&amp;&amp;r.push(String(e.columnNumber)),r.join(":")}<span class="fstat-no" title="function not covered" >f</span>unction Tn(e){let r=e.showColors?hd:yd,t;return t=Ed(e,r),vd(t,r)}v</span>ar la=O(Ki());<span class="fstat-no" title="function not covered" >function na(e,r,t){let n=ia(e),i=Td(n),o=Rd(i);o?Sn(o,r,t):r.addErrorMessage(()=&gt;"Unknown error")}<span class="fstat-no" title="function not covered" >f</span>unction ia(e){return e.errors.flatMap(r=&gt;r.kind==="Union"?ia(r):[r])}<span class="fstat-no" title="function not covered" >f</span>unction Td(e){let r=new Map,t=[];for(let n of e){if(n.kind!=="InvalidArgumentType"){t.push(n);continue}let i=`${n.selectionPath.join(".")}:${n.argumentPath.join(".")}`,o=r.get(i);o?r.set(i,{...n,argument:{...n.argument,typeNames:Sd(o.argument.typeNames,n.argument.typeNames)}}):r.set(i,n)}return t.push(...r.values()),t}<span class="fstat-no" title="function not covered" >f</span>unction Sd(e,r){return[...new Set(e.concat(r))]}<span class="fstat-no" title="function not covered" >f</span>unction Rd(e){return ji(e,(r,t)=&gt;{let n=ra(r),i=ra(t);return n!==i?n-i:ta(r)-ta(t)})}<span class="fstat-no" title="function not covered" >f</span>unction ra(e){let r=0;return Array.isArray(e.selectionPath)&amp;&amp;(r+=e.selectionPath.length),Array.isArray(e.argumentPath)&amp;&amp;(r+=e.argumentPath.length),r}<span class="fstat-no" title="function not covered" >f</span>unction ta(e){switch(e.kind){case"InvalidArgumentValue":case"ValueTooLarge":return 20;case"InvalidArgumentType":return 10;case"RequiredArgumentMissing":return-10;default:return 0}}v</span>ar le=class<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{constructor(r,t){this.name=r;this.value=t}isRequired=!1;makeRequired(){return this.isRequired=!0,this}write(r){let{colors:{green:t}}=r.context;r.addMarginSymbol(t(this.isRequired?"+":"?")),r.write(t(this.name)),this.isRequired||r.write(t("?")),r.write(t(": ")),typeof this.value=="string"?r.write(t(this.value)):r.write(this.value)}};s</span></span>a();var Ar=class<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{constructor(r=0,t){this.context=t;this.currentIndent=r}lines=[];currentLine="";currentIndent=0;marginSymbol;afterNextNewLineCallback;write(r){return typeof r=="string"?this.currentLine+=r:r.write(this),this}writeJoined(r,t,n=(i,o)=&gt;o.write(i)){let i=t.length-1;for(let o=0;o&lt;t.length;o++)n(t[o],this),o!==i&amp;&amp;this.write(r);return this}writeLine(r){return this.write(r).newLine()}newLine(){this.lines.push(this.indentedCurrentLine()),this.currentLine="",this.marginSymbol=void 0;let r=this.afterNextNewLineCallback;return this.afterNextNewLineCallback=void 0,r?.(),this}withIndent(r){return this.indent(),r(this),this.unindent(),this}afterNextNewline(r){return this.afterNextNewLineCallback=r,this}indent(){return this.currentIndent++,this}unindent(){return this.currentIndent&gt;0&amp;&amp;this.currentIndent--,this}addMarginSymbol(r){return this.marginSymbol=r,this}toString(){return this.lines.concat(this.indentedCurrentLine()).join(`</span></span>
`)}getCurrentLineLength(){return this.currentLine.length}indentedCurrentLine(){let r=this.currentLine.padStart(this.currentLine.length+2*this.currentIndent);return this.marginSymbol?this.marginSymbol+r.slice(1):r}};oa();var Rn=class{<span class="fstat-no" title="function not covered" >constructor(r){this.value=r}<span class="fstat-no" title="function not covered" >w</span>rite(r){r.write(this.value)}<span class="fstat-no" title="function not covered" >m</span>arkAsError(){this.value.markAsError()}}</span>;var An=<span class="fstat-no" title="function not covered" >e=&gt;e,</span>Cn={bold:An,red:An,green:An,dim:An,enabled:!1},aa={bold:W,red:ce,green:qe,dim:Ce,enabled:!0},Cr={<span class="fstat-no" title="function not covered" >write(e){e.writeLine(",")}}</span>;var Pe=class<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{constructor(r){this.contents=r}isUnderlined=!1;color=r=&gt;r;underline(){return this.isUnderlined=!0,this}setColor(r){return this.color=r,this}write(r){let t=r.getCurrentLineLength();r.write(this.color(this.contents)),this.isUnderlined&amp;&amp;r.afterNextNewline(()=&gt;{r.write(" ".repeat(t)).writeLine(this.color("~".repeat(this.contents.length)))})}};v</span></span>ar ze=class<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{hasError=!1;markAsError(){return this.hasError=!0,this}};v</span></span>ar Ir=class extends ze<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{items=[];addItem(r){return this.items.push(new Rn(r)),this}getField(r){return this.items[r]}getPrintWidth(){return this.items.length===0?2:Math.max(...this.items.map(t=&gt;t.value.getPrintWidth()))+2}write(r){if(this.items.length===0){this.writeEmpty(r);return}this.writeWithItems(r)}writeEmpty(r){let t=new Pe("[]");this.hasError&amp;&amp;t.setColor(r.context.colors.red).underline(),r.write(t)}writeWithItems(r){let{colors:t}=r.context;r.writeLine("[").withIndent(()=&gt;r.writeJoined(Cr,this.items).newLine()).write("]"),this.hasError&amp;&amp;r.afterNextNewline(()=&gt;{r.writeLine(t.red("~".repeat(this.getPrintWidth())))})}asObject(){}};v</span></span>ar Dr=class e extends ze<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{fields={};suggestions=[];addField(r){this.fields[r.name]=r}addSuggestion(r){this.suggestions.push(r)}getField(r){return this.fields[r]}getDeepField(r){let[t,...n]=r,i=this.getField(t);if(!i)return;let o=i;for(let s of n){let a;if(o.value instanceof e?a=o.value.getField(s):o.value instanceof Ir&amp;&amp;(a=o.value.getField(Number(s))),!a)return;o=a}return o}getDeepFieldValue(r){return r.length===0?this:this.getDeepField(r)?.value}hasField(r){return!!this.getField(r)}removeAllFields(){this.fields={}}removeField(r){delete this.fields[r]}getFields(){return this.fields}isEmpty(){return Object.keys(this.fields).length===0}getFieldValue(r){return this.getField(r)?.value}getDeepSubSelectionValue(r){let t=this;for(let n of r){if(!(t instanceof e))return;let i=t.getSubSelectionValue(n);if(!i)return;t=i}return t}getDeepSelectionParent(r){let t=this.getSelectionParent();if(!t)return;let n=t;for(let i of r){let o=n.value.getFieldValue(i);if(!o||!(o instanceof e))return;let s=o.getSelectionParent();if(!s)return;n=s}return n}getSelectionParent(){let r=this.getField("select")?.value.asObject();if(r)return{kind:"select",value:r};let t=this.getField("include")?.value.asObject();if(t)return{kind:"include",value:t}}getSubSelectionValue(r){return this.getSelectionParent()?.value.fields[r].value}getPrintWidth(){let r=Object.values(this.fields);return r.length==0?2:Math.max(...r.map(n=&gt;n.getPrintWidth()))+2}write(r){let t=Object.values(this.fields);if(t.length===0&amp;&amp;this.suggestions.length===0){this.writeEmpty(r);return}this.writeWithContents(r,t)}asObject(){return this}writeEmpty(r){let t=new Pe("{}");this.hasError&amp;&amp;t.setColor(r.context.colors.red).underline(),r.write(t)}writeWithContents(r,t){r.writeLine("{").withIndent(()=&gt;{r.writeJoined(Cr,[...t,...this.suggestions]).newLine()}),r.write("}"),this.hasError&amp;&amp;r.afterNextNewline(()=&gt;{r.writeLine(r.context.colors.red("~".repeat(this.getPrintWidth())))})}};v</span></span>ar Q=class extends ze{<span class="fstat-no" title="function not covered" >constructor(t){super();this.text=t}<span class="fstat-no" title="function not covered" >g</span>etPrintWidth(){return this.text.length}<span class="fstat-no" title="function not covered" >w</span>rite(t){let n=new Pe(this.text);this.hasError&amp;&amp;n.underline().setColor(t.context.colors.red),t.write(n)}<span class="fstat-no" title="function not covered" >a</span>sObject(){}}</span>;var pt=class<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{fields=[];addField(r,t){return this.fields.push({write(n){let{green:i,dim:o}=n.context.colors;n.write(i(o(`${r}: ${t}`))).addMarginSymbol(i(o("+")))}}),this}write(r){let{colors:{green:t}}=r.context;r.writeLine(t("{")).withIndent(()=&gt;{r.writeJoined(Cr,this.fields).newLine()}).write(t("}")).addMarginSymbol(t("+"))}};<span class="fstat-no" title="function not covered" >f</span></span>unction Sn(e,r,t){switch(e.kind){case"MutuallyExclusiveFields":Ad(e,r);break;case"IncludeOnScalar":Cd(e,r);break;case"EmptySelection":Id(e,r,t);break;case"UnknownSelectionField":_d(e,r);break;case"InvalidSelectionValue":Nd(e,r);break;case"UnknownArgument":Ld(e,r);break;case"UnknownInputField":Fd(e,r);break;case"RequiredArgumentMissing":Md(e,r);break;case"InvalidArgumentType":$d(e,r);break;case"InvalidArgumentValue":qd(e,r);break;case"ValueTooLarge":Vd(e,r);break;case"SomeFieldsMissing":jd(e,r);break;case"TooManyFieldsGiven":Bd(e,r);break;case"Union":na(e,r,t);break;default:throw new Error("not implemented: "+e.kind)}}<span class="fstat-no" title="function not covered" >f</span>unction Ad(e,r){let t=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();t&amp;&amp;(t.getField(e.firstField)?.markAsError(),t.getField(e.secondField)?.markAsError()),r.addErrorMessage(n=&gt;`Please ${n.bold("either")} use ${n.green(`\`${e.firstField}\``)} or ${n.green(`\`${e.secondField}\``)}, but ${n.red("not both")} at the same time.`)}<span class="fstat-no" title="function not covered" >f</span>unction Cd(e,r){let[t,n]=Or(e.selectionPath),i=e.outputType,o=r.arguments.getDeepSelectionParent(t)?.value;if(o&amp;&amp;(o.getField(n)?.markAsError(),i))for(let s of i.fields)s.isRelation&amp;&amp;o.addSuggestion(new le(s.name,"true"));r.addErrorMessage(s=&gt;{let a=`Invalid scalar field ${s.red(`\`${n}\``)} for ${s.bold("include")} statement`;return i?a+=` on model ${s.bold(i.name)}. ${dt(s)}`:a+=".",a+=`</span>
Note that ${s.bold("include")} statements only accept relation fields.`,a})}<span class="fstat-no" title="function not covered" >function Id(e,r,t){let n=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(n){let i=n.getField("omit")?.value.asObject();if(i){Dd(e,r,i);return}if(n.hasField("select")){Od(e,r);return}}if(t?.[We(e.outputType.name)]){kd(e,r);return}r.addErrorMessage(()=&gt;`Unknown field at "${e.selectionPath.join(".")} selection"`)}<span class="fstat-no" title="function not covered" >f</span>unction Dd(e,r,t){t.removeAllFields();for(let n of e.outputType.fields)t.addSuggestion(new le(n.name,"false"));r.addErrorMessage(n=&gt;`The ${n.red("omit")} statement includes every field of the model ${n.bold(e.outputType.name)}. At least one field must be included in the result`)}<span class="fstat-no" title="function not covered" >f</span>unction Od(e,r){let t=e.outputType,n=r.arguments.getDeepSelectionParent(e.selectionPath)?.value,i=n?.isEmpty()??!1;n&amp;&amp;(n.removeAllFields(),pa(n,t)),r.addErrorMessage(o=&gt;i?`The ${o.red("`select`")} statement for type ${o.bold(t.name)} must not be empty. ${dt(o)}`:`The ${o.red("`select`")} statement for type ${o.bold(t.name)} needs ${o.bold("at least one truthy value")}.`)}<span class="fstat-no" title="function not covered" >f</span>unction kd(e,r){let t=new pt;for(let i of e.outputType.fields)i.isRelation||t.addField(i.name,"false");let n=new le("omit",t).makeRequired();if(e.selectionPath.length===0)r.arguments.addSuggestion(n);else{let[i,o]=Or(e.selectionPath),a=r.arguments.getDeepSelectionParent(i)?.value.asObject()?.getField(o);if(a){let l=a?.value.asObject()??new Dr;l.addSuggestion(n),a.value=l}}r.addErrorMessage(i=&gt;`The global ${i.red("omit")} configuration excludes every field of the model ${i.bold(e.outputType.name)}. At least one field must be included in the result`)}<span class="fstat-no" title="function not covered" >f</span>unction _d(e,r){let t=da(e.selectionPath,r);if(t.parentKind!=="unknown"){t.field.markAsError();let n=t.parent;switch(t.parentKind){case"select":pa(n,e.outputType);break;case"include":Ud(n,e.outputType);break;case"omit":Gd(n,e.outputType);break}}r.addErrorMessage(n=&gt;{let i=[`Unknown field ${n.red(`\`${t.fieldName}\``)}`];return t.parentKind!=="unknown"&amp;&amp;i.push(`for ${n.bold(t.parentKind)} statement`),i.push(`on model ${n.bold(`\`${e.outputType.name}\``)}.`),i.push(dt(n)),i.join(" ")})}<span class="fstat-no" title="function not covered" >f</span>unction Nd(e,r){let t=da(e.selectionPath,r);t.parentKind!=="unknown"&amp;&amp;t.field.value.markAsError(),r.addErrorMessage(n=&gt;`Invalid value for selection field \`${n.red(t.fieldName)}\`: ${e.underlyingError}`)}<span class="fstat-no" title="function not covered" >f</span>unction Ld(e,r){let t=e.argumentPath[0],n=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();n&amp;&amp;(n.getField(t)?.markAsError(),Qd(n,e.arguments)),r.addErrorMessage(i=&gt;ua(i,t,e.arguments.map(o=&gt;o.name)))}<span class="fstat-no" title="function not covered" >f</span>unction Fd(e,r){let[t,n]=Or(e.argumentPath),i=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(i){i.getDeepField(e.argumentPath)?.markAsError();let o=i.getDeepFieldValue(t)?.asObject();o&amp;&amp;ma(o,e.inputType)}r.addErrorMessage(o=&gt;ua(o,n,e.inputType.fields.map(s=&gt;s.name)))}<span class="fstat-no" title="function not covered" >f</span>unction ua(e,r,t){let n=[`Unknown argument \`${e.red(r)}\`.`],i=Jd(r,t);return i&amp;&amp;n.push(`Did you mean \`${e.green(i)}\`?`),t.length&gt;0&amp;&amp;n.push(dt(e)),n.join(" ")}<span class="fstat-no" title="function not covered" >f</span>unction Md(e,r){let t;r.addErrorMessage(l=&gt;t?.value instanceof Q&amp;&amp;t.value.text==="null"?`Argument \`${l.green(o)}\` must not be ${l.red("null")}.`:`Argument \`${l.green(o)}\` is missing.`);let n=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(!n)return;let[i,o]=Or(e.argumentPath),s=new pt,a=n.getDeepFieldValue(i)?.asObject();if(a){if(t=a.getField(o),t&amp;&amp;a.removeField(o),e.inputTypes.length===1&amp;&amp;e.inputTypes[0].kind==="object"){for(let l of e.inputTypes[0].fields)s.addField(l.name,l.typeNames.join(" | "));a.addSuggestion(new le(o,s).makeRequired())}else{let l=e.inputTypes.map(ca).join(" | ");a.addSuggestion(new le(o,l).makeRequired())}if(e.dependentArgumentPath){n.getDeepField(e.dependentArgumentPath)?.markAsError();let[,l]=Or(e.dependentArgumentPath);r.addErrorMessage(u=&gt;`Argument \`${u.green(o)}\` is required because argument \`${u.green(l)}\` was provided.`)}}}<span class="fstat-no" title="function not covered" >f</span>unction ca(e){return e.kind==="list"?`${ca(e.elementType)}[]`:e.name}<span class="fstat-no" title="function not covered" >f</span>unction $d(e,r){let t=e.argument.name,n=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();n&amp;&amp;n.getDeepFieldValue(e.argumentPath)?.markAsError(),r.addErrorMessage(i=&gt;{let o=In("or",e.argument.typeNames.map(s=&gt;i.green(s)));return`Argument \`${i.bold(t)}\`: Invalid value provided. Expected ${o}, provided ${i.red(e.inferredType)}.`})}<span class="fstat-no" title="function not covered" >f</span>unction qd(e,r){let t=e.argument.name,n=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();n&amp;&amp;n.getDeepFieldValue(e.argumentPath)?.markAsError(),r.addErrorMessage(i=&gt;{let o=[`Invalid value for argument \`${i.bold(t)}\``];if(e.underlyingError&amp;&amp;o.push(`: ${e.underlyingError}`),o.push("."),e.argument.typeNames.length&gt;0){let s=In("or",e.argument.typeNames.map(a=&gt;i.green(a)));o.push(` Expected ${s}.`)}return o.join("")})}<span class="fstat-no" title="function not covered" >f</span>unction Vd(e,r){let t=e.argument.name,n=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(),i;if(n){let s=n.getDeepField(e.argumentPath)?.value;s?.markAsError(),s instanceof Q&amp;&amp;(i=s.text)}r.addErrorMessage(o=&gt;{let s=["Unable to fit value"];return i&amp;&amp;s.push(o.red(i)),s.push(`into a 64-bit signed integer for field \`${o.bold(t)}\``),s.join(" ")})}<span class="fstat-no" title="function not covered" >f</span>unction jd(e,r){let t=e.argumentPath[e.argumentPath.length-1],n=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(n){let i=n.getDeepFieldValue(e.argumentPath)?.asObject();i&amp;&amp;ma(i,e.inputType)}r.addErrorMessage(i=&gt;{let o=[`Argument \`${i.bold(t)}\` of type ${i.bold(e.inputType.name)} needs`];return e.constraints.minFieldCount===1?e.constraints.requiredFields?o.push(`${i.green("at least one of")} ${In("or",e.constraints.requiredFields.map(s=&gt;`\`${i.bold(s)}\``))} arguments.`):o.push(`${i.green("at least one")} argument.`):o.push(`${i.green(`at least ${e.constraints.minFieldCount}`)} arguments.`),o.push(dt(i)),o.join(" ")})}<span class="fstat-no" title="function not covered" >f</span>unction Bd(e,r){let t=e.argumentPath[e.argumentPath.length-1],n=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(),i=[];if(n){let o=n.getDeepFieldValue(e.argumentPath)?.asObject();o&amp;&amp;(o.markAsError(),i=Object.keys(o.getFields()))}r.addErrorMessage(o=&gt;{let s=[`Argument \`${o.bold(t)}\` of type ${o.bold(e.inputType.name)} needs`];return e.constraints.minFieldCount===1&amp;&amp;e.constraints.maxFieldCount==1?s.push(`${o.green("exactly one")} argument,`):e.constraints.maxFieldCount==1?s.push(`${o.green("at most one")} argument,`):s.push(`${o.green(`at most ${e.constraints.maxFieldCount}`)} arguments,`),s.push(`but you provided ${In("and",i.map(a=&gt;o.red(a)))}. Please choose`),e.constraints.maxFieldCount===1?s.push("one."):s.push(`${e.constraints.maxFieldCount}.`),s.join(" ")})}<span class="fstat-no" title="function not covered" >f</span>unction pa(e,r){for(let t of r.fields)e.hasField(t.name)||e.addSuggestion(new le(t.name,"true"))}<span class="fstat-no" title="function not covered" >f</span>unction Ud(e,r){for(let t of r.fields)t.isRelation&amp;&amp;!e.hasField(t.name)&amp;&amp;e.addSuggestion(new le(t.name,"true"))}<span class="fstat-no" title="function not covered" >f</span>unction Gd(e,r){for(let t of r.fields)!e.hasField(t.name)&amp;&amp;!t.isRelation&amp;&amp;e.addSuggestion(new le(t.name,"true"))}<span class="fstat-no" title="function not covered" >f</span>unction Qd(e,r){for(let t of r)e.hasField(t.name)||e.addSuggestion(new le(t.name,t.typeNames.join(" | ")))}<span class="fstat-no" title="function not covered" >f</span>unction da(e,r){let[t,n]=Or(e),i=r.arguments.getDeepSubSelectionValue(t)?.asObject();if(!i)return{parentKind:"unknown",fieldName:n};let o=i.getFieldValue("select")?.asObject(),s=i.getFieldValue("include")?.asObject(),a=i.getFieldValue("omit")?.asObject(),l=o?.getField(n);return o&amp;&amp;l?{parentKind:"select",parent:o,field:l,fieldName:n}:(l=s?.getField(n),s&amp;&amp;l?{parentKind:"include",field:l,parent:s,fieldName:n}:(l=a?.getField(n),a&amp;&amp;l?{parentKind:"omit",field:l,parent:a,fieldName:n}:{parentKind:"unknown",fieldName:n}))}<span class="fstat-no" title="function not covered" >f</span>unction ma(e,r){if(r.kind==="object")for(let t of r.fields)e.hasField(t.name)||e.addSuggestion(new le(t.name,t.typeNames.join(" | ")))}<span class="fstat-no" title="function not covered" >f</span>unction Or(e){let r=[...e],t=r.pop();if(!t)throw new Error("unexpected empty path");return[r,t]}<span class="fstat-no" title="function not covered" >f</span>unction dt({green:e,enabled:r}){return"Available options are "+(r?`listed in ${e("green")}`:"marked with ?")+"."}<span class="fstat-no" title="function not covered" >f</span>unction In(e,r){if(r.length===1)return r[0];let t=[...r],n=t.pop();return`${t.join(", ")} ${e} ${n}`}v</span>ar Wd=3;<span class="fstat-no" title="function not covered" >function Jd(e,r){let t=1/0,n;for(let i of r){let o=(0,la.default)(e,i);o&gt;Wd||o&lt;t&amp;&amp;(t=o,n=i)}return n}v</span>ar mt=class<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{modelName;name;typeName;isList;isEnum;constructor(r,t,n,i,o){this.modelName=r,this.name=t,this.typeName=n,this.isList=i,this.isEnum=o}_toGraphQLInputType(){let r=this.isList?"List":"",t=this.isEnum?"Enum":"";return`${r}${t}${this.typeName}FieldRefInput&lt;${this.modelName}&gt;`}};f</span></span>unction kr(e){return e instanceof mt}var Dn=Symbol(),Yi=new WeakMap,Me=class{constructor(r){r===Dn?Yi.set(this,`Prisma.${this._getName()}`)<span class="branch-0 cbranch-no" title="branch not covered" >:Yi.set(this,`new Prisma.${this._getNamespace()}.${this._getName()}()`)}</span>_getName(){return this.constructor.name}<span class="fstat-no" title="function not covered" >toString(){return Yi.get(this)}}</span>,ft=class extends Me{<span class="fstat-no" title="function not covered" >_getNamespace(){return"NullTypes"}}</span>,gt=class extends ft{#e};zi(gt,"DbNull");var ht=class extends ft{#e};zi(ht,"JsonNull");var yt=class extends ft{#e};zi(yt,"AnyNull");var On={classes:{DbNull:gt,JsonNull:ht,AnyNull:yt},instances:{DbNull:new gt(Dn),JsonNull:new ht(Dn),AnyNull:new yt(Dn)}};function zi(e,r){Object.defineProperty(e,"name",{value:r,configurable:!0})}var fa=": ",kn=class<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{constructor(r,t){this.name=r;this.value=t}hasError=!1;markAsError(){this.hasError=!0}getPrintWidth(){return this.name.length+this.value.getPrintWidth()+fa.length}write(r){let t=new Pe(this.name);this.hasError&amp;&amp;t.underline().setColor(r.context.colors.red),r.write(t).write(fa).write(this.value)}};</span></span>var Zi=class<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{arguments;errorMessages=[];constructor(r){this.arguments=r}write(r){r.write(this.arguments)}addErrorMessage(r){this.errorMessages.push(r)}renderAllMessages(r){return this.errorMessages.map(t=&gt;t(r)).join(`</span></span>
`)}};<span class="fstat-no" title="function not covered" >function _r(e){return new Zi(ga(e))}<span class="fstat-no" title="function not covered" >f</span>unction ga(e){let r=new Dr;for(let[t,n]of Object.entries(e)){let i=new kn(t,ha(n));r.addField(i)}return r}<span class="fstat-no" title="function not covered" >f</span>unction ha(e){if(typeof e=="string")return new Q(JSON.stringify(e));if(typeof e=="number"||typeof e=="boolean")return new Q(String(e));if(typeof e=="bigint")return new Q(`${e}n`);if(e===null)return new Q("null");if(e===void 0)return new Q("undefined");if(Sr(e))return new Q(`new Prisma.Decimal("${e.toFixed()}")`);if(e instanceof Uint8Array)return Buffer.isBuffer(e)?new Q(`Buffer.alloc(${e.byteLength})`):new Q(`new Uint8Array(${e.byteLength})`);if(e instanceof Date){let r=mn(e)?e.toISOString():"Invalid Date";return new Q(`new Date("${r}")`)}return e instanceof Me?new Q(`Prisma.${e._getName()}`):kr(e)?new Q(`prisma.${We(e.modelName)}.$fields.${e.name}`):Array.isArray(e)?Kd(e):typeof e=="object"?ga(e):new Q(Object.prototype.toString.call(e))}<span class="fstat-no" title="function not covered" >f</span>unction Kd(e){let r=new Ir;for(let t of e)r.addItem(ha(t));return r}<span class="fstat-no" title="function not covered" >f</span>unction _n(e,r){let t=r==="pretty"?aa:Cn,n=e.renderAllMessages(t),i=new Ar(0,{colors:t}).write(e).toString();return{message:n,args:i}}<span class="fstat-no" title="function not covered" >f</span>unction Nn({args:e,errors:r,errorFormat:t,callsite:n,originalMethod:i,clientVersion:o,globalOmit:s}){let a=_r(e);for(let p of r)Sn(p,a,s);let{message:l,args:u}=_n(a,t),c=Tn({message:l,callsite:n,originalMethod:i,showColors:t==="pretty",callArguments:u});throw new Z(c,{clientVersion:o})}f</span>unction Te(e){return e.replace(/^./,r=&gt;r.toLowerCase())}<span class="fstat-no" title="function not covered" >function ba(e,r,t){let n=Te(t);return!r.result||!(r.result.$allModels||r.result[n])?e:Hd({...e,...ya(r.name,e,r.result.$allModels),...ya(r.name,e,r.result[n])})}<span class="fstat-no" title="function not covered" >f</span>unction Hd(e){let r=new we,t=(n,i)=&gt;r.getOrCreate(n,()=&gt;i.has(n)?[n]:(i.add(n),e[n]?e[n].needs.flatMap(o=&gt;t(o,i)):[n]));return pn(e,n=&gt;({...n,needs:t(n.name,new Set)}))}<span class="fstat-no" title="function not covered" >f</span>unction ya(e,r,t){return t?pn(t,({needs:n,compute:i},o)=&gt;({name:o,needs:n?Object.keys(n).filter(s=&gt;n[s]):[],compute:Yd(r,o,i)})):{}}<span class="fstat-no" title="function not covered" >f</span>unction Yd(e,r,t){let n=e?.[r]?.compute;return n?i=&gt;t({...i,[r]:n(i)}):t}<span class="fstat-no" title="function not covered" >f</span>unction Ea(e,r){if(!r)return e;let t={...e};for(let n of Object.values(r))if(e[n.name])for(let i of n.needs)t[i]=!0;return t}f</span>unction wa(e,r){if(!r)return e<span class="branch-0 cbranch-no" title="branch not covered" >;let t={...e};for(let n of Object.values(r))if(!e[n.name])for(let i of n.needs)delete t[i];return t}v</span>ar Ln=class<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{constructor(r,t){this.extension=r;this.previous=t}computedFieldsCache=new we;modelExtensionsCache=new we;queryCallbacksCache=new we;clientExtensions=lt(()=&gt;this.extension.client?{...this.previous?.getAllClientExtensions(),...this.extension.client}:this.previous?.getAllClientExtensions());batchCallbacks=lt(()=&gt;{let r=this.previous?.getAllBatchQueryCallbacks()??[],t=this.extension.query?.$__internalBatch;return t?r.concat(t):r});getAllComputedFields(r){return this.computedFieldsCache.getOrCreate(r,()=&gt;ba(this.previous?.getAllComputedFields(r),this.extension,r))}getAllClientExtensions(){return this.clientExtensions.get()}getAllModelExtensions(r){return this.modelExtensionsCache.getOrCreate(r,()=&gt;{let t=Te(r);return!this.extension.model||!(this.extension.model[t]||this.extension.model.$allModels)?this.previous?.getAllModelExtensions(r):{...this.previous?.getAllModelExtensions(r),...this.extension.model.$allModels,...this.extension.model[t]}})}getAllQueryCallbacks(r,t){return this.queryCallbacksCache.getOrCreate(`${r}:${t}`,()=&gt;{let n=this.previous?.getAllQueryCallbacks(r,t)??[],i=[],o=this.extension.query;return!o||!(o[r]||o.$allModels||o[t]||o.$allOperations)?n:(o[r]!==void 0&amp;&amp;(o[r][t]!==void 0&amp;&amp;i.push(o[r][t]),o[r].$allOperations!==void 0&amp;&amp;i.push(o[r].$allOperations)),r!=="$none"&amp;&amp;o.$allModels!==void 0&amp;&amp;(o.$allModels[t]!==void 0&amp;&amp;i.push(o.$allModels[t]),o.$allModels.$allOperations!==void 0&amp;&amp;i.push(o.$allModels.$allOperations)),o[t]!==void 0&amp;&amp;i.push(o[t]),o.$allOperations!==void 0&amp;&amp;i.push(o.$allOperations),n.concat(i))})}getAllBatchQueryCallbacks(){return this.batchCallbacks.get()}},</span></span>Nr=class e{constructor(r){this.head=r}static empty(){return new e}static <span class="fstat-no" title="function not covered" >single(r){return new e(new Ln(r))}i</span>sEmpty(){return this.head===void 0}<span class="fstat-no" title="function not covered" >append(r){return new e(new Ln(r,this.head))}g</span>etAllComputedFields(r){return this.head<span class="branch-0 cbranch-no" title="branch not covered" >?.getAllComputedFields(</span>r)}getAllClientExtensions(){return this.head<span class="branch-0 cbranch-no" title="branch not covered" >?.getAllClientExtensions(</span>)}getAllModelExtensions(r){return this.head<span class="branch-0 cbranch-no" title="branch not covered" >?.getAllModelExtensions(</span>r)}<span class="fstat-no" title="function not covered" >getAllQueryCallbacks(r,t){return this.head?.getAllQueryCallbacks(r,t)??[]}<span class="fstat-no" title="function not covered" >g</span>etAllBatchQueryCallbacks(){return this.head?.getAllBatchQueryCallbacks()??[]}}</span>;var Fn=class{<span class="fstat-no" title="function not covered" >constructor(r){this.name=r}}</span>;function xa(e){return e instanceof Fn}<span class="fstat-no" title="function not covered" >function va(e){return new Fn(e)}v</span>ar Pa=Symbol(),bt=class{constructor(r){if(r!==Pa)<span class="branch-0 cbranch-no" title="branch not covered" >throw new Error("Skip instance can not be constructed directly")}<span class="fstat-no" title="function not covered" >i</span>fUndefined(r){return r===void 0?Mn:r}}</span>,Mn=new bt(Pa);function Se(e){return e instanceof bt}var zd={findUnique:"findUnique",findUniqueOrThrow:"findUniqueOrThrow",findFirst:"findFirst",findFirstOrThrow:"findFirstOrThrow",findMany:"findMany",count:"aggregate",create:"createOne",createMany:"createMany",createManyAndReturn:"createManyAndReturn",update:"updateOne",updateMany:"updateMany",updateManyAndReturn:"updateManyAndReturn",upsert:"upsertOne",delete:"deleteOne",deleteMany:"deleteMany",executeRaw:"executeRaw",queryRaw:"queryRaw",aggregate:"aggregate",groupBy:"groupBy",runCommandRaw:"runCommandRaw",findRaw:"findRaw",aggregateRaw:"aggregateRaw"},Ta="explicitly `undefined` values are not allowed";function $n({modelName:e,action:r,args:t,runtimeDataModel:n,extensions:i=Nr.empty(),callsite:o,clientMethod:s,errorFormat:a,clientVersion:l,previewFeatures:u,globalOmit:c}){let p=new Xi({runtimeDataModel:n,modelName:e,action:r,rootArgs:t,callsite:o,extensions:i,selectionPath:[],argumentPath:[],originalMethod:s,errorFormat:a,clientVersion:l,previewFeatures:u,globalOmit:c});return{modelName:e,action:zd[r],query:Et(t,p)}}function Et({select:e,include:r,...t}={},n){let i=t.omit;return delete t.omit,{arguments:Ra(t,n),selection:Zd(e,r,i,n)}}function Zd(e,r,t,n){return e<span class="branch-0 cbranch-no" title="branch not covered" >?(r?n.throwValidationError({kind:"MutuallyExclusiveFields",firstField:"include",secondField:"select",selectionPath:n.getSelectionPath()}):t&amp;&amp;n.throwValidationError({kind:"MutuallyExclusiveFields",firstField:"omit",secondField:"select",selectionPath:n.getSelectionPath()}),tm(e,n)):X</span>d(n,r,t)}function Xd(e,r,t){let n={};return e.modelOrType&amp;&amp;!e.isRawAction()&amp;&amp;(n.$composites=!0,n.$scalars=!0),r<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;em(n,r,e),</span>rm(n,t,e),n}<span class="fstat-no" title="function not covered" >function em(e,r,t){for(let[n,i]of Object.entries(r)){if(Se(i))continue;let o=t.nestSelection(n);if(eo(i,o),i===!1||i===void 0){e[n]=!1;continue}let s=t.findField(n);if(s&amp;&amp;s.kind!=="object"&amp;&amp;t.throwValidationError({kind:"IncludeOnScalar",selectionPath:t.getSelectionPath().concat(n),outputType:t.getOutputTypeDescription()}),s){e[n]=Et(i===!0?{}:i,o);continue}if(i===!0){e[n]=!0;continue}e[n]=Et(i,o)}}f</span>unction rm(e,r,t){let n=t.getComputedFields(),i={...t.getGlobalOmit(),...r},o=wa(i,n);for(let[s,a]of Object.entries(o))<span class="branch-0 cbranch-no" title="branch not covered" >{if(Se(a))continue;eo(a,t.nestSelection(s));let l=t.findField(s);n?.[s]&amp;&amp;!l||(e[s]=!a)}}<span class="fstat-no" title="function not covered" ></span>function tm(e,r){let t={},n=r.getComputedFields(),i=Ea(e,n);for(let[o,s]of Object.entries(i)){if(Se(s))continue;let a=r.nestSelection(o);eo(s,a);let l=r.findField(o);if(!(n?.[o]&amp;&amp;!l)){if(s===!1||s===void 0||Se(s)){t[o]=!1;continue}if(s===!0){l?.kind==="object"?t[o]=Et({},a):t[o]=!0;continue}t[o]=Et(s,a)}}return t}f</span>unction Sa(e,r){if(e===null)return null;if(typeof e=="string"||typeof e=="number"||typeof e=="boolean")return e;if(typeof e=="bigint")<span class="branch-0 cbranch-no" title="branch not covered" >return{$type:"BigInt",value:String(e)};i</span>f(vr(e)){if(mn(e))return{$type:"DateTime",value:e.toISOString()}<span class="branch-0 cbranch-no" title="branch not covered" >;r.throwValidationError({kind:"InvalidArgumentValue",selectionPath:r.getSelectionPath(),argumentPath:r.getArgumentPath(),argument:{name:r.getArgumentName(),typeNames:["Date"]},underlyingError:"Provided Date object is invalid"})}i</span>f(xa(e))<span class="branch-0 cbranch-no" title="branch not covered" >return{$type:"Param",value:e.name};i</span>f(kr(e))<span class="branch-0 cbranch-no" title="branch not covered" >return{$type:"FieldRef",value:{_ref:e.name,_container:e.modelName}};i</span>f(Array.isArray(e))<span class="branch-0 cbranch-no" title="branch not covered" >return nm(e,r);i</span>f(ArrayBuffer.isView(e))<span class="branch-0 cbranch-no" title="branch not covered" >{let{buffer:t,byteOffset:n,byteLength:i}=e;return{$type:"Bytes",value:Buffer.from(t,n,i).toString("base64")}}i</span>f(im(e))<span class="branch-0 cbranch-no" title="branch not covered" >return e.values;i</span>f(Sr(e))<span class="branch-0 cbranch-no" title="branch not covered" >return{$type:"Decimal",value:e.toFixed()};i</span>f(e instanceof Me)<span class="branch-0 cbranch-no" title="branch not covered" >{if(e!==On.instances[e._getName()])throw new Error("Invalid ObjectEnumValue");return{$type:"Enum",value:e._getName()}}i</span>f(om(e))<span class="branch-0 cbranch-no" title="branch not covered" >return e.toJSON();i</span>f(typeof e=="object")return Ra(e,r)<span class="branch-0 cbranch-no" title="branch not covered" >;r.throwValidationError({kind:"InvalidArgumentValue",selectionPath:r.getSelectionPath(),argumentPath:r.getArgumentPath(),argument:{name:r.getArgumentName(),typeNames:[]},underlyingError:`We could not serialize ${Object.prototype.toString.call(e)} value. Serialize the object to JSON or implement a ".toJSON()" method on it`})}f</span>unction Ra(e,r){if(e.$type)<span class="branch-0 cbranch-no" title="branch not covered" >return{$type:"Raw",value:e};l</span>et t={};for(let n in e){let i=e[n],o=r.nestArgument(n);Se(i)||(i!==void 0?t[n]=Sa(i,o)<span class="branch-0 cbranch-no" title="branch not covered" >:r.isPreviewFeatureOn("strictUndefinedChecks")&amp;&amp;r.throwValidationError({kind:"InvalidArgumentValue",argumentPath:o.getArgumentPath(),selectionPath:r.getSelectionPath(),argument:{name:r.getArgumentName(),typeNames:[]},underlyingError:Ta}))</span>}return t}<span class="fstat-no" title="function not covered" >function nm(e,r){let t=[];for(let n=0;n&lt;e.length;n++){let i=r.nestArgument(String(n)),o=e[n];if(o===void 0||Se(o)){let s=o===void 0?"undefined":"Prisma.skip";r.throwValidationError({kind:"InvalidArgumentValue",selectionPath:i.getSelectionPath(),argumentPath:i.getArgumentPath(),argument:{name:`${r.getArgumentName()}[${n}]`,typeNames:[]},underlyingError:`Can not use \`${s}\` value within array. Use \`null\` or filter out \`${s}\` values`})}t.push(Sa(o,i))}return t}f</span>unction im(e){return typeof e=="object"&amp;&amp;e!==null&amp;&amp;e.__prismaRawParameters__===!0}function om(e){return typeof e=="object"&amp;&amp;e!==null&amp;&amp;typeof e.toJSON=="function"}<span class="fstat-no" title="function not covered" >function eo(e,r){e===void 0&amp;&amp;r.isPreviewFeatureOn("strictUndefinedChecks")&amp;&amp;r.throwValidationError({kind:"InvalidSelectionValue",selectionPath:r.getSelectionPath(),underlyingError:Ta})}v</span>ar Xi=class e{constructor(r){this.params=r;this.params.modelName&amp;&amp;(this.modelOrType=this.params.runtimeDataModel.models[this.params.modelName]<span class="branch-0 cbranch-no" title="branch not covered" >??this.params.runtimeDataModel.types[this.params.modelName])</span>}modelOrType;<span class="fstat-no" title="function not covered" >throwValidationError(r){Nn({errors:[r],originalMethod:this.params.originalMethod,args:this.params.rootArgs??{},callsite:this.params.callsite,errorFormat:this.params.errorFormat,clientVersion:this.params.clientVersion,globalOmit:this.params.globalOmit})}<span class="fstat-no" title="function not covered" >g</span>etSelectionPath(){return this.params.selectionPath}<span class="fstat-no" title="function not covered" >g</span>etArgumentPath(){return this.params.argumentPath}<span class="fstat-no" title="function not covered" >g</span>etArgumentName(){return this.params.argumentPath[this.params.argumentPath.length-1]}<span class="fstat-no" title="function not covered" >g</span>etOutputTypeDescription(){if(!(!this.params.modelName||!this.modelOrType))return{name:this.params.modelName,fields:this.modelOrType.fields.map(r=&gt;({name:r.name,typeName:"boolean",isRelation:r.kind==="object"}))}}i</span>sRawAction(){return["executeRaw","queryRaw","runCommandRaw","findRaw","aggregateRaw"].includes(this.params.action)}<span class="fstat-no" title="function not covered" >isPreviewFeatureOn(r){return this.params.previewFeatures.includes(r)}g</span>etComputedFields(){if(this.params.modelName)return this.params.extensions.getAllComputedFields(this.params.modelName)}<span class="fstat-no" title="function not covered" >findField(r){return this.modelOrType?.fields.find(t=&gt;t.name===r)}<span class="fstat-no" title="function not covered" >n</span>estSelection(r){let t=this.findField(r),n=t?.kind==="object"?t.type:void 0;return new e({...this.params,modelName:n,selectionPath:this.params.selectionPath.concat(r)})}g</span>etGlobalOmit(){return this.params.modelName&amp;&amp;this.shouldApplyGlobalOmit()?this.params.globalOmit<span class="branch-0 cbranch-no" title="branch not covered" >?.[We(this.params.modelName)]?</span>?{}<span class="branch-0 cbranch-no" title="branch not covered" >:{}}</span>shouldApplyGlobalOmit(){switch(this.params.action){<span class="branch-0 cbranch-no" title="branch not covered" >case"findFirst":<span class="branch-0 cbranch-no" title="branch not covered" >c</span>ase"findFirstOrThrow":<span class="branch-0 cbranch-no" title="branch not covered" >c</span>ase"findUniqueOrThrow":<span class="branch-0 cbranch-no" title="branch not covered" >c</span>ase"findMany":<span class="branch-0 cbranch-no" title="branch not covered" >c</span>ase"upsert":c</span>ase"findUnique":case"createManyAndReturn":case"create":case"update":case"updateManyAndReturn":case"delete":return!0;<span class="branch-0 cbranch-no" title="branch not covered" >case"executeRaw":<span class="branch-0 cbranch-no" title="branch not covered" >c</span>ase"aggregateRaw":<span class="branch-0 cbranch-no" title="branch not covered" >c</span>ase"runCommandRaw":<span class="branch-0 cbranch-no" title="branch not covered" >c</span>ase"findRaw":<span class="branch-0 cbranch-no" title="branch not covered" >c</span>ase"createMany":<span class="branch-0 cbranch-no" title="branch not covered" >c</span>ase"deleteMany":<span class="branch-0 cbranch-no" title="branch not covered" >c</span>ase"groupBy":<span class="branch-0 cbranch-no" title="branch not covered" >c</span>ase"updateMany":<span class="branch-0 cbranch-no" title="branch not covered" >c</span>ase"count":<span class="branch-0 cbranch-no" title="branch not covered" >c</span>ase"aggregate":<span class="branch-0 cbranch-no" title="branch not covered" >c</span>ase"queryRaw":return!1;<span class="branch-0 cbranch-no" title="branch not covered" >d</span>efault:ar(this.params.action,"Unknown action")}}</span>nestArgument(r){return new e({...this.params,argumentPath:this.params.argumentPath.concat(r)})}};<span class="fstat-no" title="function not covered" >function Aa(e){if(!e._hasPreviewFlag("metrics"))throw new Z("`metrics` preview feature must be enabled in order to access metrics API",{clientVersion:e._clientVersion})}v</span>ar Lr=class{_client;constructor(r){this._client=r}<span class="fstat-no" title="function not covered" >prometheus(r){return Aa(this._client),this._client._engine.metrics({format:"prometheus",...r})}<span class="fstat-no" title="function not covered" >j</span>son(r){return Aa(this._client),this._client._engine.metrics({format:"json",...r})}}</span>;function Ca(e,r){let t=lt(()=&gt;sm(r));Object.defineProperty(e,"dmmf",{get:<span class="fstat-no" title="function not covered" >()=&gt;t.get()}</span>)}<span class="fstat-no" title="function not covered" >function sm(e){return{datamodel:{models:ro(e.models),enums:ro(e.enums),types:ro(e.types)}}}<span class="fstat-no" title="function not covered" >f</span>unction ro(e){return Object.entries(e).map(([r,t])=&gt;({name:r,...t}))}v</span>ar to=new WeakMap,qn="$$PrismaTypedSql",wt=class{<span class="fstat-no" title="function not covered" >constructor(r,t){to.set(this,{sql:r,values:t}),Object.defineProperty(this,qn,{value:qn})}<span class="fstat-no" title="function not covered" >g</span>et sql(){return to.get(this).sql}<span class="fstat-no" title="function not covered" >g</span>et values(){return to.get(this).values}}</span>;<span class="fstat-no" title="function not covered" >function Ia(e){return(...r)=&gt;new wt(e,r)}<span class="fstat-no" title="function not covered" >f</span>unction Vn(e){return e!=null&amp;&amp;e[qn]===qn}v</span>ar cu=O(Ti());var pu=require("node:async_hooks"),du=require("node:events"),mu=O(require("node:fs")),ri=O(require("node:path"));var ie=class e{constructor(r,t){if(r.length-1!==t.length)<span class="branch-0 cbranch-no" title="branch not covered" >throw r.length===0?new TypeError("Expected at least 1 string"):new TypeError(`Expected ${r.length} strings to have ${r.length-1} values`);l</span>et n=t.reduce((s,a)=&gt;s+(a instanceof e?a.values.length:1),0);this.values=new Array(n),this.strings=new Array(n+1),this.strings[0]=r[0];let i=0,o=0;for(;i&lt;t.length;)<span class="branch-0 cbranch-no" title="branch not covered" >{let s=t[i++],a=r[i];if(s instanceof e){this.strings[o]+=s.strings[0];let l=0;for(;l&lt;s.values.length;)this.values[o++]=s.values[l++],this.strings[o]=s.strings[l];this.strings[o]+=a}else this.values[o++]=s,this.strings[o]=a}}<span class="fstat-no" title="function not covered" ></span>get sql(){let r=this.strings.length,t=1,n=this.strings[0];for(;t&lt;r;)n+=`?${this.strings[t++]}`;return n}<span class="fstat-no" title="function not covered" >g</span>et statement(){let r=this.strings.length,t=1,n=this.strings[0];for(;t&lt;r;)n+=`:${t}${this.strings[t++]}`;return n}<span class="fstat-no" title="function not covered" >g</span>et text(){let r=this.strings.length,t=1,n=this.strings[0];for(;t&lt;r;)n+=`$${t}${this.strings[t++]}`;return n}<span class="fstat-no" title="function not covered" >i</span>nspect(){return{sql:this.sql,statement:this.statement,text:this.text,values:this.values}}}</span>;<span class="fstat-no" title="function not covered" >function Da(e,r=",",t="",n=""){if(e.length===0)throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");return new ie([t,...Array(e.length-1).fill(r),n],e)}f</span>unction no(e){return new ie([e],[])}var Oa=no("");<span class="fstat-no" title="function not covered" >function io(e,...r){return new ie(e,r)}f</span>unction xt(e){return{getKeys(){return Object.keys(e)},<span class="fstat-no" title="function not covered" >getPropertyValue(r){return e[r]}}</span>}function re(e,r){return{getKeys(){return[e]},<span class="fstat-no" title="function not covered" >getPropertyValue(){return r()}}</span>}function lr(e){let r=new we;return{getKeys(){return e.getKeys()},getPropertyValue(t){return r.getOrCreate(t,()=&gt;e.getPropertyValue(t))},<span class="fstat-no" title="function not covered" >getPropertyDescriptor(t){return e.getPropertyDescriptor?.(t)}}</span>}var jn={enumerable:!0,configurable:!0,writable:!0};function Bn(e){let r=new Set(e);return{getPrototypeOf:<span class="fstat-no" title="function not covered" >()=&gt;Object.prototype,</span>getOwnPropertyDescriptor:<span class="fstat-no" title="function not covered" >()=&gt;jn,</span>has:<span class="fstat-no" title="function not covered" >(t,n)=&gt;r.has(n),</span>set:<span class="fstat-no" title="function not covered" >(t,n,i)=&gt;r.add(n)&amp;&amp;Reflect.set(t,n,i),</span>ownKeys:<span class="fstat-no" title="function not covered" >()=&gt;[...r]}</span>}var ka=Symbol.for("nodejs.util.inspect.custom");function he(e,r){let t=am(r),n=new Set,i=new Proxy(e,{get(o,s){if(n.has(s))<span class="branch-0 cbranch-no" title="branch not covered" >return o[s];l</span>et a=t.get(s);return a?a.getPropertyValue(s)<span class="branch-0 cbranch-no" title="branch not covered" >:o[s]}</span>,<span class="fstat-no" title="function not covered" >has(o,s){if(n.has(s))return!0;let a=t.get(s);return a?a.has?.(s)??!0:Reflect.has(o,s)},<span class="fstat-no" title="function not covered" ></span>ownKeys(o){let s=_a(Reflect.ownKeys(o),t),a=_a(Array.from(t.keys()),t);return[...new Set([...s,...a,...n])]},</span>set(o,s,a){return t.get(s)<span class="branch-0 cbranch-no" title="branch not covered" >?.getPropertyDescriptor?.(s)?.writable=</span>==!1<span class="branch-0 cbranch-no" title="branch not covered" >?!1:</span>(n.add(s),Reflect.set(o,s,a))},<span class="fstat-no" title="function not covered" >getOwnPropertyDescriptor(o,s){let a=Reflect.getOwnPropertyDescriptor(o,s);if(a&amp;&amp;!a.configurable)return a;let l=t.get(s);return l?l.getPropertyDescriptor?{...jn,...l?.getPropertyDescriptor(s)}:jn:a},<span class="fstat-no" title="function not covered" ></span>defineProperty(o,s,a){return n.add(s),Reflect.defineProperty(o,s,a)},</span>getPrototypeOf:<span class="fstat-no" title="function not covered" >()=&gt;Object.prototype}</span>);return i[ka]=<span class="fstat-no" title="function not covered" >function(){let o={...this};return delete o[ka],o},</span>i}function am(e){let r=new Map;for(let t of e){let n=t.getKeys();for(let i of n)r.set(i,t)}return r}<span class="fstat-no" title="function not covered" >function _a(e,r){return e.filter(t=&gt;r.get(t)?.has?.(t)??!0)}<span class="fstat-no" title="function not covered" >f</span>unction Fr(e){return{getKeys(){return e},has(){return!1},getPropertyValue(){}}}<span class="fstat-no" title="function not covered" >f</span>unction Mr(e,r){return{batch:e,transaction:r?.kind==="batch"?{isolationLevel:r.options.isolationLevel}:void 0}}<span class="fstat-no" title="function not covered" >f</span>unction Na(e){if(e===void 0)return"";let r=_r(e);return new Ar(0,{colors:Cn}).write(r).toString()}v</span>ar lm="P2037";<span class="fstat-no" title="function not covered" >function $r({error:e,user_facing_error:r},t,n){return r.error_code?new z(um(r,n),{code:r.error_code,clientVersion:t,meta:r.meta,batchRequestIdx:r.batch_request_idx}):new V(e,{clientVersion:t,batchRequestIdx:r.batch_request_idx})}<span class="fstat-no" title="function not covered" >f</span>unction um(e,r){let t=e.message;return(r==="postgresql"||r==="postgres"||r==="mysql")&amp;&amp;e.error_code===lm&amp;&amp;(t+=`</span>
Prisma Accelerate has built-in connection pooling to prevent such errors: https://pris.ly/client/error-accelerate`),t}var vt="&lt;unknown&gt;";<span class="fstat-no" title="function not covered" >function La(e){var r=e.split(`</span>
`);return r.reduce(function(t,n){var i=dm(n)||fm(n)||ym(n)||xm(n)||Em(n);return i&amp;&amp;t.push(i),t},[])}var cm=/^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|rsc|&lt;anonymous&gt;|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,pm=/\((\S*)(?::(\d+))(?::(\d+))\)/;<span class="fstat-no" title="function not covered" >function dm(e){var r=cm.exec(e);if(!r)return null;var t=r[2]&amp;&amp;r[2].indexOf("native")===0,n=r[2]&amp;&amp;r[2].indexOf("eval")===0,i=pm.exec(r[2]);return n&amp;&amp;i!=null&amp;&amp;(r[2]=i[1],r[3]=i[2],r[4]=i[3]),{file:t?null:r[2],methodName:r[1]||vt,arguments:t?[r[2]]:[],lineNumber:r[3]?+r[3]:null,column:r[4]?+r[4]:null}}v</span>ar mm=/^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|rsc|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;<span class="fstat-no" title="function not covered" >function fm(e){var r=mm.exec(e);return r?{file:r[2],methodName:r[1]||vt,arguments:[],lineNumber:+r[3],column:r[4]?+r[4]:null}:null}v</span>ar gm=/^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|rsc|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i,hm=/(\S+) line (\d+)(?: &gt; eval line \d+)* &gt; eval/i;<span class="fstat-no" title="function not covered" >function ym(e){var r=gm.exec(e);if(!r)return null;var t=r[3]&amp;&amp;r[3].indexOf(" &gt; eval")&gt;-1,n=hm.exec(r[3]);return t&amp;&amp;n!=null&amp;&amp;(r[3]=n[1],r[4]=n[2],r[5]=null),{file:r[3],methodName:r[1]||vt,arguments:r[2]?r[2].split(","):[],lineNumber:r[4]?+r[4]:null,column:r[5]?+r[5]:null}}v</span>ar bm=/^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;<span class="fstat-no" title="function not covered" >function Em(e){var r=bm.exec(e);return r?{file:r[3],methodName:r[1]||vt,arguments:[],lineNumber:+r[4],column:r[5]?+r[5]:null}:null}v</span>ar wm=/^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;<span class="fstat-no" title="function not covered" >function xm(e){var r=wm.exec(e);return r?{file:r[2],methodName:r[1]||vt,arguments:[],lineNumber:+r[3],column:r[4]?+r[4]:null}:null}v</span>ar oo=class{<span class="fstat-no" title="function not covered" >getLocation(){return null}}</span>,so=class{_error;constructor(){this._error=new Error}<span class="fstat-no" title="function not covered" >getLocation(){let r=this._error.stack;if(!r)return null;let n=La(r).find(i=&gt;{if(!i.file)return!1;let o=Li(i.file);return o!=="&lt;anonymous&gt;"&amp;&amp;!o.includes("@prisma")&amp;&amp;!o.includes("/packages/client/src/runtime/")&amp;&amp;!o.endsWith("/runtime/binary.js")&amp;&amp;!o.endsWith("/runtime/library.js")&amp;&amp;!o.endsWith("/runtime/edge.js")&amp;&amp;!o.endsWith("/runtime/edge-esm.js")&amp;&amp;!o.startsWith("internal/")&amp;&amp;!i.methodName.includes("new ")&amp;&amp;!i.methodName.includes("getCallSite")&amp;&amp;!i.methodName.includes("Proxy.")&amp;&amp;i.methodName.split(".").length&lt;4});return!n||!n.file?null:{fileName:n.file,lineNumber:n.lineNumber,columnNumber:n.column}}}</span>;function Ze(e){return e==="minimal"<span class="branch-0 cbranch-no" title="branch not covered" >?typeof $EnabledCallSite=="function"&amp;&amp;e!=="minimal"?new $EnabledCallSite:new oo:</span>new so}var Fa={_avg:!0,_count:!0,_sum:!0,_min:!0,_max:!0};<span class="fstat-no" title="function not covered" >function qr(e={}){let r=Pm(e);return Object.entries(r).reduce((n,[i,o])=&gt;(Fa[i]!==void 0?n.select[i]={select:o}:n[i]=o,n),{select:{}})}<span class="fstat-no" title="function not covered" >f</span>unction Pm(e={}){return typeof e._count=="boolean"?{...e,_count:{_all:e._count}}:e}<span class="fstat-no" title="function not covered" >f</span>unction Un(e={}){return r=&gt;(typeof e._count=="boolean"&amp;&amp;(r._count=r._count._all),r)}<span class="fstat-no" title="function not covered" >f</span>unction Ma(e,r){let t=Un(e);return r({action:"aggregate",unpacker:t,argsMapper:qr})(e)}<span class="fstat-no" title="function not covered" >f</span>unction Tm(e={}){let{select:r,...t}=e;return typeof r=="object"?qr({...t,_count:r}):qr({...t,_count:{_all:!0}})}<span class="fstat-no" title="function not covered" >f</span>unction Sm(e={}){return typeof e.select=="object"?r=&gt;Un(e)(r)._count:r=&gt;Un(e)(r)._count._all}<span class="fstat-no" title="function not covered" >f</span>unction $a(e,r){return r({action:"count",unpacker:Sm(e),argsMapper:Tm})(e)}<span class="fstat-no" title="function not covered" >f</span>unction Rm(e={}){let r=qr(e);if(Array.isArray(r.by))for(let t of r.by)typeof t=="string"&amp;&amp;(r.select[t]=!0);else typeof r.by=="string"&amp;&amp;(r.select[r.by]=!0);return r}<span class="fstat-no" title="function not covered" >f</span>unction Am(e={}){return r=&gt;(typeof e?._count=="boolean"&amp;&amp;r.forEach(t=&gt;{t._count=t._count._all}),r)}<span class="fstat-no" title="function not covered" >f</span>unction qa(e,r){return r({action:"groupBy",unpacker:Am(e),argsMapper:Rm})(e)}<span class="fstat-no" title="function not covered" >f</span>unction Va(e,r,t){if(r==="aggregate")return n=&gt;Ma(n,t);if(r==="count")return n=&gt;$a(n,t);if(r==="groupBy")return n=&gt;qa(n,t)}<span class="fstat-no" title="function not covered" >f</span>unction ja(e,r){let t=r.fields.filter(i=&gt;!i.relationName),n=_s(t,"name");return new Proxy({},{get(i,o){if(o in i||typeof o=="symbol")return i[o];let s=n[o];if(s)return new mt(e,o,s.type,s.isList,s.kind==="enum")},...Bn(Object.keys(n))})}v</span>ar Ba=e=&gt;Array.isArray(e)?e<span class="branch-0 cbranch-no" title="branch not covered" >:e.split("."),</span>ao=(e,r)=&gt;Ba(r).reduce((t,n)=&gt;t&amp;&amp;t[n],e),Ua=<span class="fstat-no" title="function not covered" >(e,r,t)=&gt;Ba(r).reduceRight((n,i,o,s)=&gt;Object.assign({},ao(e,s.slice(0,o)),{[i]:n}),t);</span>function Cm(e,r){return e===void 0<span class="branch-0 cbranch-no" title="branch not covered" >||r===void 0?</span>[]<span class="branch-0 cbranch-no" title="branch not covered" >:[...r,"select",e]}</span>function Im(e,r,t){return r===void 0?e<span class="branch-0 cbranch-no" title="branch not covered" >??{}<span class="branch-0 cbranch-no" title="branch not covered" >:</span>Ua(r,t,e||!0)}</span>function lo(e,r,t,n,i,o){let a=e._runtimeDataModel.models[r].fields.reduce((l,u)=&gt;({...l,[u.name]:u}),{});return l=&gt;{let u=Ze(e._errorFormat),c=Cm(n,i),p=Im(l,o,c),d=t({dataPath:c,callsite:u})(p),f=Dm(e,r);return new Proxy(d,{get(h,g){if(!f.includes(g))return h[g]<span class="branch-0 cbranch-no" title="branch not covered" >;let T=[a[g].type,t,g],S=[c,p];return lo(e,...T,...S)},</span>...Bn([...f,...Object.getOwnPropertyNames(d)])})}}function Dm(e,r){return e._runtimeDataModel.models[r].fields.filter(t=&gt;t.kind==="object").map(t=&gt;t.name)}var Om=["findUnique","findUniqueOrThrow","findFirst","findFirstOrThrow","create","update","upsert","delete"],km=["aggregate","count","groupBy"];function uo(e,r){let t=e._extensions.getAllModelExtensions(r)??{},n=[_m(e,r),Lm(e,r),xt(t),re("name",()=&gt;r),re("$name",()=&gt;r),re("$parent",()=&gt;e._appliedParent)];return he({},n)}function _m(e,r){let t=Te(r),n=Object.keys(Rr).concat("count");return{getKeys(){return n},getPropertyValue(i){let o=i,s=a=&gt;l=&gt;{let u=Ze(e._errorFormat);return e._createPrismaPromise(c=&gt;{let p={args:l,dataPath:[],action:o,model:r,clientMethod:`${t}.${i}`,jsModelName:t,transaction:c,callsite:u};return e._request({...p,...a})},{action:o,args:l,model:r})};return Om.includes(o)?lo(e,r,s)<span class="branch-0 cbranch-no" title="branch not covered" >:Nm(i)?Va(e,i,s):s({})}</span>}}<span class="fstat-no" title="function not covered" >function Nm(e){return km.includes(e)}f</span>unction Lm(e,r){return lr(re("fields",()=&gt;{let t=e._runtimeDataModel.models[r];return ja(r,t)}))}function Ga(e){return e.replace(/^./,r=&gt;r.toUpperCase())}var co=Symbol();function Pt(e){let r=[Fm(e),Mm(e),re(co,()=&gt;e),re("$parent",()=&gt;e._appliedParent)],t=e._extensions.getAllClientExtensions();return t<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;r.push(xt(t)),</span>he(e,r)}function Fm(e){let r=Object.getPrototypeOf(e._originalClient),t=[...new Set(Object.getOwnPropertyNames(r))];return{getKeys(){return t},<span class="fstat-no" title="function not covered" >getPropertyValue(n){return e[n]}}</span>}function Mm(e){let r=Object.keys(e._runtimeDataModel.models),t=r.map(Te),n=[...new Set(r.concat(t))];return lr({getKeys(){return n},getPropertyValue(i){let o=Ga(i);if(e._runtimeDataModel.models[o]!==void 0)return uo(e,o)<span class="branch-0 cbranch-no" title="branch not covered" >;if(e._runtimeDataModel.models[i]!==void 0)return uo(e,i)},<span class="fstat-no" title="function not covered" ></span>getPropertyDescriptor(i){if(!t.includes(i))return{enumerable:!1}}}</span>)}<span class="fstat-no" title="function not covered" >function Qa(e){return e[co]?e[co]:e}<span class="fstat-no" title="function not covered" >f</span>unction Wa(e){if(typeof e=="function")return e(this);if(e.client?.__AccelerateEngine){let t=e.client.__AccelerateEngine;this._originalClient._engine=new t(this._originalClient._accelerateEngineConfig)}let r=Object.create(this._originalClient,{_extensions:{value:this._extensions.append(e)},_appliedParent:{value:this,configurable:!0},$on:{value:void 0}});return Pt(r)}<span class="fstat-no" title="function not covered" >f</span>unction Ja({result:e,modelName:r,select:t,omit:n,extensions:i}){let o=i.getAllComputedFields(r);if(!o)return e;let s=[],a=[];for(let l of Object.values(o)){if(n){if(n[l.name])continue;let u=l.needs.filter(c=&gt;n[c]);u.length&gt;0&amp;&amp;a.push(Fr(u))}else if(t){if(!t[l.name])continue;let u=l.needs.filter(c=&gt;!t[c]);u.length&gt;0&amp;&amp;a.push(Fr(u))}$m(e,l.needs)&amp;&amp;s.push(qm(l,he(e,s)))}return s.length&gt;0||a.length&gt;0?he(e,[...s,...a]):e}<span class="fstat-no" title="function not covered" >f</span>unction $m(e,r){return r.every(t=&gt;Vi(e,t))}<span class="fstat-no" title="function not covered" >f</span>unction qm(e,r){return lr(re(e.name,()=&gt;e.compute(r)))}<span class="fstat-no" title="function not covered" >f</span>unction Gn({visitor:e,result:r,args:t,runtimeDataModel:n,modelName:i}){if(Array.isArray(r)){for(let s=0;s&lt;r.length;s++)r[s]=Gn({result:r[s],args:t,modelName:i,runtimeDataModel:n,visitor:e});return r}let o=e(r,i,t)??r;return t.include&amp;&amp;Ka({includeOrSelect:t.include,result:o,parentModelName:i,runtimeDataModel:n,visitor:e}),t.select&amp;&amp;Ka({includeOrSelect:t.select,result:o,parentModelName:i,runtimeDataModel:n,visitor:e}),o}<span class="fstat-no" title="function not covered" >f</span>unction Ka({includeOrSelect:e,result:r,parentModelName:t,runtimeDataModel:n,visitor:i}){for(let[o,s]of Object.entries(e)){if(!s||r[o]==null||Se(s))continue;let l=n.models[t].fields.find(c=&gt;c.name===o);if(!l||l.kind!=="object"||!l.relationName)continue;let u=typeof s=="object"?s:{};r[o]=Gn({visitor:i,result:r[o],args:u,modelName:l.type,runtimeDataModel:n})}}f</span>unction Ha({result:e,modelName:r,args:t,extensions:n,runtimeDataModel:i,globalOmit:o}){return n.isEmpty()<span class="branch-0 cbranch-no" title="branch not covered" >||e==null<span class="branch-0 cbranch-no" title="branch not covered" >|</span>|typeof e!="object"<span class="branch-0 cbranch-no" title="branch not covered" >|</span>|!i.models[r]?</span>e<span class="branch-0 cbranch-no" title="branch not covered" >:Gn({result:e,args:t??{},modelName:r,runtimeDataModel:i,visitor:<span class="fstat-no" title="function not covered" >(a,l,u)=&gt;{let c=Te(l);return Ja({result:a,modelName:c,select:u.select,omit:u.select?void 0:{...o?.[c],...u.omit},extensions:n})}}</span>)}</span>var Vm=["$connect","$disconnect","$on","$transaction","$extends"],Ya=Vm;<span class="fstat-no" title="function not covered" >function za(e){if(e instanceof ie)return jm(e);if(Vn(e))return Bm(e);if(Array.isArray(e)){let t=[e[0]];for(let n=1;n&lt;e.length;n++)t[n]=Tt(e[n]);return t}let r={};for(let t in e)r[t]=Tt(e[t]);return r}<span class="fstat-no" title="function not covered" >f</span>unction jm(e){return new ie(e.strings,e.values)}<span class="fstat-no" title="function not covered" >f</span>unction Bm(e){return new wt(e.sql,e.values)}<span class="fstat-no" title="function not covered" >f</span>unction Tt(e){if(typeof e!="object"||e==null||e instanceof Me||kr(e))return e;if(Sr(e))return new Fe(e.toFixed());if(vr(e))return new Date(+e);if(ArrayBuffer.isView(e))return e.slice(0);if(Array.isArray(e)){let r=e.length,t;for(t=Array(r);r--;)t[r]=Tt(e[r]);return t}if(typeof e=="object"){let r={};for(let t in e)t==="__proto__"?Object.defineProperty(r,t,{value:Tt(e[t]),configurable:!0,enumerable:!0,writable:!0}):r[t]=Tt(e[t]);return r}ar(e,"Unknown value")}<span class="fstat-no" title="function not covered" >f</span>unction Xa(e,r,t,n=0){return e._createPrismaPromise(i=&gt;{let o=r.customDataProxyFetch;return"transaction"in r&amp;&amp;i!==void 0&amp;&amp;(r.transaction?.kind==="batch"&amp;&amp;r.transaction.lock.then(),r.transaction=i),n===t.length?e._executeRequest(r):t[n]({model:r.model,operation:r.model?r.action:r.clientMethod,args:za(r.args??{}),__internalParams:r,query:(s,a=r)=&gt;{let l=a.customDataProxyFetch;return a.customDataProxyFetch=nl(o,l),a.args=s,Xa(e,a,t,n+1)}})})}f</span>unction el(e,r){let{jsModelName:t,action:n,clientMethod:i}=r,o=t?n<span class="branch-0 cbranch-no" title="branch not covered" >:i;</span>if(e._extensions.isEmpty())return e._executeRequest(r)<span class="branch-0 cbranch-no" title="branch not covered" >;let s=e._extensions.getAllQueryCallbacks(t??"$none",</span>o);return Xa(e,r,s)}function rl(e){return r=&gt;{let t={requests:r},n=r[0].extensions.getAllBatchQueryCallbacks();return n.length?tl(t,n,0,e):e(t)}}<span class="fstat-no" title="function not covered" >function tl(e,r,t,n){if(t===r.length)return n(e);let i=e.customDataProxyFetch,o=e.requests[0].transaction;return r[t]({args:{queries:e.requests.map(s=&gt;({model:s.modelName,operation:s.action,args:s.args})),transaction:o?{isolationLevel:o.kind==="batch"?o.isolationLevel:void 0}:void 0},__internalParams:e,query(s,a=e){let l=a.customDataProxyFetch;return a.customDataProxyFetch=nl(i,l),tl(a,r,t+1,n)}})}v</span>ar Za=<span class="fstat-no" title="function not covered" >e=&gt;e;<span class="fstat-no" title="function not covered" ></span>function nl(e=Za,r=Za){return t=&gt;e(r(t))}v</span>ar il=N("prisma:client"),ol={Vercel:"vercel","Netlify CI":"netlify"};function sl({postinstall:e,ciName:r,clientVersion:t,generator:n}){if(il("checkPlatformCaching:postinstall",e),il("checkPlatformCaching:ciName",r),e===!0<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;!(n?.output&amp;&amp;typeof(n.output.fromEnvVar??n.output.value)=="string")<span class="branch-0 cbranch-no" title="branch not covered" >&amp;</span>&amp;r<span class="branch-0 cbranch-no" title="branch not covered" >&amp;</span>&amp;r in ol)<span class="branch-0 cbranch-no" title="branch not covered" ></span>{let i=`Prisma has detected that this project was built on ${r}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.</span>
<span class="cstat-no" title="statement not covered" ></span>
Learn how: https://pris.ly/d/${ol[r]}-build`;throw console.error(i),new P(i,t)}}function al(e,r){return e?e.datasources<span class="branch-0 cbranch-no" title="branch not covered" >?e.datasources:</span>e.datasourceUrl<span class="branch-0 cbranch-no" title="branch not covered" >?{[r[0]]:{url:e.datasourceUrl}}:</span>{}<span class="branch-0 cbranch-no" title="branch not covered" >:{}}</span>var dl=O(require("node:fs")),St=O(require("node:path"));<span class="fstat-no" title="function not covered" >function Qn(e){let{runtimeBinaryTarget:r}=e;return`Add "${r}" to \`binaryTargets\` in the "schema.prisma" file and run \`prisma generate\` after saving it:</span>
<span class="cstat-no" title="statement not covered" ></span>
${Um(e)}`}<span class="fstat-no" title="function not covered" >function Um(e){let{generator:r,generatorBinaryTargets:t,runtimeBinaryTarget:n}=e,i={fromEnvVar:null,value:n},o=[...t,i];return ki({...r,binaryTargets:o})}<span class="fstat-no" title="function not covered" >f</span>unction Xe(e){let{runtimeBinaryTarget:r}=e;return`Prisma Client could not locate the Query Engine for runtime "${r}".`}<span class="fstat-no" title="function not covered" >f</span>unction er(e){let{searchedLocations:r}=e;return`The following locations have been searched:</span>
<span class="cstat-no" title="statement not covered" >${[...new Set(r)].map(i=&gt;`  ${i}`).join(`</span>
`)}`}<span class="fstat-no" title="function not covered" >function ll(e){let{runtimeBinaryTarget:r}=e;return`${Xe(e)}</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >This happened because \`binaryTargets\` have been pinned, but the actual deployment also required "${r}".</span>
<span class="cstat-no" title="statement not covered" >${Qn(e)}</span>
<span class="cstat-no" title="statement not covered" ></span>
${er(e)}`}<span class="fstat-no" title="function not covered" >function Wn(e){return`We would appreciate if you could take the time to share some information with us.</span>
Please help us by answering a few questions: https://pris.ly/${e}`}<span class="fstat-no" title="function not covered" >function Jn(e){let{errorStack:r}=e;return r?.match(/\/\.next|\/next@|\/next\//)?`</span>
<span class="cstat-no" title="statement not covered" ></span>
We detected that you are using Next.js, learn how to fix this: https://pris.ly/d/engine-not-found-nextjs.`:""}<span class="fstat-no" title="function not covered" >function ul(e){let{queryEngineName:r}=e;return`${Xe(e)}${Jn(e)}</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >This is likely caused by a bundler that has not copied "${r}" next to the resulting bundle.</span>
<span class="cstat-no" title="statement not covered" >Ensure that "${r}" has been copied next to the bundle or in "${e.expectedLocation}".</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >${Wn("engine-not-found-bundler-investigation")}</span>
<span class="cstat-no" title="statement not covered" ></span>
${er(e)}`}<span class="fstat-no" title="function not covered" >function cl(e){let{runtimeBinaryTarget:r,generatorBinaryTargets:t}=e,n=t.find(i=&gt;i.native);return`${Xe(e)}</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >This happened because Prisma Client was generated for "${n?.value??"unknown"}", but the actual deployment required "${r}".</span>
<span class="cstat-no" title="statement not covered" >${Qn(e)}</span>
<span class="cstat-no" title="statement not covered" ></span>
${er(e)}`}<span class="fstat-no" title="function not covered" >function pl(e){let{queryEngineName:r}=e;return`${Xe(e)}${Jn(e)}</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >This is likely caused by tooling that has not copied "${r}" to the deployment folder.</span>
<span class="cstat-no" title="statement not covered" >Ensure that you ran \`prisma generate\` and that "${r}" has been copied to "${e.expectedLocation}".</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >${Wn("engine-not-found-tooling-investigation")}</span>
<span class="cstat-no" title="statement not covered" ></span>
${er(e)}`}var Gm=N("prisma:client:engines:resolveEnginePath"),Qm=<span class="fstat-no" title="function not covered" >()=&gt;new RegExp("runtime[\\\\/]library\\.m?js$");</span>async function ml(e,r){let t={binary:process.env.PRISMA_QUERY_ENGINE_BINARY,library:process.env.PRISMA_QUERY_ENGINE_LIBRARY}[e]??r.prismaPath;if(t!==void 0)<span class="branch-0 cbranch-no" title="branch not covered" >return t;l</span>et{enginePath:n,searchedLocations:i}=await Wm(e,r);if(Gm("enginePath",n),n!==void 0&amp;&amp;e==="binary"<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;Ri(n),</span>n!==void 0)return r.prismaPath=n<span class="branch-0 cbranch-no" title="branch not covered" >;let o=await ir(),s=r.generator?.binaryTargets<span class="branch-0 cbranch-no" title="branch not covered" >?</span>?[],</span>a=s.some(d=&gt;d.native),l=!s.some(d=&gt;d.value===o),u=__filename.match(Qm())===null,c={searchedLocations:i,generatorBinaryTargets:s,generator:r.generator,runtimeBinaryTarget:o,queryEngineName:fl(e,o),expectedLocation:St.default.relative(process.cwd(),r.dirname),errorStack:new Error().stack},p;throw a<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;l<span class="branch-0 cbranch-no" title="branch not covered" >?</span>p=cl(c)<span class="branch-0 cbranch-no" title="branch not covered" >:</span>l?p=ll(c):u?p=ul(c):p=pl(c),</span>new P(p,r.clientVersion)}async function Wm(e,r){let t=await ir(),n=[],i=[r.dirname,St.default.resolve(__dirname,".."),r.generator?.output?.value<span class="branch-0 cbranch-no" title="branch not covered" >??__dirname,</span>St.default.resolve(__dirname,"../../../.prisma/client"),"/tmp/prisma-engines",r.cwd];__filename.includes("resolveEnginePath")<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;i.push(ms());</span>for(let o of i){let s=fl(e,t),a=St.default.join(o,s);if(n.push(o),dl.default.existsSync(a))return{enginePath:a,searchedLocations:n}<span class="branch-0 cbranch-no" title="branch not covered" >}return{enginePath:void 0,searchedLocations:n}}f</span>unction fl(e,r){return e==="library"?Gt(r,"fs")<span class="branch-0 cbranch-no" title="branch not covered" >:`query-engine-${r}${r==="windows"?".exe":""}`}<span class="fstat-no" title="function not covered" ></span>function gl(e){return e?e.replace(/".*"/g,'"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g,r=&gt;`${r[0]}5`):""}<span class="fstat-no" title="function not covered" >f</span>unction hl(e){return e.split(`</span>
<span class="cstat-no" title="statement not covered" >`).map(r=&gt;r.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/,"").replace(/\+\d+\s*ms$/,"")).join(`</span>
`)}var yl=O(Os());<span class="fstat-no" title="function not covered" >function bl({title:e,user:r="prisma",repo:t="prisma",template:n="bug_report.yml",body:i}){return(0,yl.default)({user:r,repo:t,template:n,title:e,body:i})}<span class="fstat-no" title="function not covered" >f</span>unction El({version:e,binaryTarget:r,title:t,description:n,engineVersion:i,database:o,query:s}){let a=Bo(6e3-(s?.length??0)),l=hl(wr(a)),u=n?`# Description</span>
<span class="cstat-no" title="statement not covered" >\`\`\`</span>
<span class="cstat-no" title="statement not covered" >${n}</span>
<span class="cstat-no" title="statement not covered" >\`\`\``:"",c=wr(`Hi Prisma Team! My Prisma Client just crashed. This is the report:</span>
<span class="cstat-no" title="statement not covered" >## Versions</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >| Name            | Version            |</span>
<span class="cstat-no" title="statement not covered" >|-----------------|--------------------|</span>
<span class="cstat-no" title="statement not covered" >| Node            | ${process.version?.padEnd(19)}| </span>
<span class="cstat-no" title="statement not covered" >| OS              | ${r?.padEnd(19)}|</span>
<span class="cstat-no" title="statement not covered" >| Prisma Client   | ${e?.padEnd(19)}|</span>
<span class="cstat-no" title="statement not covered" >| Query Engine    | ${i?.padEnd(19)}|</span>
<span class="cstat-no" title="statement not covered" >| Database        | ${o?.padEnd(19)}|</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >${u}</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >## Logs</span>
<span class="cstat-no" title="statement not covered" >\`\`\`</span>
<span class="cstat-no" title="statement not covered" >${l}</span>
<span class="cstat-no" title="statement not covered" >\`\`\`</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >## Client Snippet</span>
<span class="cstat-no" title="statement not covered" >\`\`\`ts</span>
<span class="cstat-no" title="statement not covered" >// PLEASE FILL YOUR CODE SNIPPET HERE</span>
<span class="cstat-no" title="statement not covered" >\`\`\`</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >## Schema</span>
<span class="cstat-no" title="statement not covered" >\`\`\`prisma</span>
<span class="cstat-no" title="statement not covered" >// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE</span>
<span class="cstat-no" title="statement not covered" >\`\`\`</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >## Prisma Engine Query</span>
<span class="cstat-no" title="statement not covered" >\`\`\`</span>
<span class="cstat-no" title="statement not covered" >${s?gl(s):""}</span>
<span class="cstat-no" title="statement not covered" >\`\`\`</span>
<span class="cstat-no" title="statement not covered" >`),p=bl({title:t,body:c});return`${t}</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >${Y(p)}</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >If you want the Prisma team to look into it, please open the link above \u{1F64F}</span>
<span class="cstat-no" title="statement not covered" >To increase the chance of success, please post your schema and a snippet of</span>
<span class="cstat-no" title="statement not covered" >how you used Prisma Client in the issue. </span>
`}<span class="fstat-no" title="function not covered" >function wl(e,r){throw new Error(r)}f</span>unction Jm(e){return e!==null&amp;&amp;typeof e=="object"&amp;&amp;typeof e.$type=="string"}function Km(e,r){let t={};for(let n of Object.keys(e))t[n]=r(e[n],n);return t}function Vr(e){return e===null?e:Array.isArray(e)<span class="branch-0 cbranch-no" title="branch not covered" >?e.map(Vr):</span>typeof e=="object"?Jm(e)?Hm(e):e.constructor!==null&amp;&amp;e.constructor.name!=="Object"<span class="branch-0 cbranch-no" title="branch not covered" >?e:</span>Km(e,Vr):e}function Hm({$type:e,value:r}){switch(e){<span class="branch-0 cbranch-no" title="branch not covered" >case"BigInt":return BigInt(r);<span class="branch-0 cbranch-no" title="branch not covered" >c</span>ase"Bytes":{let{buffer:t,byteOffset:n,byteLength:i}=Buffer.from(r,"base64");return new Uint8Array(t,n,i)}c</span>ase"DateTime":return new Date(r);<span class="branch-0 cbranch-no" title="branch not covered" >case"Decimal":return new Le(r);<span class="branch-0 cbranch-no" title="branch not covered" >c</span>ase"Json":return JSON.parse(r);<span class="branch-0 cbranch-no" title="branch not covered" >d</span>efault:wl(r,"Unknown tagged value")}}</span>var xl="6.16.2";var zm=<span class="fstat-no" title="function not covered" >()=&gt;globalThis.process?.release?.name==="node",</span>Zm=<span class="fstat-no" title="function not covered" >()=&gt;!!globalThis.Bun||!!globalThis.process?.versions?.bun,</span>Xm=<span class="fstat-no" title="function not covered" >()=&gt;!!globalThis.Deno,</span>ef=<span class="fstat-no" title="function not covered" >()=&gt;typeof globalThis.Netlify=="object",</span>rf=<span class="fstat-no" title="function not covered" >()=&gt;typeof globalThis.EdgeRuntime=="object",</span>tf=<span class="fstat-no" title="function not covered" >()=&gt;globalThis.navigator?.userAgent==="Cloudflare-Workers";<span class="fstat-no" title="function not covered" ></span>function nf(){return[[ef,"netlify"],[rf,"edge-light"],[tf,"workerd"],[Xm,"deno"],[Zm,"bun"],[zm,"node"]].flatMap(t=&gt;t[0]()?[t[1]]:[]).at(0)??""}v</span>ar of={node:"Node.js",workerd:"Cloudflare Workers",deno:"Deno and Deno Deploy",netlify:"Netlify Edge Functions","edge-light":"Edge Runtime (Vercel Edge Functions, Vercel Edge Middleware, Next.js (Pages Router) Edge API Routes, Next.js (App Router) Edge Route Handlers or Next.js Middleware)"};<span class="fstat-no" title="function not covered" >function Kn(){let e=nf();return{id:e,prettyName:of[e]||e,isEdge:["workerd","deno","netlify","edge-light"].includes(e)}}f</span>unction jr({inlineDatasources:e,overrideDatasources:r,env:t,clientVersion:n}){let i,o=Object.keys(e)[0],s=e[o]?.url,a=r[o]<span class="branch-0 cbranch-no" title="branch not covered" >?.url;</span>if(o===void 0<span class="branch-0 cbranch-no" title="branch not covered" >?i=void 0:</span>a<span class="branch-0 cbranch-no" title="branch not covered" >?i=a:</span>s?.value<span class="branch-0 cbranch-no" title="branch not covered" >?i=s.value:</span>s?.fromEnvVar&amp;&amp;(i=t[s.fromEnvVar]),s?.fromEnvVar!==void 0&amp;&amp;i===void 0)<span class="branch-0 cbranch-no" title="branch not covered" >throw new P(`error: Environment variable not found: ${s.fromEnvVar}.`,n);i</span>f(i===void 0)<span class="branch-0 cbranch-no" title="branch not covered" >throw new P("error: Missing URL environment variable, value, or override.",n);r</span>eturn i}var Hn=class extends Error<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{clientVersion;cause;constructor(r,t){super(r),this.clientVersion=t.clientVersion,this.cause=t.cause}get[Symbol.toStringTag](){return this.name}};v</span></span>ar oe=class extends Hn<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{isRetryable;constructor(r,t){super(r,t),this.isRetryable=t.isRetryable??!0}};<span class="fstat-no" title="function not covered" >f</span></span>unction R(e,r){return{...e,isRetryable:r}}v</span>ar ur=class extends oe<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{name="InvalidDatasourceError";code="P6001";constructor(r,t){super(r,R(t,!1))}};x</span></span>(ur,"InvalidDatasourceError");<span class="fstat-no" title="function not covered" >function vl(e){let r={clientVersion:e.clientVersion},t=Object.keys(e.inlineDatasources)[0],n=jr({inlineDatasources:e.inlineDatasources,overrideDatasources:e.overrideDatasources,clientVersion:e.clientVersion,env:{...e.env,...typeof process&lt;"u"?process.env:{}}}),i;try{i=new URL(n)}catch{throw new ur(`Error validating datasource \`${t}\`: the URL must start with the protocol \`prisma://\``,r)}let{protocol:o,searchParams:s}=i;if(o!=="prisma:"&amp;&amp;o!==sn)throw new ur(`Error validating datasource \`${t}\`: the URL must start with the protocol \`prisma://\` or \`prisma+postgres://\``,r);let a=s.get("api_key");if(a===null||a.length&lt;1)throw new ur(`Error validating datasource \`${t}\`: the URL must contain a valid API key`,r);let l=Ii(i)?"http:":"https:";process.env.TEST_CLIENT_ENGINE_REMOTE_EXECUTOR&amp;&amp;i.searchParams.has("use_http")&amp;&amp;(l="http:");let u=new URL(i.href.replace(o,l));return{apiKey:a,url:u}}v</span>ar Pl=O(on()),Yn=class<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{apiKey;tracingHelper;logLevel;logQueries;engineHash;constructor({apiKey:r,tracingHelper:t,logLevel:n,logQueries:i,engineHash:o}){this.apiKey=r,this.tracingHelper=t,this.logLevel=n,this.logQueries=i,this.engineHash=o}build({traceparent:r,transactionId:t}={}){let n={Accept:"application/json",Authorization:`Bearer ${this.apiKey}`,"Content-Type":"application/json","Prisma-Engine-Hash":this.engineHash,"Prisma-Engine-Version":Pl.enginesVersion};this.tracingHelper.isEnabled()&amp;&amp;(n.traceparent=r??this.tracingHelper.getTraceParent()),t&amp;&amp;(n["X-Transaction-Id"]=t);let i=this.#e();return i.length&gt;0&amp;&amp;(n["X-Capture-Telemetry"]=i.join(", ")),n}#e(){let r=[];return this.tracingHelper.isEnabled()&amp;&amp;r.push("tracing"),this.logLevel&amp;&amp;r.push(this.logLevel),this.logQueries&amp;&amp;r.push("query"),r}};<span class="fstat-no" title="function not covered" ></span></span>function sf(e){return e[0]*1e3+e[1]/1e6}<span class="fstat-no" title="function not covered" >f</span>unction po(e){return new Date(sf(e))}v</span>ar Br=class extends oe<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{name="ForcedRetryError";code="P5001";constructor(r){super("This request must be retried",R(r,!0))}};x</span></span>(Br,"ForcedRetryError");var cr=class extends oe<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{name="NotImplementedYetError";code="P5004";constructor(r,t){super(r,R(t,!1))}};x</span></span>(cr,"NotImplementedYetError");var $=class extends oe<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{response;constructor(r,t){super(r,t),this.response=t.response;let n=this.response.headers.get("prisma-request-id");if(n){let i=`(The request id was: ${n})`;this.message=this.message+" "+i}}};v</span></span>ar pr=class extends $<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{name="SchemaMissingError";code="P5005";constructor(r){super("Schema needs to be uploaded",R(r,!0))}};x</span></span>(pr,"SchemaMissingError");var mo="This request could not be understood by the server",Rt=class extends $<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{name="BadRequestError";code="P5000";constructor(r,t,n){super(t||mo,R(r,!1)),n&amp;&amp;(this.code=n)}};</span></span>x(Rt,"BadRequestError");var At=class extends $<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{name="HealthcheckTimeoutError";code="P5013";logs;constructor(r,t){super("Engine not started: healthcheck timeout",R(r,!0)),this.logs=t}};x</span></span>(At,"HealthcheckTimeoutError");var Ct=class extends $<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{name="EngineStartupError";code="P5014";logs;constructor(r,t,n){super(t,R(r,!0)),this.logs=n}};x</span></span>(Ct,"EngineStartupError");var It=class extends $<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{name="EngineVersionNotSupportedError";code="P5012";constructor(r){super("Engine version is not supported",R(r,!1))}};x</span></span>(It,"EngineVersionNotSupportedError");var fo="Request timed out",Dt=class extends $<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{name="GatewayTimeoutError";code="P5009";constructor(r,t=fo){super(t,R(r,!1))}};</span></span>x(Dt,"GatewayTimeoutError");var af="Interactive transaction error",Ot=class extends $<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{name="InteractiveTransactionError";code="P5015";constructor(r,t=af){super(t,R(r,!1))}};</span></span>x(Ot,"InteractiveTransactionError");var lf="Request parameters are invalid",kt=class extends $<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{name="InvalidRequestError";code="P5011";constructor(r,t=lf){super(t,R(r,!1))}};</span></span>x(kt,"InvalidRequestError");var go="Requested resource does not exist",_t=class extends $<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{name="NotFoundError";code="P5003";constructor(r,t=go){super(t,R(r,!1))}};</span></span>x(_t,"NotFoundError");var ho="Unknown server error",Ur=class extends $<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{name="ServerError";code="P5006";logs;constructor(r,t,n){super(t||ho,R(r,!0)),this.logs=n}};</span></span>x(Ur,"ServerError");var yo="Unauthorized, check your connection string",Nt=class extends $<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{name="UnauthorizedError";code="P5007";constructor(r,t=yo){super(t,R(r,!1))}};</span></span>x(Nt,"UnauthorizedError");var bo="Usage exceeded, retry again later",Lt=class extends $<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{name="UsageExceededError";code="P5008";constructor(r,t=bo){super(t,R(r,!0))}};</span></span>x(Lt,"UsageExceededError");<span class="fstat-no" title="function not covered" >async function uf(e){let r;try{r=await e.text()}catch{return{type:"EmptyError"}}try{let t=JSON.parse(r);if(typeof t=="string")switch(t){case"InternalDataProxyError":return{type:"DataProxyError",body:t};default:return{type:"UnknownTextError",body:t}}if(typeof t=="object"&amp;&amp;t!==null){if("is_panic"in t&amp;&amp;"message"in t&amp;&amp;"error_code"in t)return{type:"QueryEngineError",body:t};if("EngineNotStarted"in t||"InteractiveTransactionMisrouted"in t||"InvalidRequestError"in t){let n=Object.values(t)[0].reason;return typeof n=="string"&amp;&amp;!["SchemaMissing","EngineVersionNotSupported"].includes(n)?{type:"UnknownJsonError",body:t}:{type:"DataProxyError",body:t}}}return{type:"UnknownJsonError",body:t}}catch{return r===""?{type:"EmptyError"}:{type:"UnknownTextError",body:r}}}<span class="fstat-no" title="function not covered" >a</span>sync function Ft(e,r){if(e.ok)return;let t={clientVersion:r,response:e},n=await uf(e);if(n.type==="QueryEngineError")throw new z(n.body.message,{code:n.body.error_code,clientVersion:r});if(n.type==="DataProxyError"){if(n.body==="InternalDataProxyError")throw new Ur(t,"Internal Data Proxy error");if("EngineNotStarted"in n.body){if(n.body.EngineNotStarted.reason==="SchemaMissing")return new pr(t);if(n.body.EngineNotStarted.reason==="EngineVersionNotSupported")throw new It(t);if("EngineStartupError"in n.body.EngineNotStarted.reason){let{msg:i,logs:o}=n.body.EngineNotStarted.reason.EngineStartupError;throw new Ct(t,i,o)}if("KnownEngineStartupError"in n.body.EngineNotStarted.reason){let{msg:i,error_code:o}=n.body.EngineNotStarted.reason.KnownEngineStartupError;throw new P(i,r,o)}if("HealthcheckTimeout"in n.body.EngineNotStarted.reason){let{logs:i}=n.body.EngineNotStarted.reason.HealthcheckTimeout;throw new At(t,i)}}if("InteractiveTransactionMisrouted"in n.body){let i={IDParseError:"Could not parse interactive transaction ID",NoQueryEngineFoundError:"Could not find Query Engine for the specified host and transaction ID",TransactionStartError:"Could not start interactive transaction"};throw new Ot(t,i[n.body.InteractiveTransactionMisrouted.reason])}if("InvalidRequestError"in n.body)throw new kt(t,n.body.InvalidRequestError.reason)}if(e.status===401||e.status===403)throw new Nt(t,Gr(yo,n));if(e.status===404)return new _t(t,Gr(go,n));if(e.status===429)throw new Lt(t,Gr(bo,n));if(e.status===504)throw new Dt(t,Gr(fo,n));if(e.status&gt;=500)throw new Ur(t,Gr(ho,n));if(e.status&gt;=400)throw new Rt(t,Gr(mo,n))}<span class="fstat-no" title="function not covered" >f</span>unction Gr(e,r){return r.type==="EmptyError"?e:`${e}: ${JSON.stringify(r)}`}<span class="fstat-no" title="function not covered" >f</span>unction Tl(e){let r=Math.pow(2,e)*50,t=Math.ceil(Math.random()*r)-Math.ceil(r/2),n=r+t;return new Promise(i=&gt;setTimeout(()=&gt;i(n),n))}v</span>ar $e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";<span class="fstat-no" title="function not covered" >function Sl(e){let r=new TextEncoder().encode(e),t="",n=r.byteLength,i=n%3,o=n-i,s,a,l,u,c;for(let p=0;p&lt;o;p=p+3)c=r[p]&lt;&lt;16|r[p+1]&lt;&lt;8|r[p+2],s=(c&amp;16515072)&gt;&gt;18,a=(c&amp;258048)&gt;&gt;12,l=(c&amp;4032)&gt;&gt;6,u=c&amp;63,t+=$e[s]+$e[a]+$e[l]+$e[u];return i==1?(c=r[o],s=(c&amp;252)&gt;&gt;2,a=(c&amp;3)&lt;&lt;4,t+=$e[s]+$e[a]+"=="):i==2&amp;&amp;(c=r[o]&lt;&lt;8|r[o+1],s=(c&amp;64512)&gt;&gt;10,a=(c&amp;1008)&gt;&gt;4,l=(c&amp;15)&lt;&lt;2,t+=$e[s]+$e[a]+$e[l]+"="),t}<span class="fstat-no" title="function not covered" >f</span>unction Rl(e){if(!!e.generator?.previewFeatures.some(t=&gt;t.toLowerCase().includes("metrics")))throw new P("The `metrics` preview feature is not yet available with Accelerate.\nPlease remove `metrics` from the `previewFeatures` in your schema.\n\nMore information about Accelerate: https://pris.ly/d/accelerate",e.clientVersion)}v</span>ar Al={"@prisma/debug":"workspace:*","@prisma/engines-version":"6.16.0-7.1c57fdcd7e44b29b9313256c76699e91c3ac3c43","@prisma/fetch-engine":"workspace:*","@prisma/get-platform":"workspace:*"};var Mt=class extends oe<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{name="RequestError";code="P5010";constructor(r,t){super(`Cannot fetch data from service:</span></span>
${r}`,R(t,!0))}};x(Mt,"RequestError");<span class="fstat-no" title="function not covered" >async function dr(e,r,t=n=&gt;n){let{clientVersion:n,...i}=r,o=t(fetch);try{return await o(e,i)}catch(s){let a=s.message??"Unknown error";throw new Mt(a,{clientVersion:n,cause:s})}}v</span>ar pf=/^[1-9][0-9]*\.[0-9]+\.[0-9]+$/,Cl=N("prisma:client:dataproxyEngine");<span class="fstat-no" title="function not covered" >async function df(e,r){let t=Al["@prisma/engines-version"],n=r.clientVersion??"unknown";if(process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION||globalThis.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION)return process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION||globalThis.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;if(e.includes("accelerate")&amp;&amp;n!=="0.0.0"&amp;&amp;n!=="in-memory")return n;let[i,o]=n?.split("-")??[];if(o===void 0&amp;&amp;pf.test(i))return i;if(o!==void 0||n==="0.0.0"||n==="in-memory"){let[s]=t.split("-")??[],[a,l,u]=s.split("."),c=mf(`&lt;=${a}.${l}.${u}`),p=await dr(c,{clientVersion:n});if(!p.ok)throw new Error(`Failed to fetch stable Prisma version, unpkg.com status ${p.status} ${p.statusText}, response body: ${await p.text()||"&lt;empty body&gt;"}`);let d=await p.text();Cl("length of body fetched from unpkg.com",d.length);let f;try{f=JSON.parse(d)}catch(h){throw console.error("JSON.parse error: body fetched from unpkg.com: ",d),h}return f.version}throw new cr("Only `major.minor.patch` versions are supported by Accelerate.",{clientVersion:n})}<span class="fstat-no" title="function not covered" >a</span>sync function Il(e,r){let t=await df(e,r);return Cl("version",t),t}<span class="fstat-no" title="function not covered" >f</span>unction mf(e){return encodeURI(`https://unpkg.com/prisma@${e}/package.json`)}v</span>ar Dl=3,$t=N("prisma:client:dataproxyEngine"),qt=class<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{name="DataProxyEngine";inlineSchema;inlineSchemaHash;inlineDatasources;config;logEmitter;env;clientVersion;engineHash;tracingHelper;remoteClientVersion;host;headerBuilder;startPromise;protocol;constructor(r){Rl(r),this.config=r,this.env=r.env,this.inlineSchema=Sl(r.inlineSchema),this.inlineDatasources=r.inlineDatasources,this.inlineSchemaHash=r.inlineSchemaHash,this.clientVersion=r.clientVersion,this.engineHash=r.engineVersion,this.logEmitter=r.logEmitter,this.tracingHelper=r.tracingHelper}apiKey(){return this.headerBuilder.apiKey}version(){return this.engineHash}async start(){this.startPromise!==void 0&amp;&amp;await this.startPromise,this.startPromise=(async()=&gt;{let{apiKey:r,url:t}=this.getURLAndAPIKey();this.host=t.host,this.protocol=t.protocol,this.headerBuilder=new Yn({apiKey:r,tracingHelper:this.tracingHelper,logLevel:this.config.logLevel??"error",logQueries:this.config.logQueries,engineHash:this.engineHash}),this.remoteClientVersion=await Il(this.host,this.config),$t("host",this.host),$t("protocol",this.protocol)})(),await this.startPromise}async stop(){}propagateResponseExtensions(r){r?.logs?.length&amp;&amp;r.logs.forEach(t=&gt;{switch(t.level){case"debug":case"trace":$t(t);break;case"error":case"warn":case"info":{this.logEmitter.emit(t.level,{timestamp:po(t.timestamp),message:t.attributes.message??"",target:t.target??"BinaryEngine"});break}case"query":{this.logEmitter.emit("query",{query:t.attributes.query??"",timestamp:po(t.timestamp),duration:t.attributes.duration_ms??0,params:t.attributes.params??"",target:t.target??"BinaryEngine"});break}default:t.level}}),r?.traces?.length&amp;&amp;this.tracingHelper.dispatchEngineSpans(r.traces)}onBeforeExit(){throw new Error('"beforeExit" hook is not applicable to the remote query engine')}async url(r){return await this.start(),`${this.protocol}//${this.host}/${this.remoteClientVersion}/${this.inlineSchemaHash}/${r}`}async uploadSchema(){let r={name:"schemaUpload",internal:!0};return this.tracingHelper.runInChildSpan(r,async()=&gt;{let t=await dr(await this.url("schema"),{method:"PUT",headers:this.headerBuilder.build(),body:this.inlineSchema,clientVersion:this.clientVersion});t.ok||$t("schema response status",t.status);let n=await Ft(t,this.clientVersion);if(n)throw this.logEmitter.emit("warn",{message:`Error while uploading schema: ${n.message}`,timestamp:new Date,target:""}),n;this.logEmitter.emit("info",{message:`Schema (re)uploaded (hash: ${this.inlineSchemaHash})`,timestamp:new Date,target:""})})}request(r,{traceparent:t,interactiveTransaction:n,customDataProxyFetch:i}){return this.requestInternal({body:r,traceparent:t,interactiveTransaction:n,customDataProxyFetch:i})}async requestBatch(r,{traceparent:t,transaction:n,customDataProxyFetch:i}){let o=n?.kind==="itx"?n.options:void 0,s=Mr(r,n);return(await this.requestInternal({body:s,customDataProxyFetch:i,interactiveTransaction:o,traceparent:t})).map(l=&gt;(l.extensions&amp;&amp;this.propagateResponseExtensions(l.extensions),"errors"in l?this.convertProtocolErrorsToClientError(l.errors):l))}requestInternal({body:r,traceparent:t,customDataProxyFetch:n,interactiveTransaction:i}){return this.withRetry({actionGerund:"querying",callback:async({logHttpCall:o})=&gt;{let s=i?`${i.payload.endpoint}/graphql`:await this.url("graphql");o(s);let a=await dr(s,{method:"POST",headers:this.headerBuilder.build({traceparent:t,transactionId:i?.id}),body:JSON.stringify(r),clientVersion:this.clientVersion},n);a.ok||$t("graphql response status",a.status),await this.handleError(await Ft(a,this.clientVersion));let l=await a.json();if(l.extensions&amp;&amp;this.propagateResponseExtensions(l.extensions),"errors"in l)throw this.convertProtocolErrorsToClientError(l.errors);return"batchResult"in l?l.batchResult:l}})}async transaction(r,t,n){let i={start:"starting",commit:"committing",rollback:"rolling back"};return this.withRetry({actionGerund:`${i[r]} transaction`,callback:async({logHttpCall:o})=&gt;{if(r==="start"){let s=JSON.stringify({max_wait:n.maxWait,timeout:n.timeout,isolation_level:n.isolationLevel}),a=await this.url("transaction/start");o(a);let l=await dr(a,{method:"POST",headers:this.headerBuilder.build({traceparent:t.traceparent}),body:s,clientVersion:this.clientVersion});await this.handleError(await Ft(l,this.clientVersion));let u=await l.json(),{extensions:c}=u;c&amp;&amp;this.propagateResponseExtensions(c);let p=u.id,d=u["data-proxy"].endpoint;return{id:p,payload:{endpoint:d}}}else{let s=`${n.payload.endpoint}/${r}`;o(s);let a=await dr(s,{method:"POST",headers:this.headerBuilder.build({traceparent:t.traceparent}),clientVersion:this.clientVersion});await this.handleError(await Ft(a,this.clientVersion));let l=await a.json(),{extensions:u}=l;u&amp;&amp;this.propagateResponseExtensions(u);return}}})}getURLAndAPIKey(){return vl({clientVersion:this.clientVersion,env:this.env,inlineDatasources:this.inlineDatasources,overrideDatasources:this.config.overrideDatasources})}metrics(){throw new cr("Metrics are not yet supported for Accelerate",{clientVersion:this.clientVersion})}async withRetry(r){for(let t=0;;t++){let n=i=&gt;{this.logEmitter.emit("info",{message:`Calling ${i} (n=${t})`,timestamp:new Date,target:""})};try{return await r.callback({logHttpCall:n})}catch(i){if(!(i instanceof oe)||!i.isRetryable)throw i;if(t&gt;=Dl)throw i instanceof Br?i.cause:i;this.logEmitter.emit("warn",{message:`Attempt ${t+1}/${Dl} failed for ${r.actionGerund}: ${i.message??"(unknown)"}`,timestamp:new Date,target:""});let o=await Tl(t);this.logEmitter.emit("warn",{message:`Retrying after ${o}ms`,timestamp:new Date,target:""})}}}async handleError(r){if(r instanceof pr)throw await this.uploadSchema(),new Br({clientVersion:this.clientVersion,cause:r});if(r)throw r}convertProtocolErrorsToClientError(r){return r.length===1?$r(r[0],this.config.clientVersion,this.config.activeProvider):new V(JSON.stringify(r),{clientVersion:this.config.clientVersion})}applyPendingMigrations(){throw new Error("Method not implemented.")}};<span class="fstat-no" title="function not covered" ></span></span>function Ol(e){if(e?.kind==="itx")return e.options.id}v</span>ar wo=O(require("node:os")),kl=O(require("node:path"));var Eo=Symbol("PrismaLibraryEngineCache");function ff(){let e=globalThis;return e[Eo]===void 0&amp;&amp;(e[Eo]={}),e[Eo]}function gf(e){let r=ff();if(r[e]!==void 0)return r[e];let t=kl.default.toNamespacedPath(e),n={exports:{}},i=0;return process.platform!=="win32"<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(i=wo.default.constants.dlopen.RTLD_LAZY|wo.default.constants.dlopen.RTLD_DEEPBIND),</span>process.dlopen(n,t,i),r[e]=n.exports,n.exports}var _l={async loadLibrary(e){let r=await fi(),t=await ml("library",e);try{return e.tracingHelper.runInChildSpan({name:"loadLibrary",internal:!0},()=&gt;gf(t))}<span class="branch-0 cbranch-no" title="branch not covered" >catch(n){let i=Ai({e:n,platformInfo:r,id:t});throw new P(i,e.clientVersion)}}</span>};var xo,Nl={<span class="fstat-no" title="function not covered" >async loadLibrary(e){let{clientVersion:r,adapter:t,engineWasm:n}=e;if(t===void 0)throw new P(`The \`adapter\` option for \`PrismaClient\` is required in this context (${Kn().prettyName})`,r);if(n===void 0)throw new P("WASM engine was unexpectedly `undefined`",r);xo===void 0&amp;&amp;(xo=(async()=&gt;{let o=await n.getRuntime(),s=await n.getQueryEngineWasmModule();if(s==null)throw new P("The loaded wasm module was unexpectedly `undefined` or `null` once loaded",r);let a={"./query_engine_bg.js":o},l=new WebAssembly.Instance(s,a),u=l.exports.__wbindgen_start;return o.__wbg_set_wasm(l.exports),u(),o.QueryEngine})());let i=await xo;return{debugPanic(){return Promise.reject("{}")},dmmf(){return Promise.resolve("{}")},version(){return{commit:"unknown",version:"unknown"}},QueryEngine:i}}}</span>;var hf="P2036",Re=N("prisma:client:libraryEngine");<span class="fstat-no" title="function not covered" >function yf(e){return e.item_type==="query"&amp;&amp;"query"in e}<span class="fstat-no" title="function not covered" >f</span>unction bf(e){return"level"in e?e.level==="error"&amp;&amp;e.message==="PANIC":!1}v</span>ar Ll=[...li,"native"],Ef=0xffffffffffffffffn,vo=1n;function wf(){let e=vo++;return vo&gt;Ef<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(vo=1n),</span>e}var Qr=class{name="LibraryEngine";engine;libraryInstantiationPromise;libraryStartingPromise;libraryStoppingPromise;libraryStarted;executingQueryPromise;config;QueryEngineConstructor;libraryLoader;library;logEmitter;libQueryEnginePath;binaryTarget;datasourceOverrides;datamodel;logQueries;logLevel;lastQuery;loggerRustPanic;tracingHelper;adapterPromise;versionInfo;constructor(r,t){this.libraryLoader=t??_l,r.engineWasm!==void 0<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(this.libraryLoader=t??Nl),</span>this.config=r,this.libraryStarted=!1,this.logQueries=r.logQueries??!1,this.logLevel=r.logLevel??"error",this.logEmitter=r.logEmitter,this.datamodel=r.inlineSchema,this.tracingHelper=r.tracingHelper,r.enableDebugLogs<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(this.logLevel="debug");</span>let n=Object.keys(r.overrideDatasources)[0],i=r.overrideDatasources[n]<span class="branch-0 cbranch-no" title="branch not covered" >?.url;</span>n!==void 0<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;i!==void 0<span class="branch-0 cbranch-no" title="branch not covered" >&amp;</span>&amp;(this.datasourceOverrides={[n]:i}),</span>this.libraryInstantiationPromise=this.instantiateLibrary()}wrapEngine(r){return{applyPendingMigrations:r.applyPendingMigrations<span class="branch-0 cbranch-no" title="branch not covered" >?.bind(</span>r),commitTransaction:this.withRequestId(r.commitTransaction.bind(r)),connect:this.withRequestId(r.connect.bind(r)),disconnect:this.withRequestId(r.disconnect.bind(r)),metrics:r.metrics?.bind(r),query:this.withRequestId(r.query.bind(r)),rollbackTransaction:this.withRequestId(r.rollbackTransaction.bind(r)),sdlSchema:r.sdlSchema?.bind(r),startTransaction:this.withRequestId(r.startTransaction.bind(r)),trace:r.trace.bind(r),free:r.free<span class="branch-0 cbranch-no" title="branch not covered" >?.bind(</span>r)}}withRequestId(r){return async(...t)=&gt;{let n=wf().toString();try{return await r(...t,n)}finally{if(this.tracingHelper.isEnabled())<span class="branch-0 cbranch-no" title="branch not covered" >{let i=await this.engine?.trace(n);if(i){let o=JSON.parse(i);this.tracingHelper.dispatchEngineSpans(o.spans)}}}</span>}}<span class="fstat-no" title="function not covered" >async applyPendingMigrations(){throw new Error("Cannot call this method from this type of engine instance")}<span class="fstat-no" title="function not covered" >a</span>sync transaction(r,t,n){await this.start();let i=await this.adapterPromise,o=JSON.stringify(t),s;if(r==="start"){let l=JSON.stringify({max_wait:n.maxWait,timeout:n.timeout,isolation_level:n.isolationLevel});s=await this.engine?.startTransaction(l,o)}else r==="commit"?s=await this.engine?.commitTransaction(n.id,o):r==="rollback"&amp;&amp;(s=await this.engine?.rollbackTransaction(n.id,o));let a=this.parseEngineResponse(s);if(xf(a)){let l=this.getExternalAdapterError(a,i?.errorRegistry);throw l?l.error:new z(a.message,{code:a.error_code,clientVersion:this.config.clientVersion,meta:a.meta})}else if(typeof a.message=="string")throw new V(a.message,{clientVersion:this.config.clientVersion});return a}a</span>sync instantiateLibrary(){if(Re("internalSetup"),this.libraryInstantiationPromise)<span class="branch-0 cbranch-no" title="branch not covered" >return this.libraryInstantiationPromise;a</span>i(),this.binaryTarget=await this.getCurrentBinaryTarget(),await this.tracingHelper.runInChildSpan("load_engine",()=&gt;this.loadEngine()),this.version()}async getCurrentBinaryTarget(){{if(this.binaryTarget)<span class="branch-0 cbranch-no" title="branch not covered" >return this.binaryTarget;l</span>et r=await this.tracingHelper.runInChildSpan("detect_platform",()=&gt;ir());if(!Ll.includes(r))<span class="branch-0 cbranch-no" title="branch not covered" >throw new P(`Unknown ${ce("PRISMA_QUERY_ENGINE_LIBRARY")} ${ce(W(r))}. Possible binaryTargets: ${qe(Ll.join(", "))} or a path to the query engine library.</span>
You may have to run ${qe("prisma generate")} for your changes to take effect.`,this.config.clientVersion);return r}}parseEngineResponse(r){if(!r)<span class="branch-0 cbranch-no" title="branch not covered" >throw new V("Response from the Engine was empty",{clientVersion:this.config.clientVersion});t</span>ry{return JSON.parse(r)}<span class="branch-0 cbranch-no" title="branch not covered" >catch{throw new V("Unable to JSON.parse response from engine",{clientVersion:this.config.clientVersion})}}</span>async loadEngine(){if(!this.engine){this.QueryEngineConstructor||(this.library=await this.libraryLoader.loadLibrary(this.config),this.QueryEngineConstructor=this.library.QueryEngine);try{let r=new WeakRef(this);this.adapterPromise||(this.adapterPromise=this.config.adapter<span class="branch-0 cbranch-no" title="branch not covered" >?.connect(</span>)<span class="branch-0 cbranch-no" title="branch not covered" >?.then(</span>tn));let t=await this.adapterPromise;t<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;Re("Using driver adapter: %O",t),</span>this.engine=this.wrapEngine(new this.QueryEngineConstructor({datamodel:this.datamodel,env:process.env,logQueries:this.config.logQueries??!1,ignoreEnvVarErrors:!0,datasourceOverrides:this.datasourceOverrides??{},logLevel:this.logLevel,configDir:this.config.cwd,engineProtocol:"json",enableTracing:this.tracingHelper.isEnabled()},n=&gt;{r.deref()?.logger(n)},t))}<span class="branch-0 cbranch-no" title="branch not covered" >catch(r){let t=r,n=this.parseInitError(t.message);throw typeof n=="string"?t:new P(n.message,this.config.clientVersion,n.error_code)}}</span>}<span class="fstat-no" title="function not covered" >logger(r){let t=this.parseEngineResponse(r);t&amp;&amp;(t.level=t?.level.toLowerCase()??"unknown",yf(t)?this.logEmitter.emit("query",{timestamp:new Date,query:t.query,params:t.params,duration:Number(t.duration_ms),target:t.module_path}):bf(t)?this.loggerRustPanic=new ae(Po(this,`${t.message}: ${t.reason} in ${t.file}:${t.line}:${t.column}`),this.config.clientVersion):this.logEmitter.emit(t.level,{timestamp:new Date,message:t.message,target:t.module_path}))}<span class="fstat-no" title="function not covered" >p</span>arseInitError(r){try{return JSON.parse(r)}catch{}return r}<span class="fstat-no" title="function not covered" >p</span>arseRequestError(r){try{return JSON.parse(r)}catch{}return r}<span class="fstat-no" title="function not covered" >o</span>nBeforeExit(){throw new Error('"beforeExit" hook is not applicable to the library engine since Prisma 5.0.0, it is only relevant and implemented for the binary engine. Please add your event listener to the `process` object directly instead.')}a</span>sync start(){if(this.libraryInstantiationPromise<span class="branch-0 cbranch-no" title="branch not covered" >||(this.libraryInstantiationPromise=this.instantiateLibrary()),</span>await this.libraryInstantiationPromise,await this.libraryStoppingPromise,this.libraryStartingPromise)<span class="branch-0 cbranch-no" title="branch not covered" >return Re(`library already starting, this.libraryStarted: ${this.libraryStarted}`),this.libraryStartingPromise;i</span>f(this.libraryStarted)return;let r=async()=&gt;{Re("library starting");try{let t={traceparent:this.tracingHelper.getTraceParent()};await this.engine?.connect(JSON.stringify(t)),this.libraryStarted=!0,this.adapterPromise||(this.adapterPromise=this.config.adapter<span class="branch-0 cbranch-no" title="branch not covered" >?.connect(</span>)<span class="branch-0 cbranch-no" title="branch not covered" >?.then(</span>tn)),await this.adapterPromise,Re("library started")}<span class="branch-0 cbranch-no" title="branch not covered" >catch(t){let n=this.parseInitError(t.message);throw typeof n=="string"?t:new P(n.message,this.config.clientVersion,n.error_code)}f</span>inally{this.libraryStartingPromise=void 0}};return this.libraryStartingPromise=this.tracingHelper.runInChildSpan("connect",r),this.libraryStartingPromise}<span class="fstat-no" title="function not covered" >async stop(){if(await this.libraryInstantiationPromise,await this.libraryStartingPromise,await this.executingQueryPromise,this.libraryStoppingPromise)return Re("library is already stopping"),this.libraryStoppingPromise;if(!this.libraryStarted){await(await this.adapterPromise)?.dispose(),this.adapterPromise=void 0;return}let r=async()=&gt;{await new Promise(n=&gt;setImmediate(n)),Re("library stopping");let t={traceparent:this.tracingHelper.getTraceParent()};await this.engine?.disconnect(JSON.stringify(t)),this.engine?.free&amp;&amp;this.engine.free(),this.engine=void 0,this.libraryStarted=!1,this.libraryStoppingPromise=void 0,this.libraryInstantiationPromise=void 0,await(await this.adapterPromise)?.dispose(),this.adapterPromise=void 0,Re("library stopped")};return this.libraryStoppingPromise=this.tracingHelper.runInChildSpan("disconnect",r),this.libraryStoppingPromise}v</span>ersion(){return this.versionInfo=this.library?.version(),this.versionInfo?.version<span class="branch-0 cbranch-no" title="branch not covered" >??"unknown"}<span class="fstat-no" title="function not covered" ></span>debugPanic(r){return this.library?.debugPanic(r)}a</span>sync request(r,{traceparent:t,interactiveTransaction:n}){Re(`sending request, this.libraryStarted: ${this.libraryStarted}`);let i=JSON.stringify({traceparent:t}),o=JSON.stringify(r);try{await this.start();let s=await this.adapterPromise;this.executingQueryPromise=this.engine?.query(o,i,n<span class="branch-0 cbranch-no" title="branch not covered" >?.id)</span>,this.lastQuery=o;let a=this.parseEngineResponse(await this.executingQueryPromise);if(a.errors)<span class="branch-0 cbranch-no" title="branch not covered" >throw a.errors.length===1?this.buildQueryError(a.errors[0],s?.errorRegistry):new V(JSON.stringify(a.errors),{clientVersion:this.config.clientVersion});i</span>f(this.loggerRustPanic)<span class="branch-0 cbranch-no" title="branch not covered" >throw this.loggerRustPanic;r</span>eturn{data:a}}<span class="branch-0 cbranch-no" title="branch not covered" >catch(s){if(s instanceof P)throw s;if(s.code==="GenericFailure"&amp;&amp;s.message?.startsWith("PANIC:"))throw new ae(Po(this,s.message),this.config.clientVersion);let a=this.parseRequestError(s.message);throw typeof a=="string"?s:new V(`${a.message}</span>
${a.backtrace}`,{clientVersion:this.config.clientVersion})}}<span class="fstat-no" title="function not covered" >async requestBatch(r,{transaction:t,traceparent:n}){Re("requestBatch");let i=Mr(r,t);await this.start();let o=await this.adapterPromise;this.lastQuery=JSON.stringify(i),this.executingQueryPromise=this.engine?.query(this.lastQuery,JSON.stringify({traceparent:n}),Ol(t));let s=await this.executingQueryPromise,a=this.parseEngineResponse(s);if(a.errors)throw a.errors.length===1?this.buildQueryError(a.errors[0],o?.errorRegistry):new V(JSON.stringify(a.errors),{clientVersion:this.config.clientVersion});let{batchResult:l,errors:u}=a;if(Array.isArray(l))return l.map(c=&gt;c.errors&amp;&amp;c.errors.length&gt;0?this.loggerRustPanic??this.buildQueryError(c.errors[0],o?.errorRegistry):{data:c});throw u&amp;&amp;u.length===1?new Error(u[0].error):new Error(JSON.stringify(a))}<span class="fstat-no" title="function not covered" >b</span>uildQueryError(r,t){if(r.user_facing_error.is_panic)return new ae(Po(this,r.user_facing_error.message),this.config.clientVersion);let n=this.getExternalAdapterError(r.user_facing_error,t);return n?n.error:$r(r,this.config.clientVersion,this.config.activeProvider)}<span class="fstat-no" title="function not covered" >g</span>etExternalAdapterError(r,t){if(r.error_code===hf&amp;&amp;t){let n=r.meta?.id;ln(typeof n=="number","Malformed external JS error received from the engine");let i=t.consumeError(n);return ln(i,"External error with reported id was not registered"),i}}<span class="fstat-no" title="function not covered" >a</span>sync metrics(r){await this.start();let t=await this.engine.metrics(JSON.stringify(r));return r.format==="prometheus"?t:this.parseEngineResponse(t)}}</span>;<span class="fstat-no" title="function not covered" >function xf(e){return typeof e=="object"&amp;&amp;e!==null&amp;&amp;e.error_code!==void 0}<span class="fstat-no" title="function not covered" >f</span>unction Po(e,r){return El({binaryTarget:e.binaryTarget,title:r,version:e.config.clientVersion,engineVersion:e.versionInfo?.commit,database:e.config.activeProvider,query:e.lastQuery})}f</span>unction Fl({url:e,adapter:r,copyEngine:t,targetBuildType:n}){let i=[],o=[],s=<span class="fstat-no" title="function not covered" >g=&gt;{i.push({_tag:"warning",value:g})},</span>a=<span class="fstat-no" title="function not covered" >g=&gt;{let I=g.join(`</span>
`);o.push({_tag:"error",value:I})},l=!!e?.startsWith("prisma://"),u=an(e),c=!!r,p=l||u;!c&amp;&amp;t&amp;&amp;p<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;n!=="client"<span class="branch-0 cbranch-no" title="branch not covered" >&amp;</span>&amp;n!=="wasm-compiler-edge"<span class="branch-0 cbranch-no" title="branch not covered" >&amp;</span>&amp;s(["recommend--no-engine","In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)"]);</span>let d=p||!t;c<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(d||n==="edge")<span class="branch-0 cbranch-no" title="branch not covered" >&amp;</span>&amp;(n==="edge"?a(["Prisma Client was configured to use the `adapter` option but it was imported via its `/edge` endpoint.","Please either remove the `/edge` endpoint or remove the `adapter` from the Prisma Client constructor."]):p?a(["You've provided both a driver adapter and an Accelerate database URL. Driver adapters currently cannot connect to Accelerate.","Please provide either a driver adapter with a direct database URL or an Accelerate URL and no driver adapter."]):t||a(["Prisma Client was configured to use the `adapter` option but `prisma generate` was run with `--no-engine`.","Please run `prisma generate` without `--no-engine` to be able to use Prisma Client with the adapter."]));</span>let f={accelerate:d,ppg:u,driverAdapters:c};function h(g){return g.length&gt;0}return h(o)<span class="branch-0 cbranch-no" title="branch not covered" >?{ok:!1,diagnostics:{warnings:i,errors:o},isUsing:f}:</span>{ok:!0,diagnostics:{warnings:i},isUsing:f}}function Ml({copyEngine:e=!0},r){let t;try{t=jr({inlineDatasources:r.inlineDatasources,overrideDatasources:r.overrideDatasources,env:{...r.env,...process.env},clientVersion:r.clientVersion})}<span class="branch-0 cbranch-no" title="branch not covered" >catch{}l</span>et{ok:n,isUsing:i,diagnostics:o}=Fl({url:t,adapter:r.adapter,copyEngine:e,targetBuildType:"library"});for(let p of o.warnings)<span class="branch-0 cbranch-no" title="branch not covered" >at(...p.value);i</span>f(!n)<span class="branch-0 cbranch-no" title="branch not covered" >{let p=o.errors[0];throw new Z(p.value,{clientVersion:r.clientVersion})}l</span>et s=Er(r.generator),a=s==="library",l=s==="binary",u=s==="client",c=(i.accelerate||i.ppg<span class="branch-0 cbranch-no" title="branch not covered" >)&amp;&amp;!i.driverAdapters;</span>return i.accelerate<span class="branch-0 cbranch-no" title="branch not covered" >?new qt(r):</span>(i.driverAdapters,a?new Qr(r)<span class="branch-0 cbranch-no" title="branch not covered" >:(i.accelerate,new Qr(r)))</span>}function $l({generator:e}){return e?.previewFeatures<span class="branch-0 cbranch-no" title="branch not covered" >??[]}</span>var ql=<span class="fstat-no" title="function not covered" >e=&gt;({command:e});</span>var Vl=<span class="fstat-no" title="function not covered" >e=&gt;e.strings.reduce((r,t,n)=&gt;`${r}@P${n}${t}`);<span class="fstat-no" title="function not covered" ></span>function Wr(e){try{return jl(e,"fast")}catch{return jl(e,"slow")}}<span class="fstat-no" title="function not covered" >f</span>unction jl(e,r){return JSON.stringify(e.map(t=&gt;Ul(t,r)))}<span class="fstat-no" title="function not covered" >f</span>unction Ul(e,r){if(Array.isArray(e))return e.map(t=&gt;Ul(t,r));if(typeof e=="bigint")return{prisma__type:"bigint",prisma__value:e.toString()};if(vr(e))return{prisma__type:"date",prisma__value:e.toJSON()};if(Fe.isDecimal(e))return{prisma__type:"decimal",prisma__value:e.toJSON()};if(Buffer.isBuffer(e))return{prisma__type:"bytes",prisma__value:e.toString("base64")};if(vf(e))return{prisma__type:"bytes",prisma__value:Buffer.from(e).toString("base64")};if(ArrayBuffer.isView(e)){let{buffer:t,byteOffset:n,byteLength:i}=e;return{prisma__type:"bytes",prisma__value:Buffer.from(t,n,i).toString("base64")}}return typeof e=="object"&amp;&amp;r==="slow"?Gl(e):e}<span class="fstat-no" title="function not covered" >f</span>unction vf(e){return e instanceof ArrayBuffer||e instanceof SharedArrayBuffer?!0:typeof e=="object"&amp;&amp;e!==null?e[Symbol.toStringTag]==="ArrayBuffer"||e[Symbol.toStringTag]==="SharedArrayBuffer":!1}<span class="fstat-no" title="function not covered" >f</span>unction Gl(e){if(typeof e!="object"||e===null)return e;if(typeof e.toJSON=="function")return e.toJSON();if(Array.isArray(e))return e.map(Bl);let r={};for(let t of Object.keys(e))r[t]=Bl(e[t]);return r}<span class="fstat-no" title="function not covered" >f</span>unction Bl(e){return typeof e=="bigint"?e.toString():Gl(e)}v</span>ar Pf=/^(\s*alter\s)/i,Ql=N("prisma:client");<span class="fstat-no" title="function not covered" >function To(e,r,t,n){if(!(e!=="postgresql"&amp;&amp;e!=="cockroachdb")&amp;&amp;t.length&gt;0&amp;&amp;Pf.exec(r))throw new Error(`Running ALTER using ${n} is not supported</span>
<span class="cstat-no" title="statement not covered" >Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >Example:</span>
<span class="cstat-no" title="statement not covered" >  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >More Information: https://pris.ly/d/execute-raw</span>
`)}var So=<span class="fstat-no" title="function not covered" >({clientMethod:e,activeProvider:r})=&gt;t=&gt;{let n="",i;if(Vn(t))n=t.sql,i={values:Wr(t.values),__prismaRawParameters__:!0};else if(Array.isArray(t)){let[o,...s]=t;n=o,i={values:Wr(s||[]),__prismaRawParameters__:!0}}else switch(r){case"sqlite":case"mysql":{n=t.sql,i={values:Wr(t.values),__prismaRawParameters__:!0};break}case"cockroachdb":case"postgresql":case"postgres":{n=t.text,i={values:Wr(t.values),__prismaRawParameters__:!0};break}case"sqlserver":{n=Vl(t),i={values:Wr(t.values),__prismaRawParameters__:!0};break}default:throw new Error(`The ${r} provider does not support ${e}`)}return i?.values?Ql(`prisma.${e}(${n}, ${i.values})`):Ql(`prisma.${e}(${n})`),{query:n,parameters:i}},</span>Wl={<span class="fstat-no" title="function not covered" >requestArgsToMiddlewareArgs(e){return[e.strings,...e.values]},<span class="fstat-no" title="function not covered" ></span>middlewareArgsToRequestArgs(e){let[r,...t]=e;return new ie(r,t)}}</span>,Jl={<span class="fstat-no" title="function not covered" >requestArgsToMiddlewareArgs(e){return[e]},<span class="fstat-no" title="function not covered" ></span>middlewareArgsToRequestArgs(e){return e[0]}}</span>;function Ro(e){return function(t,n){let i,o=(s=e)=&gt;{try{return s===void 0<span class="branch-0 cbranch-no" title="branch not covered" >||s?.kind==="itx"?</span>i??=Kl(t(s))<span class="branch-0 cbranch-no" title="branch not covered" >:Kl(t(s))}<span class="branch-0 cbranch-no" title="branch not covered" ></span>catch(a){return Promise.reject(a)}}</span>;return{<span class="fstat-no" title="function not covered" >get spec(){return n},</span>then(s,a){return o().then(s,a)},<span class="fstat-no" title="function not covered" >catch(s){return o().catch(s)},<span class="fstat-no" title="function not covered" ></span>finally(s){return o().finally(s)},<span class="fstat-no" title="function not covered" ></span>requestTransaction(s){let a=o(s);return a.requestTransaction?a.requestTransaction(s):a},</span>[Symbol.toStringTag]:"PrismaPromise"}}}function Kl(e){return typeof e.then=="function"?e<span class="branch-0 cbranch-no" title="branch not covered" >:Promise.resolve(e)}</span>var Tf=xi.split(".")[0],Sf={isEnabled(){return!1},getTraceParent(){return"00-10-10-00"},<span class="fstat-no" title="function not covered" >dispatchEngineSpans(){},</span>getActiveContext(){},runInChildSpan(e,r){return r()}},Ao=class{isEnabled(){return this.getGlobalTracingHelper().isEnabled()}getTraceParent(r){return this.getGlobalTracingHelper().getTraceParent(r)}<span class="fstat-no" title="function not covered" >dispatchEngineSpans(r){return this.getGlobalTracingHelper().dispatchEngineSpans(r)}g</span>etActiveContext(){return this.getGlobalTracingHelper().getActiveContext()}runInChildSpan(r,t){return this.getGlobalTracingHelper().runInChildSpan(r,t)}getGlobalTracingHelper(){let r=globalThis[`V${Tf}_PRISMA_INSTRUMENTATION`],t=globalThis.PRISMA_INSTRUMENTATION;return r<span class="branch-0 cbranch-no" title="branch not covered" >?.helper?</span>?t<span class="branch-0 cbranch-no" title="branch not covered" >?.helper?</span>?Sf}};function Hl(){return new Ao}<span class="fstat-no" title="function not covered" >function Yl(e,r=()=&gt;{}){let t,n=new Promise(i=&gt;t=i);return{then(i){return--e===0&amp;&amp;t(r()),i?.(n)}}}<span class="fstat-no" title="function not covered" >f</span>unction zl(e){return typeof e=="string"?e:e.reduce((r,t)=&gt;{let n=typeof t=="string"?t:t.level;return n==="query"?r:r&amp;&amp;(t==="info"||r==="info")?"info":n},void 0)}<span class="fstat-no" title="function not covered" >f</span>unction zn(e){return typeof e.batchRequestIdx=="number"}f</span>unction Zl(e){if(e.action!=="findUnique"&amp;&amp;e.action!=="findUniqueOrThrow")return;let r=[];return e.modelName&amp;&amp;r.push(e.modelName),e.query.arguments&amp;&amp;r.push(Co(e.query.arguments)),r.push(Co(e.query.selection)),r.join("")}function Co(e){return`(${Object.keys(e).sort().map(t=&gt;{let n=e[t];return typeof n=="object"&amp;&amp;n!==null?`(${t} ${Co(n)})`:t}).join(" ")})`}var Rf={aggregate:!1,aggregateRaw:!1,createMany:!0,createManyAndReturn:!0,createOne:!0,deleteMany:!0,deleteOne:!0,executeRaw:!0,findFirst:!1,findFirstOrThrow:!1,findMany:!1,findRaw:!1,findUnique:!1,findUniqueOrThrow:!1,groupBy:!1,queryRaw:!1,runCommandRaw:!0,updateMany:!0,updateManyAndReturn:!0,updateOne:!0,upsertOne:!0};function Io(e){return Rf[e]}var Zn=class{constructor(r){this.options=r;this.batches={}}batches;tickActive=!1;request(r){let t=this.options.batchBy(r);return t?(this.batches[t]||(this.batches[t]=[],this.tickActive||(this.tickActive=!0,process.nextTick(()=&gt;{this.dispatchBatches(),this.tickActive=!1}))),new Promise((n,i)=&gt;{this.batches[t].push({request:r,resolve:n,reject:i})})):this.options.singleLoader(r)}dispatchBatches(){for(let r in this.batches){let t=this.batches[r];delete this.batches[r],t.length===1?this.options.singleLoader(t[0].request).then(n=&gt;{n instanceof Error<span class="branch-0 cbranch-no" title="branch not covered" >?t[0].reject(n):</span>t[0].resolve(n)}).catch(n=&gt;{t[0].reject(n)})<span class="branch-0 cbranch-no" title="branch not covered" >:(t.sort((n,i)=&gt;this.options.batchOrder(n.request,i.request)),this.options.batchLoader(t.map(n=&gt;n.request)).then(n=&gt;{if(n instanceof Error)for(let i=0;i&lt;t.length;i++)t[i].reject(n);else for(let i=0;i&lt;t.length;i++){let o=n[i];o instanceof Error?t[i].reject(o):t[i].resolve(o)}}).catch(n=&gt;{for(let i=0;i&lt;t.length;i++)t[i].reject(n)}))}</span>}<span class="fstat-no" title="function not covered" >get[Symbol.toStringTag](){return"DataLoader"}}</span>;<span class="fstat-no" title="function not covered" >function mr(e,r){if(r===null)return r;switch(e){case"bigint":return BigInt(r);case"bytes":{let{buffer:t,byteOffset:n,byteLength:i}=Buffer.from(r,"base64");return new Uint8Array(t,n,i)}case"decimal":return new Fe(r);case"datetime":case"date":return new Date(r);case"time":return new Date(`1970-01-01T${r}Z`);case"bigint-array":return r.map(t=&gt;mr("bigint",t));case"bytes-array":return r.map(t=&gt;mr("bytes",t));case"decimal-array":return r.map(t=&gt;mr("decimal",t));case"datetime-array":return r.map(t=&gt;mr("datetime",t));case"date-array":return r.map(t=&gt;mr("date",t));case"time-array":return r.map(t=&gt;mr("time",t));default:return r}}<span class="fstat-no" title="function not covered" >f</span>unction Xn(e){let r=[],t=Af(e);for(let n=0;n&lt;e.rows.length;n++){let i=e.rows[n],o={...t};for(let s=0;s&lt;i.length;s++)o[e.columns[s]]=mr(e.types[s],i[s]);r.push(o)}return r}<span class="fstat-no" title="function not covered" >f</span>unction Af(e){let r={};for(let t=0;t&lt;e.columns.length;t++)r[e.columns[t]]=null;return r}v</span>ar Cf=N("prisma:client:request_handler"),ei=class{client;dataloader;logEmitter;constructor(r,t){this.logEmitter=t,this.client=r,this.dataloader=new Zn({batchLoader:rl(async({requests:n,customDataProxyFetch:i})=&gt;{let{transaction:o,otelParentCtx:s}=n[0],a=n.map(p=&gt;p.protocolQuery),l=this.client._tracingHelper.getTraceParent(s),u=n.some(p=&gt;Io(p.protocolQuery.action));return(await this.client._engine.requestBatch(a,{traceparent:l,transaction:If(o),containsWrite:u,customDataProxyFetch:i})).map((p,d)=&gt;{if(p instanceof Error)return p;try{return this.mapQueryEngineResult(n[d],p)}catch(f){return f}})}),singleLoader:async n=&gt;{let i=n.transaction<span class="branch-0 cbranch-no" title="branch not covered" >?.kind=</span>=="itx"<span class="branch-0 cbranch-no" title="branch not covered" >?Xl(n.transaction):</span>void 0,o=await this.client._engine.request(n.protocolQuery,{traceparent:this.client._tracingHelper.getTraceParent(),interactiveTransaction:i,isWrite:Io(n.protocolQuery.action),customDataProxyFetch:n.customDataProxyFetch});return this.mapQueryEngineResult(n,o)},batchBy:n=&gt;n.transaction<span class="branch-0 cbranch-no" title="branch not covered" >?.id<span class="branch-0 cbranch-no" title="branch not covered" >?</span>`transaction-${n.transaction.id}`:</span>Zl(n.protocolQuery),<span class="fstat-no" title="function not covered" >batchOrder(n,i){return n.transaction?.kind==="batch"&amp;&amp;i.transaction?.kind==="batch"?n.transaction.index-i.transaction.index:0}}</span>)}async request(r){try{return await this.dataloader.request(r)}<span class="branch-0 cbranch-no" title="branch not covered" >catch(t){let{clientMethod:n,callsite:i,transaction:o,args:s,modelName:a}=r;this.handleAndLogRequestError({error:t,clientMethod:n,callsite:i,transaction:o,args:s,modelName:a,globalOmit:r.globalOmit})}}</span>mapQueryEngineResult({dataPath:r,unpacker:t},n){let i=n?.data,o=this.unpack(i,r,t);return process.env.PRISMA_CLIENT_GET_TIME<span class="branch-0 cbranch-no" title="branch not covered" >?{data:o}:</span>o}<span class="fstat-no" title="function not covered" >handleAndLogRequestError(r){try{this.handleRequestError(r)}catch(t){throw this.logEmitter&amp;&amp;this.logEmitter.emit("error",{message:t.message,target:r.clientMethod,timestamp:new Date}),t}}<span class="fstat-no" title="function not covered" >h</span>andleRequestError({error:r,clientMethod:t,callsite:n,transaction:i,args:o,modelName:s,globalOmit:a}){if(Cf(r),Df(r,i))throw r;if(r instanceof z&amp;&amp;Of(r)){let u=eu(r.meta);Nn({args:o,errors:[u],callsite:n,errorFormat:this.client._errorFormat,originalMethod:t,clientVersion:this.client._clientVersion,globalOmit:a})}let l=r.message;if(n&amp;&amp;(l=Tn({callsite:n,originalMethod:t,isPanic:r.isPanic,showColors:this.client._errorFormat==="pretty",message:l})),l=this.sanitizeMessage(l),r.code){let u=s?{modelName:s,...r.meta}:r.meta;throw new z(l,{code:r.code,clientVersion:this.client._clientVersion,meta:u,batchRequestIdx:r.batchRequestIdx})}else{if(r.isPanic)throw new ae(l,this.client._clientVersion);if(r instanceof V)throw new V(l,{clientVersion:this.client._clientVersion,batchRequestIdx:r.batchRequestIdx});if(r instanceof P)throw new P(l,this.client._clientVersion);if(r instanceof ae)throw new ae(l,this.client._clientVersion)}throw r.clientVersion=this.client._clientVersion,r}<span class="fstat-no" title="function not covered" >s</span>anitizeMessage(r){return this.client._errorFormat&amp;&amp;this.client._errorFormat!=="pretty"?wr(r):r}u</span>npack(r,t,n){if(!r||(r.data&amp;&amp;(r=r.data),!r))<span class="branch-0 cbranch-no" title="branch not covered" >return r;l</span>et i=Object.keys(r)[0],o=Object.values(r)[0],s=t.filter(u=&gt;u!=="select"&amp;&amp;u!=="include"),a=ao(o,s),l=i==="queryRaw"<span class="branch-0 cbranch-no" title="branch not covered" >?Xn(a):</span>Vr(a);return n<span class="branch-0 cbranch-no" title="branch not covered" >?n(l):</span>l}<span class="fstat-no" title="function not covered" >get[Symbol.toStringTag](){return"RequestHandler"}}</span>;<span class="fstat-no" title="function not covered" >function If(e){if(e){if(e.kind==="batch")return{kind:"batch",options:{isolationLevel:e.isolationLevel}};if(e.kind==="itx")return{kind:"itx",options:Xl(e)};ar(e,"Unknown transaction kind")}}<span class="fstat-no" title="function not covered" >f</span>unction Xl(e){return{id:e.id,payload:e.payload}}<span class="fstat-no" title="function not covered" >f</span>unction Df(e,r){return zn(e)&amp;&amp;r?.kind==="batch"&amp;&amp;e.batchRequestIdx!==r.index}<span class="fstat-no" title="function not covered" >f</span>unction Of(e){return e.code==="P2009"||e.code==="P2012"}<span class="fstat-no" title="function not covered" >f</span>unction eu(e){if(e.kind==="Union")return{kind:"Union",errors:e.errors.map(eu)};if(Array.isArray(e.selectionPath)){let[,...r]=e.selectionPath;return{...e,selectionPath:r}}return e}v</span>ar ru=xl;var su=O(Ki());var _=class extends Error{<span class="fstat-no" title="function not covered" >constructor(r){super(r+`</span>
Read more at https://pris.ly/d/client-constructor`),this.name="PrismaClientConstructorValidationError"}<span class="fstat-no" title="function not covered" >get[Symbol.toStringTag](){return"PrismaClientConstructorValidationError"}}</span>;x(_,"PrismaClientConstructorValidationError");var tu=["datasources","datasourceUrl","errorFormat","adapter","log","transactionOptions","omit","__internal"],nu=["pretty","colorless","minimal"],iu=["info","query","warn","error"],kf={datasources:<span class="fstat-no" title="function not covered" >(e,{datasourceNames:r})=&gt;{if(e){if(typeof e!="object"||Array.isArray(e))throw new _(`Invalid value ${JSON.stringify(e)} for "datasources" provided to PrismaClient constructor`);for(let[t,n]of Object.entries(e)){if(!r.includes(t)){let i=Jr(t,r)||` Available datasources: ${r.join(", ")}`;throw new _(`Unknown datasource ${t} provided to PrismaClient constructor.${i}`)}if(typeof n!="object"||Array.isArray(n))throw new _(`Invalid value ${JSON.stringify(e)} for datasource "${t}" provided to PrismaClient constructor.</span>
<span class="cstat-no" title="statement not covered" >It should have this form: { url: "CONNECTION_STRING" }`);if(n&amp;&amp;typeof n=="object")for(let[i,o]of Object.entries(n)){if(i!=="url")throw new _(`Invalid value ${JSON.stringify(e)} for datasource "${t}" provided to PrismaClient constructor.</span>
<span class="cstat-no" title="statement not covered" >It should have this form: { url: "CONNECTION_STRING" }`);if(typeof o!="string")throw new _(`Invalid value ${JSON.stringify(o)} for datasource "${t}" provided to PrismaClient constructor.</span>
It should have this form: { url: "CONNECTION_STRING" }`)}}}},adapter:<span class="fstat-no" title="function not covered" >(e,r)=&gt;{if(!e&amp;&amp;Er(r.generator)==="client")throw new _('Using engine type "client" requires a driver adapter to be provided to PrismaClient constructor.');if(e!==null){if(e===void 0)throw new _('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');if(Er(r.generator)==="binary")throw new _('Cannot use a driver adapter with the "binary" Query Engine. Please use the "library" Query Engine.')}},</span>datasourceUrl:<span class="fstat-no" title="function not covered" >e=&gt;{if(typeof e&lt;"u"&amp;&amp;typeof e!="string")throw new _(`Invalid value ${JSON.stringify(e)} for "datasourceUrl" provided to PrismaClient constructor.</span>
Expected string or undefined.`)},errorFormat:<span class="fstat-no" title="function not covered" >e=&gt;{if(e){if(typeof e!="string")throw new _(`Invalid value ${JSON.stringify(e)} for "errorFormat" provided to PrismaClient constructor.`);if(!nu.includes(e)){let r=Jr(e,nu);throw new _(`Invalid errorFormat ${e} provided to PrismaClient constructor.${r}`)}}},</span>log:<span class="fstat-no" title="function not covered" >e=&gt;{if(!e)return;if(!Array.isArray(e))throw new _(`Invalid value ${JSON.stringify(e)} for "log" provided to PrismaClient constructor.`);function r(t){if(typeof t=="string"&amp;&amp;!iu.includes(t)){let n=Jr(t,iu);throw new _(`Invalid log level "${t}" provided to PrismaClient constructor.${n}`)}}for(let t of e){r(t);let n={level:r,emit:i=&gt;{let o=["stdout","event"];if(!o.includes(i)){let s=Jr(i,o);throw new _(`Invalid value ${JSON.stringify(i)} for "emit" in logLevel provided to PrismaClient constructor.${s}`)}}};if(t&amp;&amp;typeof t=="object")for(let[i,o]of Object.entries(t))if(n[i])n[i](o);else throw new _(`Invalid property ${i} for "log" provided to PrismaClient constructor`)}},</span>transactionOptions:<span class="fstat-no" title="function not covered" >e=&gt;{if(!e)return;let r=e.maxWait;if(r!=null&amp;&amp;r&lt;=0)throw new _(`Invalid value ${r} for maxWait in "transactionOptions" provided to PrismaClient constructor. maxWait needs to be greater than 0`);let t=e.timeout;if(t!=null&amp;&amp;t&lt;=0)throw new _(`Invalid value ${t} for timeout in "transactionOptions" provided to PrismaClient constructor. timeout needs to be greater than 0`)},</span>omit:<span class="fstat-no" title="function not covered" >(e,r)=&gt;{if(typeof e!="object")throw new _('"omit" option is expected to be an object.');if(e===null)throw new _('"omit" option can not be `null`');let t=[];for(let[n,i]of Object.entries(e)){let o=Nf(n,r.runtimeDataModel);if(!o){t.push({kind:"UnknownModel",modelKey:n});continue}for(let[s,a]of Object.entries(i)){let l=o.fields.find(u=&gt;u.name===s);if(!l){t.push({kind:"UnknownField",modelKey:n,fieldName:s});continue}if(l.relationName){t.push({kind:"RelationInOmit",modelKey:n,fieldName:s});continue}typeof a!="boolean"&amp;&amp;t.push({kind:"InvalidFieldValue",modelKey:n,fieldName:s})}}if(t.length&gt;0)throw new _(Lf(e,t))},</span>__internal:<span class="fstat-no" title="function not covered" >e=&gt;{if(!e)return;let r=["debug","engine","configOverride"];if(typeof e!="object")throw new _(`Invalid value ${JSON.stringify(e)} for "__internal" to PrismaClient constructor`);for(let[t]of Object.entries(e))if(!r.includes(t)){let n=Jr(t,r);throw new _(`Invalid property ${JSON.stringify(t)} for "__internal" provided to PrismaClient constructor.${n}`)}}}</span>;<span class="fstat-no" title="function not covered" >function au(e,r){for(let[t,n]of Object.entries(e)){if(!tu.includes(t)){let i=Jr(t,tu);throw new _(`Unknown property ${t} provided to PrismaClient constructor.${i}`)}kf[t](n,r)}if(e.datasourceUrl&amp;&amp;e.datasources)throw new _('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them')}<span class="fstat-no" title="function not covered" >f</span>unction Jr(e,r){if(r.length===0||typeof e!="string")return"";let t=_f(e,r);return t?` Did you mean "${t}"?`:""}<span class="fstat-no" title="function not covered" >f</span>unction _f(e,r){if(r.length===0)return null;let t=r.map(i=&gt;({value:i,distance:(0,su.default)(e,i)}));t.sort((i,o)=&gt;i.distance&lt;o.distance?-1:1);let n=t[0];return n.distance&lt;3?n.value:null}<span class="fstat-no" title="function not covered" >f</span>unction Nf(e,r){return ou(r.models,e)??ou(r.types,e)}<span class="fstat-no" title="function not covered" >f</span>unction ou(e,r){let t=Object.keys(e).find(n=&gt;We(n)===r);if(t)return e[t]}<span class="fstat-no" title="function not covered" >f</span>unction Lf(e,r){let t=_r(e);for(let o of r)switch(o.kind){case"UnknownModel":t.arguments.getField(o.modelKey)?.markAsError(),t.addErrorMessage(()=&gt;`Unknown model name: ${o.modelKey}.`);break;case"UnknownField":t.arguments.getDeepField([o.modelKey,o.fieldName])?.markAsError(),t.addErrorMessage(()=&gt;`Model "${o.modelKey}" does not have a field named "${o.fieldName}".`);break;case"RelationInOmit":t.arguments.getDeepField([o.modelKey,o.fieldName])?.markAsError(),t.addErrorMessage(()=&gt;'Relations are already excluded by default and can not be specified in "omit".');break;case"InvalidFieldValue":t.arguments.getDeepFieldValue([o.modelKey,o.fieldName])?.markAsError(),t.addErrorMessage(()=&gt;"Omit field option value must be a boolean.");break}let{message:n,args:i}=_n(t,"colorless");return`Error validating "omit" option:</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >${i}</span>
<span class="cstat-no" title="statement not covered" ></span>
${n}`}<span class="fstat-no" title="function not covered" >function lu(e){return e.length===0?Promise.resolve([]):new Promise((r,t)=&gt;{let n=new Array(e.length),i=null,o=!1,s=0,a=()=&gt;{o||(s++,s===e.length&amp;&amp;(o=!0,i?t(i):r(n)))},l=u=&gt;{o||(o=!0,t(u))};for(let u=0;u&lt;e.length;u++)e[u].then(c=&gt;{n[u]=c,a()},c=&gt;{if(!zn(c)){l(c);return}c.batchRequestIdx===u?l(c):(i||(i=c),a())})})}v</span>ar rr=N("prisma:client");typeof globalThis=="object"&amp;&amp;(globalThis.NODE_CLIENT=!0);var Ff={requestArgsToMiddlewareArgs:e=&gt;e,middlewareArgsToRequestArgs:e=&gt;e},Mf=Symbol.for("prisma.client.transaction.id"),$f={id:0,<span class="fstat-no" title="function not covered" >nextId(){return++this.id}}</span>;function fu(e){class r{_originalClient=this;_runtimeDataModel;_requestHandler;_connectionPromise;_disconnectionPromise;_engineConfig;_accelerateEngineConfig;_clientVersion;_errorFormat;_tracingHelper;_previewFeatures;_activeProvider;_globalOmit;_extensions;_engine;_appliedParent;_createPrismaPromise=Ro();constructor(n){e=n<span class="branch-0 cbranch-no" title="branch not covered" >?.__internal?.configOverride?.(e)?</span>?e,sl(e),n<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;au(n,e);</span>let i=new du.EventEmitter().on("error",()=&gt;{});this._extensions=Nr.empty(),this._previewFeatures=$l(e),this._clientVersion=e.clientVersion<span class="branch-0 cbranch-no" title="branch not covered" >??ru,</span>this._activeProvider=e.activeProvider,this._globalOmit=n<span class="branch-0 cbranch-no" title="branch not covered" >?.omit,</span>this._tracingHelper=Hl();let o=e.relativeEnvPaths&amp;&amp;{rootEnvPath:e.relativeEnvPaths.rootEnvPath<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;ri.default.resolve(e.dirname,e.relativeEnvPaths.rootEnvPath),</span>schemaEnvPath:e.relativeEnvPaths.schemaEnvPath&amp;&amp;ri.default.resolve(e.dirname,e.relativeEnvPaths.schemaEnvPath)},s;if(n<span class="branch-0 cbranch-no" title="branch not covered" >?.adapter)<span class="branch-0 cbranch-no" title="branch not covered" ></span>{s=n.adapter;let l=e.activeProvider==="postgresql"||e.activeProvider==="cockroachdb"?"postgres":e.activeProvider;if(s.provider!==l)throw new P(`The Driver Adapter \`${s.adapterName}\`, based on \`${s.provider}\`, is not compatible with the provider \`${l}\` specified in the Prisma schema.`,this._clientVersion);if(n.datasources||n.datasourceUrl!==void 0)throw new P("Custom datasource configuration is not compatible with Prisma Driver Adapters. Please define the database connection string directly in the Driver Adapter configuration.",this._clientVersion)}l</span>et a=!s&amp;&amp;o&amp;&amp;st(o,{conflictCheck:"none"})<span class="branch-0 cbranch-no" title="branch not covered" >||e.injectableEdgeEnv?.();</span>try{let l=n??{},u=l.__internal??{},c=u.debug===!0;c<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;N.enable("prisma:client");</span>let p=ri.default.resolve(e.dirname,e.relativePath);mu.default.existsSync(p)<span class="branch-0 cbranch-no" title="branch not covered" >||(p=e.dirname),</span>rr("dirname",e.dirname),rr("relativePath",e.relativePath),rr("cwd",p);let d=u.engine||{};if(l.errorFormat<span class="branch-0 cbranch-no" title="branch not covered" >?this._errorFormat=l.errorFormat:</span>process.env.NODE_ENV==="production"<span class="branch-0 cbranch-no" title="branch not covered" >?this._errorFormat="minimal":</span>process.env.NO_COLOR<span class="branch-0 cbranch-no" title="branch not covered" >?this._errorFormat="colorless":</span>this._errorFormat="colorless",this._runtimeDataModel=e.runtimeDataModel,this._engineConfig={cwd:p,dirname:e.dirname,enableDebugLogs:c,allowTriggerPanic:d.allowTriggerPanic,prismaPath:d.binaryPath??void 0,engineEndpoint:d.endpoint,generator:e.generator,showColors:this._errorFormat==="pretty",logLevel:l.log<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;zl(l.log),</span>logQueries:l.log<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;!!(typeof l.log=="string"?l.log==="query":l.log.find(f=&gt;typeof f=="string"?f==="query":f.level==="query")),</span>env:a?.parsed<span class="branch-0 cbranch-no" title="branch not covered" >??{},</span>flags:[],engineWasm:e.engineWasm,compilerWasm:e.compilerWasm,clientVersion:e.clientVersion,engineVersion:e.engineVersion,previewFeatures:this._previewFeatures,activeProvider:e.activeProvider,inlineSchema:e.inlineSchema,overrideDatasources:al(l,e.datasourceNames),inlineDatasources:e.inlineDatasources,inlineSchemaHash:e.inlineSchemaHash,tracingHelper:this._tracingHelper,transactionOptions:{maxWait:l.transactionOptions<span class="branch-0 cbranch-no" title="branch not covered" >?.maxWait?</span>?2e3,timeout:l.transactionOptions<span class="branch-0 cbranch-no" title="branch not covered" >?.timeout?</span>?5e3,isolationLevel:l.transactionOptions<span class="branch-0 cbranch-no" title="branch not covered" >?.isolationLevel}</span>,logEmitter:i,isBundled:e.isBundled,adapter:s},this._accelerateEngineConfig={...this._engineConfig,accelerateUtils:{resolveDatasourceUrl:jr,getBatchRequestPayload:Mr,prismaGraphQLToJSError:$r,PrismaClientUnknownRequestError:V,PrismaClientInitializationError:P,PrismaClientKnownRequestError:z,debug:N("prisma:client:accelerateEngine"),engineVersion:cu.version,clientVersion:e.clientVersion}},rr("clientVersion",e.clientVersion),this._engine=Ml(e,this._engineConfig),this._requestHandler=new ei(this,i),l.log)<span class="branch-0 cbranch-no" title="branch not covered" >for(let f of l.log){let h=typeof f=="string"?f:f.emit==="stdout"?f.level:null;h&amp;&amp;this.$on(h,g=&gt;{nt.log(`${nt.tags[h]??""}`,g.message||g.query)})}}<span class="branch-0 cbranch-no" title="branch not covered" ></span>catch(l){throw l.clientVersion=this._clientVersion,l}r</span>eturn this._appliedParent=Pt(this)}get[Symbol.toStringTag](){return"PrismaClient"}<span class="fstat-no" title="function not covered" >$on(n,i){return n==="beforeExit"?this._engine.onBeforeExit(i):n&amp;&amp;this._engineConfig.logEmitter.on(n,i),this}<span class="fstat-no" title="function not covered" >$</span>connect(){try{return this._engine.start()}catch(n){throw n.clientVersion=this._clientVersion,n}}<span class="fstat-no" title="function not covered" >a</span>sync $disconnect(){try{await this._engine.stop()}catch(n){throw n.clientVersion=this._clientVersion,n}finally{Uo()}}<span class="fstat-no" title="function not covered" >$</span>executeRawInternal(n,i,o,s){let a=this._activeProvider;return this._request({action:"executeRaw",args:o,transaction:n,clientMethod:i,argsMapper:So({clientMethod:i,activeProvider:a}),callsite:Ze(this._errorFormat),dataPath:[],middlewareArgsMapper:s})}<span class="fstat-no" title="function not covered" >$</span>executeRaw(n,...i){return this._createPrismaPromise(o=&gt;{if(n.raw!==void 0||n.sql!==void 0){let[s,a]=uu(n,i);return To(this._activeProvider,s.text,s.values,Array.isArray(n)?"prisma.$executeRaw`&lt;SQL&gt;`":"prisma.$executeRaw(sql`&lt;SQL&gt;`)"),this.$executeRawInternal(o,"$executeRaw",s,a)}throw new Z("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n",{clientVersion:this._clientVersion})})}<span class="fstat-no" title="function not covered" >$</span>executeRawUnsafe(n,...i){return this._createPrismaPromise(o=&gt;(To(this._activeProvider,n,i,"prisma.$executeRawUnsafe(&lt;SQL&gt;, [...values])"),this.$executeRawInternal(o,"$executeRawUnsafe",[n,...i])))}<span class="fstat-no" title="function not covered" >$</span>runCommandRaw(n){if(e.activeProvider!=="mongodb")throw new Z(`The ${e.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`,{clientVersion:this._clientVersion});return this._createPrismaPromise(i=&gt;this._request({args:n,clientMethod:"$runCommandRaw",dataPath:[],action:"runCommandRaw",argsMapper:ql,callsite:Ze(this._errorFormat),transaction:i}))}<span class="fstat-no" title="function not covered" >a</span>sync $queryRawInternal(n,i,o,s){let a=this._activeProvider;return this._request({action:"queryRaw",args:o,transaction:n,clientMethod:i,argsMapper:So({clientMethod:i,activeProvider:a}),callsite:Ze(this._errorFormat),dataPath:[],middlewareArgsMapper:s})}<span class="fstat-no" title="function not covered" >$</span>queryRaw(n,...i){return this._createPrismaPromise(o=&gt;{if(n.raw!==void 0||n.sql!==void 0)return this.$queryRawInternal(o,"$queryRaw",...uu(n,i));throw new Z("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n",{clientVersion:this._clientVersion})})}<span class="fstat-no" title="function not covered" >$</span>queryRawTyped(n){return this._createPrismaPromise(i=&gt;{if(!this._hasPreviewFlag("typedSql"))throw new Z("`typedSql` preview feature must be enabled in order to access $queryRawTyped API",{clientVersion:this._clientVersion});return this.$queryRawInternal(i,"$queryRawTyped",n)})}<span class="fstat-no" title="function not covered" >$</span>queryRawUnsafe(n,...i){return this._createPrismaPromise(o=&gt;this.$queryRawInternal(o,"$queryRawUnsafe",[n,...i]))}<span class="fstat-no" title="function not covered" >_</span>transactionWithArray({promises:n,options:i}){let o=$f.nextId(),s=Yl(n.length),a=n.map((l,u)=&gt;{if(l?.[Symbol.toStringTag]!=="PrismaPromise")throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");let c=i?.isolationLevel??this._engineConfig.transactionOptions.isolationLevel,p={kind:"batch",id:o,index:u,isolationLevel:c,lock:s};return l.requestTransaction?.(p)??l});return lu(a)}<span class="fstat-no" title="function not covered" >a</span>sync _transactionWithCallback({callback:n,options:i}){let o={traceparent:this._tracingHelper.getTraceParent()},s={maxWait:i?.maxWait??this._engineConfig.transactionOptions.maxWait,timeout:i?.timeout??this._engineConfig.transactionOptions.timeout,isolationLevel:i?.isolationLevel??this._engineConfig.transactionOptions.isolationLevel},a=await this._engine.transaction("start",o,s),l;try{let u={kind:"itx",...a};l=await n(this._createItxClient(u)),await this._engine.transaction("commit",o,a)}catch(u){throw await this._engine.transaction("rollback",o,a).catch(()=&gt;{}),u}return l}<span class="fstat-no" title="function not covered" >_</span>createItxClient(n){return he(Pt(he(Qa(this),[re("_appliedParent",()=&gt;this._appliedParent._createItxClient(n)),re("_createPrismaPromise",()=&gt;Ro(n)),re(Mf,()=&gt;n.id)])),[Fr(Ya)])}<span class="fstat-no" title="function not covered" >$</span>transaction(n,i){let o;typeof n=="function"?this._engineConfig.adapter?.adapterName==="@prisma/adapter-d1"?o=()=&gt;{throw new Error("Cloudflare D1 does not support interactive transactions. We recommend you to refactor your queries with that limitation in mind, and use batch transactions with `prisma.$transactions([])` where applicable.")}:o=()=&gt;this._transactionWithCallback({callback:n,options:i}):o=()=&gt;this._transactionWithArray({promises:n,options:i});let s={name:"transaction",attributes:{method:"$transaction"}};return this._tracingHelper.runInChildSpan(s,o)}_</span>request(n){n.otelParentCtx=this._tracingHelper.getActiveContext();let i=n.middlewareArgsMapper??Ff,o={args:i.requestArgsToMiddlewareArgs(n.args),dataPath:n.dataPath,runInTransaction:!!n.transaction,action:n.action,model:n.model},s={operation:{name:"operation",attributes:{method:o.action,model:o.model,name:o.model?`${o.model}.${o.action}`<span class="branch-0 cbranch-no" title="branch not covered" >:o.action}</span>}},a=async l=&gt;{let{runInTransaction:u,args:c,...p}=l,d={...n,...p};c&amp;&amp;(d.args=i.middlewareArgsToRequestArgs(c)),n.transaction!==void 0<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;u===!1<span class="branch-0 cbranch-no" title="branch not covered" >&amp;</span>&amp;delete d.transaction;</span>let f=await el(this,d);return d.model?Ha({result:f,modelName:d.model,args:d.args,extensions:this._extensions,runtimeDataModel:this._runtimeDataModel,globalOmit:this._globalOmit})<span class="branch-0 cbranch-no" title="branch not covered" >:f}</span>;return this._tracingHelper.runInChildSpan(s.operation,()=&gt;new pu.AsyncResource("prisma-client-request").runInAsyncScope(()=&gt;a(o)))}async _executeRequest({args:n,clientMethod:i,dataPath:o,callsite:s,action:a,model:l,argsMapper:u,transaction:c,unpacker:p,otelParentCtx:d,customDataProxyFetch:f}){try{n=u<span class="branch-0 cbranch-no" title="branch not covered" >?u(n):</span>n;let h={name:"serialize"},g=this._tracingHelper.runInChildSpan(h,()=&gt;$n({modelName:l,runtimeDataModel:this._runtimeDataModel,action:a,args:n,clientMethod:i,callsite:s,extensions:this._extensions,errorFormat:this._errorFormat,clientVersion:this._clientVersion,previewFeatures:this._previewFeatures,globalOmit:this._globalOmit}));return N.enabled("prisma:client")<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(rr("Prisma Client call:"),rr(`prisma.${i}(${Na(n)})`),rr("Generated request:"),rr(JSON.stringify(g,null,2)+`</span>
`)),c<span class="branch-0 cbranch-no" title="branch not covered" >?.kind=</span>=="batch"<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;await c.lock,t</span>his._requestHandler.request({protocolQuery:g,modelName:l,action:a,clientMethod:i,dataPath:o,callsite:s,args:n,extensions:this._extensions,transaction:c,unpacker:p,otelParentCtx:d,otelChildCtx:this._tracingHelper.getActiveContext(),globalOmit:this._globalOmit,customDataProxyFetch:f})}<span class="branch-0 cbranch-no" title="branch not covered" >catch(h){throw h.clientVersion=this._clientVersion,h}}</span>$metrics=new Lr(this);<span class="fstat-no" title="function not covered" >_hasPreviewFlag(n){return!!this._engineConfig.previewFeatures?.includes(n)}<span class="fstat-no" title="function not covered" >$</span>applyPendingMigrations(){return this._engine.applyPendingMigrations()}$</span>extends=Wa}return r}<span class="fstat-no" title="function not covered" >function uu(e,r){return qf(e)?[new ie(e,r),Wl]:[e,Jl]}<span class="fstat-no" title="function not covered" >f</span>unction qf(e){return Array.isArray(e)&amp;&amp;Array.isArray(e.raw)}v</span>ar Vf=new Set(["toJSON","$$typeof","asymmetricMatch",Symbol.iterator,Symbol.toStringTag,Symbol.isConcatSpreadable,Symbol.toPrimitive]);<span class="fstat-no" title="function not covered" >function gu(e){return new Proxy(e,{get(r,t){if(t in r)return r[t];if(!Vf.has(t))throw new TypeError(`Invalid enum value: ${String(t)}`)}})}f</span>unction hu(e){st(e,{conflictCheck:"warn"})}0<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(module.exports={DMMF,Debug,Decimal,Extensions,MetricsClient,PrismaClientInitializationError,PrismaClientKnownRequestError,PrismaClientRustPanicError,PrismaClientUnknownRequestError,PrismaClientValidationError,Public,Sql,createParam,defineDmmfProperty,deserializeJsonResponse,deserializeRawResult,dmmfToRuntimeDataModel,empty,getPrismaClient,getRuntime,join,makeStrictEnum,makeTypedQueryFactory,objectEnumValues,raw,serializeJsonQuery,skip,sqltag,warnEnvConflicts,warnOnce});</span>
/*! Bundled license information:
&nbsp;
decimal.js/decimal.mjs:
  (*!
   *  decimal.js v10.5.0
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2025 Michael Mclaughlin &lt;M8ch88l@gmail.com&gt;
   *  MIT Licence
   *)
*/
//# sourceMappingURL=library.js.map
&nbsp;</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2025-10-05T21:09:30.898Z
            </div>
        <script src="../../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../../sorter.js"></script>
        <script src="../../../../block-navigation.js"></script>
    </body>
</html>
    